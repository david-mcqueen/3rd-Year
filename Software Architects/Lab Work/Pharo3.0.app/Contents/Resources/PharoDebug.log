THERE_BE_DRAGONS_HERE
MessageNotUnderstood: LOCell>>self
16 October 2014 3:48:09.569521 pm

VM: Mac OS - intel - 1090 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30858]

LOCell(Object)>>doesNotUnderstand: #self
	Receiver: a LOCell(932708352)
	Arguments and temporary variables: 
		aMessage: 	self
		exception: 	MessageNotUnderstood: LOCell>>self
		resumeValue: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (38@22)
		owner: 	nil
		submorphs: 	an Array(a StringMorph(12320768)'Flash')
		fullBounds: 	nil
		color: 	Color lightGray
		extension: 	a MorphExtension (988545024)
		borderWidth: 	3
		borderColor: 	Color gray
		target: 	nil
		actionSelector: 	#flash
		arguments: 	#()
		actWhen: 	#buttonUp
		oldColor: 	nil
		mouseDownTime: 	nil
		label: 	a StringMorph(12320768)'Flash'
		helpText: 	nil
		onColor: 	(Color r: 1.0 g: 0.6 b: 0.6 alpha: 1.0)
		offColor: 	Color lightGray
		mouseAction: 	nil


LOCell>>initialize
	Receiver: a LOCell(932708352)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (38@22)
		owner: 	nil
		submorphs: 	an Array(a StringMorph(12320768)'Flash')
		fullBounds: 	nil
		color: 	Color lightGray
		extension: 	a MorphExtension (988545024)
		borderWidth: 	3
		borderColor: 	Color gray
		target: 	nil
		actionSelector: 	#flash
		arguments: 	#()
		actWhen: 	#buttonUp
		oldColor: 	nil
		mouseDownTime: 	nil
		label: 	a StringMorph(12320768)'Flash'
		helpText: 	nil
		onColor: 	(Color r: 1.0 g: 0.6 b: 0.6 alpha: 1.0)
		offColor: 	Color lightGray
		mouseAction: 	nil


LOCell class(Behavior)>>new
	Receiver: LOCell
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	SimpleSwitchMorph
		methodDict: 	a MethodDictionary(#initialize->LOCell>>#initialize )
		format: 	168
		layout: 	a FixedLayout
		instanceVariables: 	#(#mouseAction)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#LOCell
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'PBE-LightsOut'
		traitComposition: 	{}
		localSelectors: 	nil
		announcer: 	nil


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'LOCell new'
		itsSelection: 	a Text for 'LOCell new'
		itsSelectionString: 	'LOCell new'
	Receiver's instance variables: 
		ast: 	DoIt
	^ LOCell new
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


SmalltalkEditor>>evaluateSelectionAndDo:
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | result inspect ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(381419520)
		selectionShowing: 	true
		model: 	a Workspace
		editingState: 	a SmalltalkEditingState


[ textMorph editor evaluateSelectionAndDo: [ :result | result inspect ] ] in PluggableTextMorph>>inspectIt
	Receiver: a PluggableTextMorph(570949632)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(372.0@535.0) corner: (812.0@702.0)
		owner: 	a SystemWindow(481034240)
		submorphs: 	an Array(a TransformMorph(508559360))
		fullBounds: 	(372@535) corner: (812@702)
		color: 	Color white
		extension: 	a MorphExtension (360185856) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(610795520)
		scroller: 	a TransformMorph(508559360)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(526123008)
		textMorph: 	a TextMorphForEditView(381419520)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 10)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


[ result := editBlock value ] in PluggableTextMorph>>handleEdit:
	Receiver: a PluggableTextMorph(570949632)
	Arguments and temporary variables: 
		editBlock: 	[ textMorph editor evaluateSelectionAndDo: [ :result | result inspec...etc...
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(372.0@535.0) corner: (812.0@702.0)
		owner: 	a SystemWindow(481034240)
		submorphs: 	an Array(a TransformMorph(508559360))
		fullBounds: 	(372@535) corner: (812@702)
		color: 	Color white
		extension: 	a MorphExtension (360185856) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(610795520)
		scroller: 	a TransformMorph(508559360)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(526123008)
		textMorph: 	a TextMorphForEditView(381419520)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 10)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


TextMorphForEditView(TextMorph)>>handleEdit:
	Receiver: a TextMorphForEditView(381419520)
	Arguments and temporary variables: 
		editBlock: 	[ result := editBlock value ]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@18)
		owner: 	a TransformMorph(508559360)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@18)
		color: 	Color black
		extension: 	a MorphExtension (436207616) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'LOCell new'
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(570949632)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


PluggableTextMorph>>handleEdit:
	Receiver: a PluggableTextMorph(570949632)
	Arguments and temporary variables: 
		result: 	nil
		editBlock: 	[ textMorph editor evaluateSelectionAndDo: [ :result | result inspec...etc...
	Receiver's instance variables: 
		bounds: 	(372.0@535.0) corner: (812.0@702.0)
		owner: 	a SystemWindow(481034240)
		submorphs: 	an Array(a TransformMorph(508559360))
		fullBounds: 	(372@535) corner: (812@702)
		color: 	Color white
		extension: 	a MorphExtension (360185856) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(610795520)
		scroller: 	a TransformMorph(508559360)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(526123008)
		textMorph: 	a TextMorphForEditView(381419520)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 10)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


PluggableTextMorph>>inspectIt
	Receiver: a PluggableTextMorph(570949632)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(372.0@535.0) corner: (812.0@702.0)
		owner: 	a SystemWindow(481034240)
		submorphs: 	an Array(a TransformMorph(508559360))
		fullBounds: 	(372@535) corner: (812@702)
		color: 	Color white
		extension: 	a MorphExtension (360185856) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(610795520)
		scroller: 	a TransformMorph(508559360)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(526123008)
		textMorph: 	a TextMorphForEditView(381419520)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 10)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


Workspace(Object)>>perform:orSendTo:
	Receiver: a Workspace
	Arguments and temporary variables: 
		selector: 	#inspectIt
		otherTarget: 	a PluggableTextMorph(570949632)
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(481034240) a PluggableTextMorph(57...etc...
		bindings: 	nil
		acceptDroppedMorphs: 	false
		acceptAction: 	nil
		mustDeclareVariables: 	false
		fileName: 	nil
		lineEnding: 	#cr
		encoding: 	'utf-8'
		stylingActive: 	true
		contents: 	''


[ 
| selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ 
		selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
	Receiver: a ToggleMenuItemMorph(162267136)'Inspect it'
	Arguments and temporary variables: 
		evt: 	[(474@435) mouseUp 866334 nil]
		w: 	a WorldMorph(511705088) [world]
		selArgCount: 	2
	Receiver's instance variables: 
		bounds: 	(403.0@427.0) corner: (546.0@445.0)
		owner: 	a MenuMorph(1049362432)
		submorphs: 	#()
		fullBounds: 	(403.0@427.0) corner: (546.0@445.0)
		color: 	Color black
		extension: 	a MorphExtension (185597952)
		font: 	a StrikeFont(Bitmap DejaVu Sans 9 14)
		emphasis: 	0
		contents: 	'Inspect it'
		hasFocus: 	false
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a Workspace
		selector: 	#perform:orSendTo:
		arguments: 	an Array(#inspectIt a PluggableTextMorph(570949632))
		icon: 	ColorForm(16x16x4)
		getStateSelector: 	nil
		enablementSelector: 	nil
		keyText: 	'i'


BlockClosure>>ensure:
	Receiver: [ 
| selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selec...etc...
	Arguments and temporary variables: 
		aBlock: 	[ oldcursor show ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
		startpc: 	134
		numArgs: 	0


CursorWithMask(Cursor)>>showWhile:
	Receiver: ((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0
		2r100000000000000000000...etc...
	Arguments and temporary variables: 
		aBlock: 	[ 
| selArgCount |
"show cursor in case item opens a new MVC window"
(s...etc...
		oldcursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0
		2...etc...
	Receiver's instance variables: 
		bits: 	a Bitmap of length 16
		width: 	16
		height: 	16
		depth: 	1
		offset: 	(-1@ -1)
		maskForm: 	Form(16x16x1)


ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
	Receiver: a ToggleMenuItemMorph(162267136)'Inspect it'
	Arguments and temporary variables: 
		evt: 	[(474@435) mouseUp 866334 nil]
		w: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		bounds: 	(403.0@427.0) corner: (546.0@445.0)
		owner: 	a MenuMorph(1049362432)
		submorphs: 	#()
		fullBounds: 	(403.0@427.0) corner: (546.0@445.0)
		color: 	Color black
		extension: 	a MorphExtension (185597952)
		font: 	a StrikeFont(Bitmap DejaVu Sans 9 14)
		emphasis: 	0
		contents: 	'Inspect it'
		hasFocus: 	false
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a Workspace
		selector: 	#perform:orSendTo:
		arguments: 	an Array(#inspectIt a PluggableTextMorph(570949632))
		icon: 	ColorForm(16x16x4)
		getStateSelector: 	nil
		enablementSelector: 	nil
		keyText: 	'i'


ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
	Receiver: a ToggleMenuItemMorph(162267136)'Inspect it'
	Arguments and temporary variables: 
		evt: 	[(474@435) mouseUp 866334 nil]
	Receiver's instance variables: 
		bounds: 	(403.0@427.0) corner: (546.0@445.0)
		owner: 	a MenuMorph(1049362432)
		submorphs: 	#()
		fullBounds: 	(403.0@427.0) corner: (546.0@445.0)
		color: 	Color black
		extension: 	a MorphExtension (185597952)
		font: 	a StrikeFont(Bitmap DejaVu Sans 9 14)
		emphasis: 	0
		contents: 	'Inspect it'
		hasFocus: 	false
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a Workspace
		selector: 	#perform:orSendTo:
		arguments: 	an Array(#inspectIt a PluggableTextMorph(570949632))
		icon: 	ColorForm(16x16x4)
		getStateSelector: 	nil
		enablementSelector: 	nil
		keyText: 	'i'


ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
	Receiver: a ToggleMenuItemMorph(162267136)'Inspect it'
	Arguments and temporary variables: 
		anEvent: 	[(474@435) mouseUp 866334 nil]
	Receiver's instance variables: 
		bounds: 	(403.0@427.0) corner: (546.0@445.0)
		owner: 	a MenuMorph(1049362432)
		submorphs: 	#()
		fullBounds: 	(403.0@427.0) corner: (546.0@445.0)
		color: 	Color black
		extension: 	a MorphExtension (185597952)
		font: 	a StrikeFont(Bitmap DejaVu Sans 9 14)
		emphasis: 	0
		contents: 	'Inspect it'
		hasFocus: 	false
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a Workspace
		selector: 	#perform:orSendTo:
		arguments: 	an Array(#inspectIt a PluggableTextMorph(570949632))
		icon: 	ColorForm(16x16x4)
		getStateSelector: 	nil
		enablementSelector: 	nil
		keyText: 	'i'


MouseButtonEvent>>sentTo:
	Receiver: [(474@435) mouseUp 866334 nil]
	Arguments and temporary variables: 
		anObject: 	a ToggleMenuItemMorph(162267136)'Inspect it'
	Receiver's instance variables: 
		timeStamp: 	866334
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(474@435)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


ToggleMenuItemMorph(Morph)>>handleEvent:
	Receiver: a ToggleMenuItemMorph(162267136)'Inspect it'
	Arguments and temporary variables: 
		anEvent: 	[(474@435) mouseUp 866334 nil]
	Receiver's instance variables: 
		bounds: 	(403.0@427.0) corner: (546.0@445.0)
		owner: 	a MenuMorph(1049362432)
		submorphs: 	#()
		fullBounds: 	(403.0@427.0) corner: (546.0@445.0)
		color: 	Color black
		extension: 	a MorphExtension (185597952)
		font: 	a StrikeFont(Bitmap DejaVu Sans 9 14)
		emphasis: 	0
		contents: 	'Inspect it'
		hasFocus: 	false
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a Workspace
		selector: 	#perform:orSendTo:
		arguments: 	an Array(#inspectIt a PluggableTextMorph(570949632))
		icon: 	ColorForm(16x16x4)
		getStateSelector: 	nil
		enablementSelector: 	nil
		keyText: 	'i'


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(474@435) mouseUp 866334 nil]
		aMorph: 	a ToggleMenuItemMorph(162267136)'Inspect it'
		localEvt: 	nil
		index: 	1
		child: 	nil
		morphs: 	#()
		inside: 	true
	Receiver's instance variables: 
		lastType: 	#mouseUp
		lastDispatch: 	#dispatchDefault:with:


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(474@435) mouseUp 866334 nil]
		aMorph: 	a ToggleMenuItemMorph(162267136)'Inspect it'
	Receiver's instance variables: 
		lastType: 	#mouseUp
		lastDispatch: 	#dispatchDefault:with:


ToggleMenuItemMorph(Morph)>>processEvent:using:
	Receiver: a ToggleMenuItemMorph(162267136)'Inspect it'
	Arguments and temporary variables: 
		anEvent: 	[(474@435) mouseUp 866334 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(403.0@427.0) corner: (546.0@445.0)
		owner: 	a MenuMorph(1049362432)
		submorphs: 	#()
		fullBounds: 	(403.0@427.0) corner: (546.0@445.0)
		color: 	Color black
		extension: 	a MorphExtension (185597952)
		font: 	a StrikeFont(Bitmap DejaVu Sans 9 14)
		emphasis: 	0
		contents: 	'Inspect it'
		hasFocus: 	false
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a Workspace
		selector: 	#perform:orSendTo:
		arguments: 	an Array(#inspectIt a PluggableTextMorph(570949632))
		icon: 	ColorForm(16x16x4)
		getStateSelector: 	nil
		enablementSelector: 	nil
		keyText: 	'i'


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(474@435) mouseUp 866334 nil]
		aMorph: 	a MenuMorph(1049362432)
		localEvt: 	[(474@435) mouseUp 866334 nil]
		index: 	3
		child: 	a ToggleMenuItemMorph(162267136)'Inspect it'
		morphs: 	an Array(a ToggleMenuItemMorph(1021313024)'Do it' a ToggleMenuItemMorph...etc...
		inside: 	false
	Receiver's instance variables: 
		lastType: 	#mouseUp
		lastDispatch: 	#dispatchDefault:with:


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(474@435) mouseUp 866334 nil]
		aMorph: 	a MenuMorph(1049362432)
	Receiver's instance variables: 
		lastType: 	#mouseUp
		lastDispatch: 	#dispatchDefault:with:


MenuMorph(Morph)>>processEvent:using:
	Receiver: a MenuMorph(1049362432)
	Arguments and temporary variables: 
		anEvent: 	[(474@435) mouseUp 866334 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(398.0@384.0) corner: (551.0@724.0)
		owner: 	nil
		submorphs: 	an Array(a ToggleMenuItemMorph(1021313024)'Do it' a ToggleMenuItemMo...etc...
		fullBounds: 	(398.0@384.0) corner: (551.0@724.0)
		color: 	(Color r: 0.894 g: 0.894 b: 0.894 alpha: 1.0)
		extension: 	a MorphExtension (11010048) [other:  (basicColor -> (Color r: 0.8230...etc...
		borderWidth: 	2
		borderColor: 	(Color r: 0.674 g: 0.674 b: 0.674 alpha: 1.0)
		defaultTarget: 	a Workspace
		selectedItem: 	a ToggleMenuItemMorph(162267136)'Inspect it'
		stayUp: 	false
		popUpOwner: 	nil
		activeSubMenu: 	nil
		activatorDockingBar: 	nil
		embeddable: 	nil
		menuItems: 	an OrderedCollection(a ToggleMenuItemMorph(1021313024)'Do it' a Togg...etc...


MenuMorph(Morph)>>processEvent:
	Receiver: a MenuMorph(1049362432)
	Arguments and temporary variables: 
		anEvent: 	[(474@435) mouseUp 866334 nil]
	Receiver's instance variables: 
		bounds: 	(398.0@384.0) corner: (551.0@724.0)
		owner: 	nil
		submorphs: 	an Array(a ToggleMenuItemMorph(1021313024)'Do it' a ToggleMenuItemMo...etc...
		fullBounds: 	(398.0@384.0) corner: (551.0@724.0)
		color: 	(Color r: 0.894 g: 0.894 b: 0.894 alpha: 1.0)
		extension: 	a MorphExtension (11010048) [other:  (basicColor -> (Color r: 0.8230...etc...
		borderWidth: 	2
		borderColor: 	(Color r: 0.674 g: 0.674 b: 0.674 alpha: 1.0)
		defaultTarget: 	a Workspace
		selectedItem: 	a ToggleMenuItemMorph(162267136)'Inspect it'
		stayUp: 	false
		popUpOwner: 	nil
		activeSubMenu: 	nil
		activatorDockingBar: 	nil
		embeddable: 	nil
		menuItems: 	an OrderedCollection(a ToggleMenuItemMorph(1021313024)'Do it' a Togg...etc...


MenuMorph>>handleFocusEvent:
	Receiver: a MenuMorph(1049362432)
	Arguments and temporary variables: 
		evt: 	[(474@435) mouseUp 866334 nil]
	Receiver's instance variables: 
		bounds: 	(398.0@384.0) corner: (551.0@724.0)
		owner: 	nil
		submorphs: 	an Array(a ToggleMenuItemMorph(1021313024)'Do it' a ToggleMenuItemMo...etc...
		fullBounds: 	(398.0@384.0) corner: (551.0@724.0)
		color: 	(Color r: 0.894 g: 0.894 b: 0.894 alpha: 1.0)
		extension: 	a MorphExtension (11010048) [other:  (basicColor -> (Color r: 0.8230...etc...
		borderWidth: 	2
		borderColor: 	(Color r: 0.674 g: 0.674 b: 0.674 alpha: 1.0)
		defaultTarget: 	a Workspace
		selectedItem: 	a ToggleMenuItemMorph(162267136)'Inspect it'
		stayUp: 	false
		popUpOwner: 	nil
		activeSubMenu: 	nil
		activatorDockingBar: 	nil
		embeddable: 	nil
		menuItems: 	an OrderedCollection(a ToggleMenuItemMorph(1021313024)'Do it' a Togg...etc...


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(474@435) mouseUp 866334 nil]
		focusHolder: 	a MenuMorph(1049362432)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(474@435) corner: (490@451)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(474@435) corner: (490@451)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(474@435) mouseUp 866334 nil]
		targetOffset: 	(71.0@8.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 866334 474 435 0 0 0 1)
		lastKeyScanCode: 	51
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	[(474@435) mouseOver red nil nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1064@742)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SystemWindow(481034240) a Nauti...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(474@435) mouseUp 866334 nil]
		focusHolder: 	a MenuMorph(1049362432)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		bounds: 	(474@435) corner: (490@451)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(474@435) corner: (490@451)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(474@435) mouseUp 866334 nil]
		targetOffset: 	(71.0@8.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 866334 474 435 0 0 0 1)
		lastKeyScanCode: 	51
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(474@435) mouseUp 866334 nil]
		focusHolder: 	a MenuMorph(1049362432)
		aBlock: 	[ self mouseFocus: nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(474@435) corner: (490@451)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(474@435) corner: (490@451)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(474@435) mouseUp 866334 nil]
		targetOffset: 	(71.0@8.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 866334 474 435 0 0 0 1)
		lastKeyScanCode: 	51
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(474@435) mouseUp 866334 nil]
	Receiver's instance variables: 
		bounds: 	(474@435) corner: (490@451)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(474@435) corner: (490@451)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(474@435) mouseUp 866334 nil]
		targetOffset: 	(71.0@8.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 866334 474 435 0 0 0 1)
		lastKeyScanCode: 	51
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>handleEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(474@435) mouseUp 866334 nil]
		evt: 	[(474@435) mouseUp 866334 nil]
	Receiver's instance variables: 
		bounds: 	(474@435) corner: (490@451)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(474@435) mouseOver nil nil]
		targetOffset: 	(71.0@8.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 866334 474 435 0 0 0 1)
		lastKeyScanCode: 	51
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>processEvents
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		evt: 	[(474@435) mouseUp 866334 nil]
		evtBuf: 	#(1 866334 474 435 0 0 0 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	(474@449) corner: (490@465)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(474@449) corner: (490@465)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(474@449) mouseOver nil nil]
		targetOffset: 	(71.0@8.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 866554 474 449 0 0 0 1)
		lastKeyScanCode: 	51
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		h: 	a HandMorph(760479744)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1064@742)
		canvas: 	a FormCanvas on: DisplayScreen(1064x742x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(612892672))(a SearchMorp...etc...
		lastStepTime: 	866554
		lastStepMessage: 	nil
		lastCycleTime: 	866554
		alarms: 	a Heap()
		lastAlarmTime: 	866554
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(760479744))
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(760479744))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1064@742)
		canvas: 	a FormCanvas on: DisplayScreen(1064x742x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(612892672))(a SearchMorp...etc...
		lastStepTime: 	866554
		lastStepMessage: 	nil
		lastCycleTime: 	866554
		alarms: 	a Heap()
		lastAlarmTime: 	866554
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 



--- The full stack ---
LOCell(Object)>>doesNotUnderstand: #self
LOCell>>initialize
LOCell class(Behavior)>>new
UndefinedObject>>DoIt
OpalCompiler>>evaluate
SmalltalkEditor>>evaluateSelectionAndDo:
[ textMorph editor evaluateSelectionAndDo: [ :result | result inspect ] ] in PluggableTextMorph>>inspectIt
[ result := editBlock value ] in PluggableTextMorph>>handleEdit:
TextMorphForEditView(TextMorph)>>handleEdit:
PluggableTextMorph>>handleEdit:
PluggableTextMorph>>inspectIt
Workspace(Object)>>perform:orSendTo:
[ 
| selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ 
		selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldState>>doOneSubCycleFor:
WorldMorph>>doOneSubCycle
MenuMorph>>invokeModalAt:in:allowKeyboard:
MenuMorph>>invokeModal:
MenuMorph>>invokeModal
PluggableTextMorph>>yellowButtonActivity:
SmalltalkEditor(TextEditor)>>mouseUp:
[ editor mouseUp: evt ] in TextMorphForEditView(TextMorph)>>mouseUp:
TextMorphForEditView(TextMorph)>>handleInteraction:
TextMorphForEditView>>handleInteraction:
TextMorphForEditView(TextMorph)>>mouseUp:
TextMorphForEditView>>mouseUp:
TextMorphForEditView(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
TextMorphForEditView(Morph)>>handleEvent:
TextMorphForEditView(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: LOCell>>self
16 October 2014 3:49:34.881765 pm

VM: Mac OS - intel - 1090 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30858]

LOCell(Object)>>doesNotUnderstand: #self
	Receiver: a LOCell(803733504)
	Arguments and temporary variables: 
		aMessage: 	self
		exception: 	MessageNotUnderstood: LOCell>>self
		resumeValue: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (38@22)
		owner: 	nil
		submorphs: 	an Array(a StringMorph(963117056)'Flash')
		fullBounds: 	nil
		color: 	Color lightGray
		extension: 	a MorphExtension (865599488)
		borderWidth: 	3
		borderColor: 	Color gray
		target: 	nil
		actionSelector: 	#flash
		arguments: 	#()
		actWhen: 	#buttonUp
		oldColor: 	nil
		mouseDownTime: 	nil
		label: 	a StringMorph(963117056)'Flash'
		helpText: 	nil
		onColor: 	(Color r: 1.0 g: 0.6 b: 0.6 alpha: 1.0)
		offColor: 	Color lightGray
		mouseAction: 	nil


LOCell>>initialize
	Receiver: a LOCell(803733504)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (38@22)
		owner: 	nil
		submorphs: 	an Array(a StringMorph(963117056)'Flash')
		fullBounds: 	nil
		color: 	Color lightGray
		extension: 	a MorphExtension (865599488)
		borderWidth: 	3
		borderColor: 	Color gray
		target: 	nil
		actionSelector: 	#flash
		arguments: 	#()
		actWhen: 	#buttonUp
		oldColor: 	nil
		mouseDownTime: 	nil
		label: 	a StringMorph(963117056)'Flash'
		helpText: 	nil
		onColor: 	(Color r: 1.0 g: 0.6 b: 0.6 alpha: 1.0)
		offColor: 	Color lightGray
		mouseAction: 	nil


LOCell class(Behavior)>>new
	Receiver: LOCell
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	SimpleSwitchMorph
		methodDict: 	a MethodDictionary(#initialize->LOCell>>#initialize )
		format: 	168
		layout: 	a FixedLayout
		instanceVariables: 	#(#mouseAction)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#LOCell
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'PBE-LightsOut'
		traitComposition: 	{}
		localSelectors: 	nil
		announcer: 	nil


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'LOCell new
'
		itsSelection: 	a Text for 'LOCell new
'
		itsSelectionString: 	'LOCell new
'
	Receiver's instance variables: 
		ast: 	DoIt
	^ LOCell new
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


SmalltalkEditor>>evaluateSelectionAndDo:
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | result inspect ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(381419520)
		selectionShowing: 	true
		model: 	a Workspace
		editingState: 	a SmalltalkEditingState


[ textMorph editor evaluateSelectionAndDo: [ :result | result inspect ] ] in PluggableTextMorph>>inspectIt
	Receiver: a PluggableTextMorph(570949632)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(372.0@535.0) corner: (812.0@702.0)
		owner: 	a SystemWindow(481034240)
		submorphs: 	an Array(a TransformMorph(508559360))
		fullBounds: 	(372@535) corner: (812@702)
		color: 	Color white
		extension: 	a MorphExtension (360185856) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(610795520)
		scroller: 	a TransformMorph(508559360)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(526123008)
		textMorph: 	a TextMorphForEditView(381419520)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 11)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


[ result := editBlock value ] in PluggableTextMorph>>handleEdit:
	Receiver: a PluggableTextMorph(570949632)
	Arguments and temporary variables: 
		editBlock: 	[ textMorph editor evaluateSelectionAndDo: [ :result | result inspec...etc...
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(372.0@535.0) corner: (812.0@702.0)
		owner: 	a SystemWindow(481034240)
		submorphs: 	an Array(a TransformMorph(508559360))
		fullBounds: 	(372@535) corner: (812@702)
		color: 	Color white
		extension: 	a MorphExtension (360185856) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(610795520)
		scroller: 	a TransformMorph(508559360)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(526123008)
		textMorph: 	a TextMorphForEditView(381419520)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 11)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


TextMorphForEditView(TextMorph)>>handleEdit:
	Receiver: a TextMorphForEditView(381419520)
	Arguments and temporary variables: 
		editBlock: 	[ result := editBlock value ]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@34)
		owner: 	a TransformMorph(508559360)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@34)
		color: 	Color black
		extension: 	a MorphExtension (436207616) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'LOCell new
'
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(570949632)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


PluggableTextMorph>>handleEdit:
	Receiver: a PluggableTextMorph(570949632)
	Arguments and temporary variables: 
		result: 	nil
		editBlock: 	[ textMorph editor evaluateSelectionAndDo: [ :result | result inspec...etc...
	Receiver's instance variables: 
		bounds: 	(372.0@535.0) corner: (812.0@702.0)
		owner: 	a SystemWindow(481034240)
		submorphs: 	an Array(a TransformMorph(508559360))
		fullBounds: 	(372@535) corner: (812@702)
		color: 	Color white
		extension: 	a MorphExtension (360185856) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(610795520)
		scroller: 	a TransformMorph(508559360)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(526123008)
		textMorph: 	a TextMorphForEditView(381419520)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 11)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


PluggableTextMorph>>inspectIt
	Receiver: a PluggableTextMorph(570949632)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(372.0@535.0) corner: (812.0@702.0)
		owner: 	a SystemWindow(481034240)
		submorphs: 	an Array(a TransformMorph(508559360))
		fullBounds: 	(372@535) corner: (812@702)
		color: 	Color white
		extension: 	a MorphExtension (360185856) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(610795520)
		scroller: 	a TransformMorph(508559360)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(526123008)
		textMorph: 	a TextMorphForEditView(381419520)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 11)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


[ :morph | morph inspectIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
	Receiver: SmalltalkEditor
	Arguments and temporary variables: 
		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a PluggableTextMorph(570949632)
	Receiver's instance variables: 
		superclass: 	TextEditor
		methodDict: 	a MethodDictionary(#argAdvance:->SmalltalkEditor>>#argAdvance: #bro...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SmalltalkEditor
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Text-Edition'
		traitComposition: 	{}
		localSelectors: 	nil
		cmdActions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop...etc...
		shiftCmdActions: 	#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #m...etc...


BlockClosure>>cull:
	Receiver: [ :morph | morph inspectIt ]
	Arguments and temporary variables: 
		anArg: 	a PluggableTextMorph(570949632)
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	182
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :morph | morph inspectIt ]
	Arguments and temporary variables: 
		firstArg: 	a PluggableTextMorph(570949632)
		secondArg: 	a PluggableTextMorph(570949632)
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	182
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :morph | morph inspectIt ]
	Arguments and temporary variables: 
		firstArg: 	a PluggableTextMorph(570949632)
		secondArg: 	a PluggableTextMorph(570949632)
		thirdArg: 	[keystroke '<Cmd-i>']
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	182
		numArgs: 	1


KMCategoryBinding>>completeMatch:buffer:
	Receiver: aKMCategoryTarget(#SmalltalkEditor)
	Arguments and temporary variables: 
		aKeymap: 	#inspectIt on Cmd + I do [ :morph | morph inspectIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
	Receiver's instance variables: 
		target: 	a PluggableTextMorph(570949632)
		category: 	a KMCategory
		morph: 	a PluggableTextMorph(570949632)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #inspectIt on Cmd + I do [ :morph | morph inspectIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		l: 	aKMCategoryTarget(#SmalltalkEditor)
	Receiver's instance variables: 
		action: 	[ :morph | morph inspectIt ]
		name: 	#inspectIt
		shortcut: 	Cmd + I
		defaultShortcut: 	Cmd + I
		description: 	''


Array(SequenceableCollection)>>do:
	Receiver: an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #inspectIt on Cmd + I do [ :morph | morph inspectIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ :morph | morph inspectIt ]
		name: 	#inspectIt
		shortcut: 	Cmd + I
		defaultShortcut: 	Cmd + I
		description: 	''


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: #inspectIt on Cmd + I do [ :morph | morph inspectIt ]

	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		action: 	[ :morph | morph inspectIt ]
		name: 	#inspectIt
		shortcut: 	Cmd + I
		defaultShortcut: 	Cmd + I
		description: 	''


[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#inspectIt on Cmd + I do [ :morph | morph inspectIt ]

	Receiver's instance variables: 
		name: 	#SmalltalkEditor
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


Set>>do:
	Receiver: a Set(#printIt on Cmd + P do [ :morph | morph printIt ]
 #previousSelection on Cmd + Shift...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	13
		each: 	#inspectIt on Cmd + I do [ :morph | morph inspectIt ]

	Receiver's instance variables: 
		tally: 	14
		array: 	an Array(#printIt on Cmd + P do [ :morph | morph printIt ]
 #previousSel...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
	Receiver's instance variables: 
		name: 	#SmalltalkEditor
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: aKMCategoryTarget(#SmalltalkEditor)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		target: 	a PluggableTextMorph(570949632)
		category: 	a KMCategory
		morph: 	a PluggableTextMorph(570949632)


[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#SmalltalkEditor)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#SmalltalkEditor) aKMCategoryTarget(#TextMorph...etc...
		morph: 	a PluggableTextMorph(570949632)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#SmalltalkEditor) aKMCategor...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	2
	Receiver's instance variables: 
		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#SmalltalkEditor) aKMC...etc...
		firstIndex: 	1
		lastIndex: 	7


KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		association: 	nil
		match: 	nil
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#SmalltalkEditor) aKMCategoryTarget(#TextMorph...etc...
		morph: 	a PluggableTextMorph(570949632)
		directKeymaps: 	a KMCategory


KMTarget>>dispatch:
	Receiver: a KMTarget
	Arguments and temporary variables: 
		buffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
	Receiver's instance variables: 
		realTarget: 	nil
		morph: 	a PluggableTextMorph(570949632)
		targetSelector: 	#yourself
		directKeymaps: 	nil
		perInstanceCategories: 	nil


[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Cmd-i>']
		targetToDispatch: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>do:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Cmd-i>']
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatcher>>dispatchKeystroke:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		aKeyEvent: 	[keystroke '<Cmd-i>']
		chain: 	a KMDispatchChain
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#MorphFocusCtrlN...etc...
		morph: 	a TextMorphForEditView(381419520)
		directKeymaps: 	a KMCategory


TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
	Receiver: a TextMorphForEditView(381419520)
	Arguments and temporary variables: 
		evt: 	[keystroke '<Cmd-i>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@34)
		owner: 	a TransformMorph(508559360)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@34)
		color: 	Color black
		extension: 	a MorphExtension (436207616) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'LOCell new
'
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(570949632)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(TextMorph)>>handleKeystroke:
	Receiver: a TextMorphForEditView(381419520)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-i>']
		pasteUp: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@34)
		owner: 	a TransformMorph(508559360)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@34)
		color: 	Color black
		extension: 	a MorphExtension (436207616) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'LOCell new
'
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(570949632)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


KeyboardEvent>>sentTo:
	Receiver: [keystroke '<Cmd-i>']
	Arguments and temporary variables: 
		anObject: 	a TextMorphForEditView(381419520)
	Receiver's instance variables: 
		timeStamp: 	951666
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#keystroke
		buttons: 	64
		position: 	(136@22.0)
		handler: 	nil
		wasHandled: 	true
		keyValue: 	105
		charCode: 	105
		scanCode: 	34


TextMorphForEditView(Morph)>>handleEvent:
	Receiver: a TextMorphForEditView(381419520)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-i>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@34)
		owner: 	a TransformMorph(508559360)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@34)
		color: 	Color black
		extension: 	a MorphExtension (436207616) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'LOCell new
'
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(570949632)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(Morph)>>handleFocusEvent:
	Receiver: a TextMorphForEditView(381419520)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-i>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@34)
		owner: 	a TransformMorph(508559360)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@34)
		color: 	Color black
		extension: 	a MorphExtension (436207616) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'LOCell new
'
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(570949632)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-i>']
		focusHolder: 	a TextMorphForEditView(381419520)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(504@549) corner: (520@565)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(504@549) corner: (520@565)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a TextMorphForEditView(381419520)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(512@558) mouseOver nil nil]
		targetOffset: 	(136@22.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	Form(16x16x8)
		temporaryCursorOffset: 	(-8@ -9)
		hardwareCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r...etc...
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 936192 512 558 0 0 0 1)
		lastKeyScanCode: 	34
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	8


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0



--- The full stack ---
LOCell(Object)>>doesNotUnderstand: #self
LOCell>>initialize
LOCell class(Behavior)>>new
UndefinedObject>>DoIt
OpalCompiler>>evaluate
SmalltalkEditor>>evaluateSelectionAndDo:
[ textMorph editor evaluateSelectionAndDo: [ :result | result inspect ] ] in PluggableTextMorph>>inspectIt
[ result := editBlock value ] in PluggableTextMorph>>handleEdit:
TextMorphForEditView(TextMorph)>>handleEdit:
PluggableTextMorph>>handleEdit:
PluggableTextMorph>>inspectIt
[ :morph | morph inspectIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
TextMorphForEditView(TextMorph)>>handleKeystroke:
KeyboardEvent>>sentTo:
TextMorphForEditView(Morph)>>handleEvent:
TextMorphForEditView(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: LOCell>>self
16 October 2014 3:51:18.319505 pm

VM: Mac OS - intel - 1090 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30858]

LOCell(Object)>>doesNotUnderstand: #self
	Receiver: a LOCell(272367616)
	Arguments and temporary variables: 
		aMessage: 	self
		exception: 	MessageNotUnderstood: LOCell>>self
		resumeValue: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (38@22)
		owner: 	nil
		submorphs: 	an Array(a StringMorph(425721856)'Flash')
		fullBounds: 	nil
		color: 	Color lightGray
		extension: 	a MorphExtension (328204288)
		borderWidth: 	3
		borderColor: 	Color gray
		target: 	nil
		actionSelector: 	#flash
		arguments: 	#()
		actWhen: 	#buttonUp
		oldColor: 	nil
		mouseDownTime: 	nil
		label: 	a StringMorph(425721856)'Flash'
		helpText: 	nil
		onColor: 	(Color r: 1.0 g: 0.6 b: 0.6 alpha: 1.0)
		offColor: 	Color lightGray
		mouseAction: 	nil


LOCell>>initialize
	Receiver: a LOCell(272367616)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (38@22)
		owner: 	nil
		submorphs: 	an Array(a StringMorph(425721856)'Flash')
		fullBounds: 	nil
		color: 	Color lightGray
		extension: 	a MorphExtension (328204288)
		borderWidth: 	3
		borderColor: 	Color gray
		target: 	nil
		actionSelector: 	#flash
		arguments: 	#()
		actWhen: 	#buttonUp
		oldColor: 	nil
		mouseDownTime: 	nil
		label: 	a StringMorph(425721856)'Flash'
		helpText: 	nil
		onColor: 	(Color r: 1.0 g: 0.6 b: 0.6 alpha: 1.0)
		offColor: 	Color lightGray
		mouseAction: 	nil


LOCell class(Behavior)>>new
	Receiver: LOCell
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	SimpleSwitchMorph
		methodDict: 	a MethodDictionary(#initialize->LOCell>>#initialize )
		format: 	168
		layout: 	a FixedLayout
		instanceVariables: 	#(#mouseAction)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#LOCell
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'PBE-LightsOut'
		traitComposition: 	{}
		localSelectors: 	nil
		announcer: 	nil


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'LOCell new
'
		itsSelection: 	a Text for 'LOCell new
'
		itsSelectionString: 	'LOCell new
'
	Receiver's instance variables: 
		ast: 	DoIt
	^ LOCell new
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


SmalltalkEditor>>evaluateSelectionAndDo:
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(381419520)
		selectionShowing: 	true
		model: 	a Workspace
		editingState: 	a SmalltalkEditingState


SmalltalkEditor>>evaluateSelection
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(381419520)
		selectionShowing: 	true
		model: 	a Workspace
		editingState: 	a SmalltalkEditingState


[ textMorph editor evaluateSelection ] in PluggableTextMorph>>doIt
	Receiver: a PluggableTextMorph(570949632)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(488.0@523.0) corner: (928.0@690.0)
		owner: 	a SystemWindow(481034240)
		submorphs: 	an Array(a TransformMorph(508559360))
		fullBounds: 	(488@523) corner: (928@690)
		color: 	Color white
		extension: 	a MorphExtension (360185856) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(610795520)
		scroller: 	a TransformMorph(508559360)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(526123008)
		textMorph: 	a TextMorphForEditView(381419520)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 11)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


[ result := editBlock value ] in PluggableTextMorph>>handleEdit:
	Receiver: a PluggableTextMorph(570949632)
	Arguments and temporary variables: 
		editBlock: 	[ textMorph editor evaluateSelection ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(488.0@523.0) corner: (928.0@690.0)
		owner: 	a SystemWindow(481034240)
		submorphs: 	an Array(a TransformMorph(508559360))
		fullBounds: 	(488@523) corner: (928@690)
		color: 	Color white
		extension: 	a MorphExtension (360185856) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(610795520)
		scroller: 	a TransformMorph(508559360)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(526123008)
		textMorph: 	a TextMorphForEditView(381419520)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 11)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


TextMorphForEditView(TextMorph)>>handleEdit:
	Receiver: a TextMorphForEditView(381419520)
	Arguments and temporary variables: 
		editBlock: 	[ result := editBlock value ]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@34)
		owner: 	a TransformMorph(508559360)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@34)
		color: 	Color black
		extension: 	a MorphExtension (436207616) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'LOCell new
'
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(570949632)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


PluggableTextMorph>>handleEdit:
	Receiver: a PluggableTextMorph(570949632)
	Arguments and temporary variables: 
		result: 	nil
		editBlock: 	[ textMorph editor evaluateSelection ]
	Receiver's instance variables: 
		bounds: 	(488.0@523.0) corner: (928.0@690.0)
		owner: 	a SystemWindow(481034240)
		submorphs: 	an Array(a TransformMorph(508559360))
		fullBounds: 	(488@523) corner: (928@690)
		color: 	Color white
		extension: 	a MorphExtension (360185856) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(610795520)
		scroller: 	a TransformMorph(508559360)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(526123008)
		textMorph: 	a TextMorphForEditView(381419520)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 11)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


PluggableTextMorph>>doIt
	Receiver: a PluggableTextMorph(570949632)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(488.0@523.0) corner: (928.0@690.0)
		owner: 	a SystemWindow(481034240)
		submorphs: 	an Array(a TransformMorph(508559360))
		fullBounds: 	(488@523) corner: (928@690)
		color: 	Color white
		extension: 	a MorphExtension (360185856) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(610795520)
		scroller: 	a TransformMorph(508559360)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(526123008)
		textMorph: 	a TextMorphForEditView(381419520)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 11)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


[ :morph | morph doIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
	Receiver: SmalltalkEditor
	Arguments and temporary variables: 
		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a PluggableTextMorph(570949632)
	Receiver's instance variables: 
		superclass: 	TextEditor
		methodDict: 	a MethodDictionary(#argAdvance:->SmalltalkEditor>>#argAdvance: #bro...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SmalltalkEditor
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Text-Edition'
		traitComposition: 	{}
		localSelectors: 	nil
		cmdActions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop...etc...
		shiftCmdActions: 	#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #m...etc...


BlockClosure>>cull:
	Receiver: [ :morph | morph doIt ]
	Arguments and temporary variables: 
		anArg: 	a PluggableTextMorph(570949632)
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	157
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :morph | morph doIt ]
	Arguments and temporary variables: 
		firstArg: 	a PluggableTextMorph(570949632)
		secondArg: 	a PluggableTextMorph(570949632)
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	157
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :morph | morph doIt ]
	Arguments and temporary variables: 
		firstArg: 	a PluggableTextMorph(570949632)
		secondArg: 	a PluggableTextMorph(570949632)
		thirdArg: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	157
		numArgs: 	1


KMCategoryBinding>>completeMatch:buffer:
	Receiver: aKMCategoryTarget(#SmalltalkEditor)
	Arguments and temporary variables: 
		aKeymap: 	#doIt on Cmd + D do [ :morph | morph doIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
	Receiver's instance variables: 
		target: 	a PluggableTextMorph(570949632)
		category: 	a KMCategory
		morph: 	a PluggableTextMorph(570949632)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #doIt on Cmd + D do [ :morph | morph doIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		l: 	aKMCategoryTarget(#SmalltalkEditor)
	Receiver's instance variables: 
		action: 	[ :morph | morph doIt ]
		name: 	#doIt
		shortcut: 	Cmd + D
		defaultShortcut: 	Cmd + D
		description: 	''


Array(SequenceableCollection)>>do:
	Receiver: an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #doIt on Cmd + D do [ :morph | morph doIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ :morph | morph doIt ]
		name: 	#doIt
		shortcut: 	Cmd + D
		defaultShortcut: 	Cmd + D
		description: 	''


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: #doIt on Cmd + D do [ :morph | morph doIt ]

	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		action: 	[ :morph | morph doIt ]
		name: 	#doIt
		shortcut: 	Cmd + D
		defaultShortcut: 	Cmd + D
		description: 	''


[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#doIt on Cmd + D do [ :morph | morph doIt ]

	Receiver's instance variables: 
		name: 	#SmalltalkEditor
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


Set>>do:
	Receiver: a Set(#printIt on Cmd + P do [ :morph | morph printIt ]
 #previousSelection on Cmd + Shift...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	9
		each: 	#doIt on Cmd + D do [ :morph | morph doIt ]

	Receiver's instance variables: 
		tally: 	14
		array: 	an Array(#printIt on Cmd + P do [ :morph | morph printIt ]
 #previousSel...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
	Receiver's instance variables: 
		name: 	#SmalltalkEditor
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: aKMCategoryTarget(#SmalltalkEditor)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		target: 	a PluggableTextMorph(570949632)
		category: 	a KMCategory
		morph: 	a PluggableTextMorph(570949632)


[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#SmalltalkEditor)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#SmalltalkEditor) aKMCategoryTarget(#TextMorph...etc...
		morph: 	a PluggableTextMorph(570949632)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#SmalltalkEditor) aKMCategor...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	2
	Receiver's instance variables: 
		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#SmalltalkEditor) aKMC...etc...
		firstIndex: 	1
		lastIndex: 	7


KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		association: 	nil
		match: 	nil
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#SmalltalkEditor) aKMCategoryTarget(#TextMorph...etc...
		morph: 	a PluggableTextMorph(570949632)
		directKeymaps: 	a KMCategory


KMTarget>>dispatch:
	Receiver: a KMTarget
	Arguments and temporary variables: 
		buffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
	Receiver's instance variables: 
		realTarget: 	nil
		morph: 	a PluggableTextMorph(570949632)
		targetSelector: 	#yourself
		directKeymaps: 	nil
		perInstanceCategories: 	nil


[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Cmd-d>']
		targetToDispatch: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>do:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatcher>>dispatchKeystroke:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		aKeyEvent: 	[keystroke '<Cmd-d>']
		chain: 	a KMDispatchChain
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#MorphFocusCtrlN...etc...
		morph: 	a TextMorphForEditView(381419520)
		directKeymaps: 	a KMCategory


TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
	Receiver: a TextMorphForEditView(381419520)
	Arguments and temporary variables: 
		evt: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@34)
		owner: 	a TransformMorph(508559360)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@34)
		color: 	Color black
		extension: 	a MorphExtension (436207616) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'LOCell new
'
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(570949632)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(TextMorph)>>handleKeystroke:
	Receiver: a TextMorphForEditView(381419520)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-d>']
		pasteUp: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@34)
		owner: 	a TransformMorph(508559360)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@34)
		color: 	Color black
		extension: 	a MorphExtension (436207616) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'LOCell new
'
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(570949632)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


KeyboardEvent>>sentTo:
	Receiver: [keystroke '<Cmd-d>']
	Arguments and temporary variables: 
		anObject: 	a TextMorphForEditView(381419520)
	Receiver's instance variables: 
		timeStamp: 	1055131
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#keystroke
		buttons: 	64
		position: 	(195.0@82.0)
		handler: 	nil
		wasHandled: 	true
		keyValue: 	100
		charCode: 	100
		scanCode: 	2


TextMorphForEditView(Morph)>>handleEvent:
	Receiver: a TextMorphForEditView(381419520)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@34)
		owner: 	a TransformMorph(508559360)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@34)
		color: 	Color black
		extension: 	a MorphExtension (436207616) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'LOCell new
'
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(570949632)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(Morph)>>handleFocusEvent:
	Receiver: a TextMorphForEditView(381419520)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@34)
		owner: 	a TransformMorph(508559360)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@34)
		color: 	Color black
		extension: 	a MorphExtension (436207616) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'LOCell new
'
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(570949632)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-d>']
		focusHolder: 	a TextMorphForEditView(381419520)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(687@606) corner: (703@622)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(687@606) corner: (703@622)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a TextMorphForEditView(381419520)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(687@606) mouseOver nil nil]
		targetOffset: 	(127.0@152.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 1053340 687 606 0 0 0 1)
		lastKeyScanCode: 	2
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	8



--- The full stack ---
LOCell(Object)>>doesNotUnderstand: #self
LOCell>>initialize
LOCell class(Behavior)>>new
UndefinedObject>>DoIt
OpalCompiler>>evaluate
SmalltalkEditor>>evaluateSelectionAndDo:
SmalltalkEditor>>evaluateSelection
[ textMorph editor evaluateSelection ] in PluggableTextMorph>>doIt
[ result := editBlock value ] in PluggableTextMorph>>handleEdit:
TextMorphForEditView(TextMorph)>>handleEdit:
PluggableTextMorph>>handleEdit:
PluggableTextMorph>>doIt
[ :morph | morph doIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
TextMorphForEditView(TextMorph)>>handleKeystroke:
KeyboardEvent>>sentTo:
TextMorphForEditView(Morph)>>handleEvent:
TextMorphForEditView(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: LOCell>>self
16 October 2014 3:51:29.38744 pm

VM: Mac OS - intel - 1090 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30858]

LOCell(Object)>>doesNotUnderstand: #self
	Receiver: a LOCell(272367616)
	Arguments and temporary variables: 
		aMessage: 	self
		exception: 	MessageNotUnderstood: LOCell>>self
		resumeValue: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (38@22)
		owner: 	nil
		submorphs: 	an Array(a StringMorph(425721856)'Flash')
		fullBounds: 	nil
		color: 	Color lightGray
		extension: 	a MorphExtension (328204288)
		borderWidth: 	3
		borderColor: 	Color gray
		target: 	nil
		actionSelector: 	#flash
		arguments: 	#()
		actWhen: 	#buttonUp
		oldColor: 	nil
		mouseDownTime: 	nil
		label: 	a StringMorph(425721856)'Flash'
		helpText: 	nil
		onColor: 	(Color r: 1.0 g: 0.6 b: 0.6 alpha: 1.0)
		offColor: 	Color lightGray
		mouseAction: 	nil


Message>>sentTo:
	Receiver: self
	Arguments and temporary variables: 
		receiver: 	a LOCell(272367616)
	Receiver's instance variables: 
		selector: 	#self
		args: 	#()
		lookupClass: 	LOCell


LOCell(Object)>>doesNotUnderstand: #self
	Receiver: a LOCell(272367616)
	Arguments and temporary variables: 
		aMessage: 	self
		exception: 	MessageNotUnderstood: LOCell>>self
		resumeValue: 	MessageNotUnderstood: LOCell>>self
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (38@22)
		owner: 	nil
		submorphs: 	an Array(a StringMorph(425721856)'Flash')
		fullBounds: 	nil
		color: 	Color lightGray
		extension: 	a MorphExtension (328204288)
		borderWidth: 	3
		borderColor: 	Color gray
		target: 	nil
		actionSelector: 	#flash
		arguments: 	#()
		actWhen: 	#buttonUp
		oldColor: 	nil
		mouseDownTime: 	nil
		label: 	a StringMorph(425721856)'Flash'
		helpText: 	nil
		onColor: 	(Color r: 1.0 g: 0.6 b: 0.6 alpha: 1.0)
		offColor: 	Color lightGray
		mouseAction: 	nil


LOCell>>initialize
	Receiver: a LOCell(272367616)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (38@22)
		owner: 	nil
		submorphs: 	an Array(a StringMorph(425721856)'Flash')
		fullBounds: 	nil
		color: 	Color lightGray
		extension: 	a MorphExtension (328204288)
		borderWidth: 	3
		borderColor: 	Color gray
		target: 	nil
		actionSelector: 	#flash
		arguments: 	#()
		actWhen: 	#buttonUp
		oldColor: 	nil
		mouseDownTime: 	nil
		label: 	a StringMorph(425721856)'Flash'
		helpText: 	nil
		onColor: 	(Color r: 1.0 g: 0.6 b: 0.6 alpha: 1.0)
		offColor: 	Color lightGray
		mouseAction: 	nil


LOCell class(Behavior)>>new
	Receiver: LOCell
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	SimpleSwitchMorph
		methodDict: 	a MethodDictionary(#initialize->LOCell>>#initialize )
		format: 	168
		layout: 	a FixedLayout
		instanceVariables: 	#(#mouseAction)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#LOCell
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'PBE-LightsOut'
		traitComposition: 	{}
		localSelectors: 	nil
		announcer: 	nil


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'LOCell new
'
		itsSelection: 	a Text for 'LOCell new
'
		itsSelectionString: 	'LOCell new
'
	Receiver's instance variables: 
		ast: 	DoIt
	^ LOCell new
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


SmalltalkEditor>>evaluateSelectionAndDo:
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(381419520)
		selectionShowing: 	true
		model: 	a Workspace
		editingState: 	a SmalltalkEditingState


SmalltalkEditor>>evaluateSelection
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(381419520)
		selectionShowing: 	true
		model: 	a Workspace
		editingState: 	a SmalltalkEditingState


[ textMorph editor evaluateSelection ] in PluggableTextMorph>>doIt
	Receiver: a PluggableTextMorph(570949632)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(488.0@523.0) corner: (928.0@690.0)
		owner: 	a SystemWindow(481034240)
		submorphs: 	an Array(a TransformMorph(508559360))
		fullBounds: 	(488@523) corner: (928@690)
		color: 	Color white
		extension: 	a MorphExtension (360185856) [locked]  [other:  (kmDispatcher -> a K...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(610795520)
		scroller: 	a TransformMorph(508559360)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(526123008)
		textMorph: 	a TextMorphForEditView(381419520)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 11)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


[ result := editBlock value ] in PluggableTextMorph>>handleEdit:
	Receiver: a PluggableTextMorph(570949632)
	Arguments and temporary variables: 
		editBlock: 	[ textMorph editor evaluateSelection ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(488.0@523.0) corner: (928.0@690.0)
		owner: 	a SystemWindow(481034240)
		submorphs: 	an Array(a TransformMorph(508559360))
		fullBounds: 	(488@523) corner: (928@690)
		color: 	Color white
		extension: 	a MorphExtension (360185856) [locked]  [other:  (kmDispatcher -> a K...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(610795520)
		scroller: 	a TransformMorph(508559360)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(526123008)
		textMorph: 	a TextMorphForEditView(381419520)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 11)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


TextMorphForEditView(TextMorph)>>handleEdit:
	Receiver: a TextMorphForEditView(381419520)
	Arguments and temporary variables: 
		editBlock: 	[ result := editBlock value ]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@34)
		owner: 	a TransformMorph(508559360)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@34)
		color: 	Color black
		extension: 	a MorphExtension (436207616) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'LOCell new
'
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(570949632)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


PluggableTextMorph>>handleEdit:
	Receiver: a PluggableTextMorph(570949632)
	Arguments and temporary variables: 
		result: 	nil
		editBlock: 	[ textMorph editor evaluateSelection ]
	Receiver's instance variables: 
		bounds: 	(488.0@523.0) corner: (928.0@690.0)
		owner: 	a SystemWindow(481034240)
		submorphs: 	an Array(a TransformMorph(508559360))
		fullBounds: 	(488@523) corner: (928@690)
		color: 	Color white
		extension: 	a MorphExtension (360185856) [locked]  [other:  (kmDispatcher -> a K...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(610795520)
		scroller: 	a TransformMorph(508559360)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(526123008)
		textMorph: 	a TextMorphForEditView(381419520)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 11)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


PluggableTextMorph>>doIt
	Receiver: a PluggableTextMorph(570949632)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(488.0@523.0) corner: (928.0@690.0)
		owner: 	a SystemWindow(481034240)
		submorphs: 	an Array(a TransformMorph(508559360))
		fullBounds: 	(488@523) corner: (928@690)
		color: 	Color white
		extension: 	a MorphExtension (360185856) [locked]  [other:  (kmDispatcher -> a K...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(610795520)
		scroller: 	a TransformMorph(508559360)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(526123008)
		textMorph: 	a TextMorphForEditView(381419520)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 11)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


[ :morph | morph doIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
	Receiver: SmalltalkEditor
	Arguments and temporary variables: 
		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a PluggableTextMorph(570949632)
	Receiver's instance variables: 
		superclass: 	TextEditor
		methodDict: 	a MethodDictionary(#argAdvance:->SmalltalkEditor>>#argAdvance: #bro...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SmalltalkEditor
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Text-Edition'
		traitComposition: 	{}
		localSelectors: 	nil
		cmdActions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop...etc...
		shiftCmdActions: 	#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #m...etc...


BlockClosure>>cull:
	Receiver: [ :morph | morph doIt ]
	Arguments and temporary variables: 
		anArg: 	a PluggableTextMorph(570949632)
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	157
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :morph | morph doIt ]
	Arguments and temporary variables: 
		firstArg: 	a PluggableTextMorph(570949632)
		secondArg: 	a PluggableTextMorph(570949632)
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	157
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :morph | morph doIt ]
	Arguments and temporary variables: 
		firstArg: 	a PluggableTextMorph(570949632)
		secondArg: 	a PluggableTextMorph(570949632)
		thirdArg: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	157
		numArgs: 	1


KMCategoryBinding>>completeMatch:buffer:
	Receiver: aKMCategoryTarget(#SmalltalkEditor)
	Arguments and temporary variables: 
		aKeymap: 	#doIt on Cmd + D do [ :morph | morph doIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
	Receiver's instance variables: 
		target: 	a PluggableTextMorph(570949632)
		category: 	a KMCategory
		morph: 	a PluggableTextMorph(570949632)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #doIt on Cmd + D do [ :morph | morph doIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		l: 	aKMCategoryTarget(#SmalltalkEditor)
	Receiver's instance variables: 
		action: 	[ :morph | morph doIt ]
		name: 	#doIt
		shortcut: 	Cmd + D
		defaultShortcut: 	Cmd + D
		description: 	''


Array(SequenceableCollection)>>do:
	Receiver: an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #doIt on Cmd + D do [ :morph | morph doIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ :morph | morph doIt ]
		name: 	#doIt
		shortcut: 	Cmd + D
		defaultShortcut: 	Cmd + D
		description: 	''


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: #doIt on Cmd + D do [ :morph | morph doIt ]

	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		action: 	[ :morph | morph doIt ]
		name: 	#doIt
		shortcut: 	Cmd + D
		defaultShortcut: 	Cmd + D
		description: 	''


[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#doIt on Cmd + D do [ :morph | morph doIt ]

	Receiver's instance variables: 
		name: 	#SmalltalkEditor
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


Set>>do:
	Receiver: a Set(#printIt on Cmd + P do [ :morph | morph printIt ]
 #previousSelection on Cmd + Shift...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	9
		each: 	#doIt on Cmd + D do [ :morph | morph doIt ]

	Receiver's instance variables: 
		tally: 	14
		array: 	an Array(#printIt on Cmd + P do [ :morph | morph printIt ]
 #previousSel...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
	Receiver's instance variables: 
		name: 	#SmalltalkEditor
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: aKMCategoryTarget(#SmalltalkEditor)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		target: 	a PluggableTextMorph(570949632)
		category: 	a KMCategory
		morph: 	a PluggableTextMorph(570949632)


[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#SmalltalkEditor)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#SmalltalkEditor) aKMCategoryTarget(#TextMorph...etc...
		morph: 	a PluggableTextMorph(570949632)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#SmalltalkEditor) aKMCategor...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	2
	Receiver's instance variables: 
		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#SmalltalkEditor) aKMC...etc...
		firstIndex: 	1
		lastIndex: 	7


KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		association: 	nil
		match: 	nil
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#SmalltalkEditor) aKMCategoryTarget(#TextMorph...etc...
		morph: 	a PluggableTextMorph(570949632)
		directKeymaps: 	a KMCategory


KMTarget>>dispatch:
	Receiver: a KMTarget
	Arguments and temporary variables: 
		buffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
	Receiver's instance variables: 
		realTarget: 	nil
		morph: 	a PluggableTextMorph(570949632)
		targetSelector: 	#yourself
		directKeymaps: 	nil
		perInstanceCategories: 	nil


[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Cmd-d>']
		targetToDispatch: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>do:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatcher>>dispatchKeystroke:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		aKeyEvent: 	[keystroke '<Cmd-d>']
		chain: 	a KMDispatchChain
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#MorphFocusCtrlN...etc...
		morph: 	a TextMorphForEditView(381419520)
		directKeymaps: 	a KMCategory


TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
	Receiver: a TextMorphForEditView(381419520)
	Arguments and temporary variables: 
		evt: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@34)
		owner: 	a TransformMorph(508559360)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@34)
		color: 	Color black
		extension: 	a MorphExtension (436207616) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'LOCell new
'
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(570949632)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(TextMorph)>>handleKeystroke:
	Receiver: a TextMorphForEditView(381419520)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-d>']
		pasteUp: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@34)
		owner: 	a TransformMorph(508559360)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@34)
		color: 	Color black
		extension: 	a MorphExtension (436207616) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'LOCell new
'
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(570949632)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


KeyboardEvent>>sentTo:
	Receiver: [keystroke '<Cmd-d>']
	Arguments and temporary variables: 
		anObject: 	a TextMorphForEditView(381419520)
	Receiver's instance variables: 
		timeStamp: 	1055131
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#keystroke
		buttons: 	64
		position: 	(195.0@82.0)
		handler: 	nil
		wasHandled: 	true
		keyValue: 	100
		charCode: 	100
		scanCode: 	2


TextMorphForEditView(Morph)>>handleEvent:
	Receiver: a TextMorphForEditView(381419520)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@34)
		owner: 	a TransformMorph(508559360)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@34)
		color: 	Color black
		extension: 	a MorphExtension (436207616) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'LOCell new
'
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(570949632)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil



--- The full stack ---
LOCell(Object)>>doesNotUnderstand: #self
Message>>sentTo:
LOCell(Object)>>doesNotUnderstand: #self
LOCell>>initialize
LOCell class(Behavior)>>new
UndefinedObject>>DoIt
OpalCompiler>>evaluate
SmalltalkEditor>>evaluateSelectionAndDo:
SmalltalkEditor>>evaluateSelection
[ textMorph editor evaluateSelection ] in PluggableTextMorph>>doIt
[ result := editBlock value ] in PluggableTextMorph>>handleEdit:
TextMorphForEditView(TextMorph)>>handleEdit:
PluggableTextMorph>>handleEdit:
PluggableTextMorph>>doIt
[ :morph | morph doIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
TextMorphForEditView(TextMorph)>>handleKeystroke:
KeyboardEvent>>sentTo:
TextMorphForEditView(Morph)>>handleEvent:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
TextMorphForEditView(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: LOCell>>self
16 October 2014 3:51:33.033844 pm

VM: Mac OS - intel - 1090 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30858]

LOCell(Object)>>doesNotUnderstand: #self
	Receiver: a LOCell(272367616)
	Arguments and temporary variables: 
		aMessage: 	self
		exception: 	MessageNotUnderstood: LOCell>>self
		resumeValue: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (38@22)
		owner: 	nil
		submorphs: 	an Array(a StringMorph(425721856)'Flash')
		fullBounds: 	nil
		color: 	Color lightGray
		extension: 	a MorphExtension (328204288)
		borderWidth: 	3
		borderColor: 	Color gray
		target: 	nil
		actionSelector: 	#flash
		arguments: 	#()
		actWhen: 	#buttonUp
		oldColor: 	nil
		mouseDownTime: 	nil
		label: 	a StringMorph(425721856)'Flash'
		helpText: 	nil
		onColor: 	(Color r: 1.0 g: 0.6 b: 0.6 alpha: 1.0)
		offColor: 	Color lightGray
		mouseAction: 	nil


Message>>sentTo:
	Receiver: self
	Arguments and temporary variables: 
		receiver: 	a LOCell(272367616)
	Receiver's instance variables: 
		selector: 	#self
		args: 	#()
		lookupClass: 	LOCell


LOCell(Object)>>doesNotUnderstand: #self
	Receiver: a LOCell(272367616)
	Arguments and temporary variables: 
		aMessage: 	self
		exception: 	MessageNotUnderstood: LOCell>>self
		resumeValue: 	MessageNotUnderstood: LOCell>>self
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (38@22)
		owner: 	nil
		submorphs: 	an Array(a StringMorph(425721856)'Flash')
		fullBounds: 	nil
		color: 	Color lightGray
		extension: 	a MorphExtension (328204288)
		borderWidth: 	3
		borderColor: 	Color gray
		target: 	nil
		actionSelector: 	#flash
		arguments: 	#()
		actWhen: 	#buttonUp
		oldColor: 	nil
		mouseDownTime: 	nil
		label: 	a StringMorph(425721856)'Flash'
		helpText: 	nil
		onColor: 	(Color r: 1.0 g: 0.6 b: 0.6 alpha: 1.0)
		offColor: 	Color lightGray
		mouseAction: 	nil


Message>>sentTo:
	Receiver: self
	Arguments and temporary variables: 
		receiver: 	a LOCell(272367616)
	Receiver's instance variables: 
		selector: 	#self
		args: 	#()
		lookupClass: 	LOCell


LOCell(Object)>>doesNotUnderstand: #self
	Receiver: a LOCell(272367616)
	Arguments and temporary variables: 
		aMessage: 	self
		exception: 	MessageNotUnderstood: LOCell>>self
		resumeValue: 	MessageNotUnderstood: LOCell>>self
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (38@22)
		owner: 	nil
		submorphs: 	an Array(a StringMorph(425721856)'Flash')
		fullBounds: 	nil
		color: 	Color lightGray
		extension: 	a MorphExtension (328204288)
		borderWidth: 	3
		borderColor: 	Color gray
		target: 	nil
		actionSelector: 	#flash
		arguments: 	#()
		actWhen: 	#buttonUp
		oldColor: 	nil
		mouseDownTime: 	nil
		label: 	a StringMorph(425721856)'Flash'
		helpText: 	nil
		onColor: 	(Color r: 1.0 g: 0.6 b: 0.6 alpha: 1.0)
		offColor: 	Color lightGray
		mouseAction: 	nil


LOCell>>initialize
	Receiver: a LOCell(272367616)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (38@22)
		owner: 	nil
		submorphs: 	an Array(a StringMorph(425721856)'Flash')
		fullBounds: 	nil
		color: 	Color lightGray
		extension: 	a MorphExtension (328204288)
		borderWidth: 	3
		borderColor: 	Color gray
		target: 	nil
		actionSelector: 	#flash
		arguments: 	#()
		actWhen: 	#buttonUp
		oldColor: 	nil
		mouseDownTime: 	nil
		label: 	a StringMorph(425721856)'Flash'
		helpText: 	nil
		onColor: 	(Color r: 1.0 g: 0.6 b: 0.6 alpha: 1.0)
		offColor: 	Color lightGray
		mouseAction: 	nil


LOCell class(Behavior)>>new
	Receiver: LOCell
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	SimpleSwitchMorph
		methodDict: 	a MethodDictionary(#initialize->LOCell>>#initialize )
		format: 	168
		layout: 	a FixedLayout
		instanceVariables: 	#(#mouseAction)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#LOCell
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'PBE-LightsOut'
		traitComposition: 	{}
		localSelectors: 	nil
		announcer: 	nil


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'LOCell new
'
		itsSelection: 	a Text for 'LOCell new
'
		itsSelectionString: 	'LOCell new
'
	Receiver's instance variables: 
		ast: 	DoIt
	^ LOCell new
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


SmalltalkEditor>>evaluateSelectionAndDo:
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(381419520)
		selectionShowing: 	true
		model: 	a Workspace
		editingState: 	a SmalltalkEditingState


SmalltalkEditor>>evaluateSelection
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(381419520)
		selectionShowing: 	true
		model: 	a Workspace
		editingState: 	a SmalltalkEditingState


[ textMorph editor evaluateSelection ] in PluggableTextMorph>>doIt
	Receiver: a PluggableTextMorph(570949632)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(488.0@523.0) corner: (928.0@690.0)
		owner: 	a SystemWindow(481034240)
		submorphs: 	an Array(a TransformMorph(508559360))
		fullBounds: 	(488@523) corner: (928@690)
		color: 	Color white
		extension: 	a MorphExtension (360185856) [locked]  [other:  (kmDispatcher -> a K...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(610795520)
		scroller: 	a TransformMorph(508559360)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(526123008)
		textMorph: 	a TextMorphForEditView(381419520)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 11)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


[ result := editBlock value ] in PluggableTextMorph>>handleEdit:
	Receiver: a PluggableTextMorph(570949632)
	Arguments and temporary variables: 
		editBlock: 	[ textMorph editor evaluateSelection ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(488.0@523.0) corner: (928.0@690.0)
		owner: 	a SystemWindow(481034240)
		submorphs: 	an Array(a TransformMorph(508559360))
		fullBounds: 	(488@523) corner: (928@690)
		color: 	Color white
		extension: 	a MorphExtension (360185856) [locked]  [other:  (kmDispatcher -> a K...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(610795520)
		scroller: 	a TransformMorph(508559360)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(526123008)
		textMorph: 	a TextMorphForEditView(381419520)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 11)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


TextMorphForEditView(TextMorph)>>handleEdit:
	Receiver: a TextMorphForEditView(381419520)
	Arguments and temporary variables: 
		editBlock: 	[ result := editBlock value ]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@34)
		owner: 	a TransformMorph(508559360)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@34)
		color: 	Color black
		extension: 	a MorphExtension (436207616) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'LOCell new
'
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(570949632)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


PluggableTextMorph>>handleEdit:
	Receiver: a PluggableTextMorph(570949632)
	Arguments and temporary variables: 
		result: 	nil
		editBlock: 	[ textMorph editor evaluateSelection ]
	Receiver's instance variables: 
		bounds: 	(488.0@523.0) corner: (928.0@690.0)
		owner: 	a SystemWindow(481034240)
		submorphs: 	an Array(a TransformMorph(508559360))
		fullBounds: 	(488@523) corner: (928@690)
		color: 	Color white
		extension: 	a MorphExtension (360185856) [locked]  [other:  (kmDispatcher -> a K...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(610795520)
		scroller: 	a TransformMorph(508559360)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(526123008)
		textMorph: 	a TextMorphForEditView(381419520)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 11)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


PluggableTextMorph>>doIt
	Receiver: a PluggableTextMorph(570949632)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(488.0@523.0) corner: (928.0@690.0)
		owner: 	a SystemWindow(481034240)
		submorphs: 	an Array(a TransformMorph(508559360))
		fullBounds: 	(488@523) corner: (928@690)
		color: 	Color white
		extension: 	a MorphExtension (360185856) [locked]  [other:  (kmDispatcher -> a K...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(610795520)
		scroller: 	a TransformMorph(508559360)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(526123008)
		textMorph: 	a TextMorphForEditView(381419520)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 11)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


[ :morph | morph doIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
	Receiver: SmalltalkEditor
	Arguments and temporary variables: 
		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a PluggableTextMorph(570949632)
	Receiver's instance variables: 
		superclass: 	TextEditor
		methodDict: 	a MethodDictionary(#argAdvance:->SmalltalkEditor>>#argAdvance: #bro...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SmalltalkEditor
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Text-Edition'
		traitComposition: 	{}
		localSelectors: 	nil
		cmdActions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop...etc...
		shiftCmdActions: 	#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #m...etc...


BlockClosure>>cull:
	Receiver: [ :morph | morph doIt ]
	Arguments and temporary variables: 
		anArg: 	a PluggableTextMorph(570949632)
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	157
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :morph | morph doIt ]
	Arguments and temporary variables: 
		firstArg: 	a PluggableTextMorph(570949632)
		secondArg: 	a PluggableTextMorph(570949632)
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	157
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :morph | morph doIt ]
	Arguments and temporary variables: 
		firstArg: 	a PluggableTextMorph(570949632)
		secondArg: 	a PluggableTextMorph(570949632)
		thirdArg: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	157
		numArgs: 	1


KMCategoryBinding>>completeMatch:buffer:
	Receiver: aKMCategoryTarget(#SmalltalkEditor)
	Arguments and temporary variables: 
		aKeymap: 	#doIt on Cmd + D do [ :morph | morph doIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
	Receiver's instance variables: 
		target: 	a PluggableTextMorph(570949632)
		category: 	a KMCategory
		morph: 	a PluggableTextMorph(570949632)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #doIt on Cmd + D do [ :morph | morph doIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		l: 	aKMCategoryTarget(#SmalltalkEditor)
	Receiver's instance variables: 
		action: 	[ :morph | morph doIt ]
		name: 	#doIt
		shortcut: 	Cmd + D
		defaultShortcut: 	Cmd + D
		description: 	''


Array(SequenceableCollection)>>do:
	Receiver: an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #doIt on Cmd + D do [ :morph | morph doIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ :morph | morph doIt ]
		name: 	#doIt
		shortcut: 	Cmd + D
		defaultShortcut: 	Cmd + D
		description: 	''


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: #doIt on Cmd + D do [ :morph | morph doIt ]

	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		action: 	[ :morph | morph doIt ]
		name: 	#doIt
		shortcut: 	Cmd + D
		defaultShortcut: 	Cmd + D
		description: 	''


[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#doIt on Cmd + D do [ :morph | morph doIt ]

	Receiver's instance variables: 
		name: 	#SmalltalkEditor
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


Set>>do:
	Receiver: a Set(#printIt on Cmd + P do [ :morph | morph printIt ]
 #previousSelection on Cmd + Shift...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	9
		each: 	#doIt on Cmd + D do [ :morph | morph doIt ]

	Receiver's instance variables: 
		tally: 	14
		array: 	an Array(#printIt on Cmd + P do [ :morph | morph printIt ]
 #previousSel...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
	Receiver's instance variables: 
		name: 	#SmalltalkEditor
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: aKMCategoryTarget(#SmalltalkEditor)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		target: 	a PluggableTextMorph(570949632)
		category: 	a KMCategory
		morph: 	a PluggableTextMorph(570949632)


[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#SmalltalkEditor)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#SmalltalkEditor) aKMCategoryTarget(#TextMorph...etc...
		morph: 	a PluggableTextMorph(570949632)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#SmalltalkEditor) aKMCategor...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	2
	Receiver's instance variables: 
		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#SmalltalkEditor) aKMC...etc...
		firstIndex: 	1
		lastIndex: 	7


KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		association: 	nil
		match: 	nil
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#SmalltalkEditor) aKMCategoryTarget(#TextMorph...etc...
		morph: 	a PluggableTextMorph(570949632)
		directKeymaps: 	a KMCategory


KMTarget>>dispatch:
	Receiver: a KMTarget
	Arguments and temporary variables: 
		buffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
	Receiver's instance variables: 
		realTarget: 	nil
		morph: 	a PluggableTextMorph(570949632)
		targetSelector: 	#yourself
		directKeymaps: 	nil
		perInstanceCategories: 	nil


[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Cmd-d>']
		targetToDispatch: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>do:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatcher>>dispatchKeystroke:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		aKeyEvent: 	[keystroke '<Cmd-d>']
		chain: 	a KMDispatchChain
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#MorphFocusCtrlN...etc...
		morph: 	a TextMorphForEditView(381419520)
		directKeymaps: 	a KMCategory


TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
	Receiver: a TextMorphForEditView(381419520)
	Arguments and temporary variables: 
		evt: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@34)
		owner: 	a TransformMorph(508559360)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@34)
		color: 	Color black
		extension: 	a MorphExtension (436207616) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'LOCell new
'
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(570949632)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(TextMorph)>>handleKeystroke:
	Receiver: a TextMorphForEditView(381419520)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-d>']
		pasteUp: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@34)
		owner: 	a TransformMorph(508559360)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@34)
		color: 	Color black
		extension: 	a MorphExtension (436207616) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'LOCell new
'
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(570949632)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil



--- The full stack ---
LOCell(Object)>>doesNotUnderstand: #self
Message>>sentTo:
LOCell(Object)>>doesNotUnderstand: #self
Message>>sentTo:
LOCell(Object)>>doesNotUnderstand: #self
LOCell>>initialize
LOCell class(Behavior)>>new
UndefinedObject>>DoIt
OpalCompiler>>evaluate
SmalltalkEditor>>evaluateSelectionAndDo:
SmalltalkEditor>>evaluateSelection
[ textMorph editor evaluateSelection ] in PluggableTextMorph>>doIt
[ result := editBlock value ] in PluggableTextMorph>>handleEdit:
TextMorphForEditView(TextMorph)>>handleEdit:
PluggableTextMorph>>handleEdit:
PluggableTextMorph>>doIt
[ :morph | morph doIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
TextMorphForEditView(TextMorph)>>handleKeystroke:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
KeyboardEvent>>sentTo:
TextMorphForEditView(Morph)>>handleEvent:
TextMorphForEditView(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: receiver of "lastClicked:" is nil
16 October 2014 4:07:02.041734 pm

VM: Mac OS - intel - 1090 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30858]

UndefinedObject(Object)>>doesNotUnderstand: #lastClicked:
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	lastClicked: true
		exception: 	MessageNotUnderstood: receiver of "lastClicked:" is nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

MorphTreeListManager>>lastClickedMorph:
	Receiver: a MorphTreeListManager
	Arguments and temporary variables: 
		aNodeMorph: 	NodeMorph(nil)
	Receiver's instance variables: 
		keystrokeActionSelector: 	nil
		multipleSelection: 	true
		autoMultiSelection: 	false
		potentialDropMorph: 	nil
		firstClickedMorph: 	NodeMorph(nil)
		lastClickedMorph: 	NodeMorph(nil)
		columnDropUnabled: 	nil
		doubleClickBlock: 	nil
		autoDeselection: 	false
		searchedElement: 	nil
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		lastSelection: 	0
		client: 	a MorphTreeMorph(68943872)
		isSelectionUpdateFromView: 	false
		isCheckList: 	false
		autoTargetMorph: 	nil
		selectedMorphList: 	a LinkedList(NodeMorph(Node(a RPackage(PBE-LightsOut))))
		removeOnlyLastSelected: 	false


MorphTreeListManager>>mouseUp:on:
	Receiver: a MorphTreeListManager
	Arguments and temporary variables: 
		event: 	[(119@131) mouseUp 486931 nil]
		aNodeMorph: 	NodeMorph(nil)
		path: 	an OrderedCollection(Node(a RPackage(PBE-LightsOut)))
		cmdOrCtrl: 	false
		clickedTheCheckbox: 	false
	Receiver's instance variables: 
		keystrokeActionSelector: 	nil
		multipleSelection: 	true
		autoMultiSelection: 	false
		potentialDropMorph: 	nil
		firstClickedMorph: 	NodeMorph(nil)
		lastClickedMorph: 	NodeMorph(nil)
		columnDropUnabled: 	nil
		doubleClickBlock: 	nil
		autoDeselection: 	false
		searchedElement: 	nil
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		lastSelection: 	0
		client: 	a MorphTreeMorph(68943872)
		isSelectionUpdateFromView: 	false
		isCheckList: 	false
		autoTargetMorph: 	nil
		selectedMorphList: 	a LinkedList(NodeMorph(Node(a RPackage(PBE-LightsOut))))
		removeOnlyLastSelected: 	false


MorphTreeMorph>>mouseUp:
	Receiver: a MorphTreeMorph(68943872)
	Arguments and temporary variables: 
		event: 	[(119@131) mouseUp 486931 nil]
		nodeMorph: 	NodeMorph(nil)
		wasHigh: 	true
	Receiver's instance variables: 
		bounds: 	(45.0@75.0) corner: (253.0@301.0)
		owner: 	a PanelMorph(13893632)
		submorphs: 	an Array(a Morph(316669952) a MorphTreeTransformMorph(448790528))
		fullBounds: 	nil
		color: 	(Color r: 0.979 g: 0.979 b: 0.979 alpha: 1.0)
		extension: 	a MorphExtension (986447872) [other:  (dropEnabled -> true) (announc...etc...
		borderWidth: 	0
		borderColor: 	Color black
		model: 	a PackageTreeModel
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(122421248)
		scroller: 	a MorphTreeTransformMorph(448790528)
		getMenuSelector: 	#menu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(918552576)
		columns: 	an OrderedCollection(a MorphTreeColumn)
		potentialDropMorph: 	nil
		rowInset: 	0
		columnInset: 	0
		columnResizers: 	an OrderedCollection()
		withHLines: 	false
		preferedPaneColor: 	nil
		indentGap: 	20
		expandedToggleImage: 	an ImageMorph(67371008)
		notExpandedToggleImage: 	an ImageMorph(233832448)
		resizerWidth: 	3
		gapAfterToggle: 	5
		hasToggleAtRoot: 	nil
		topHeader: 	a Morph(316669952)
		topHeaderBackground: 	Color transparent
		unboundLastColumn: 	true
		columnDropUnabled: 	nil
		columnColors: 	{Color transparent. Color transparent}
		rowColors: 	{Color transparent. Color transparent}
		nodeList: 	an OrderedCollection(Node(a DynamicClassGroup ( Last Modified Classes...etc...
		iconBlock: 	nil
		treeLineWidth: 	0
		lineColorBlock: 	nil
		treeLineDashes: 	nil
		listManager: 	a MorphTreeListManager
		mouseOverAllowed: 	false
		maxNodeWidth: 	155
		enabled: 	true


MorphTreeMorph(Morph)>>handleMouseUp:
	Receiver: a MorphTreeMorph(68943872)
	Arguments and temporary variables: 
		anEvent: 	[(119@131) mouseUp 486931 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(45.0@75.0) corner: (253.0@301.0)
		owner: 	a PanelMorph(13893632)
		submorphs: 	an Array(a Morph(316669952) a MorphTreeTransformMorph(448790528))
		fullBounds: 	nil
		color: 	(Color r: 0.979 g: 0.979 b: 0.979 alpha: 1.0)
		extension: 	a MorphExtension (986447872) [other:  (dropEnabled -> true) (announc...etc...
		borderWidth: 	0
		borderColor: 	Color black
		model: 	a PackageTreeModel
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(122421248)
		scroller: 	a MorphTreeTransformMorph(448790528)
		getMenuSelector: 	#menu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(918552576)
		columns: 	an OrderedCollection(a MorphTreeColumn)
		potentialDropMorph: 	nil
		rowInset: 	0
		columnInset: 	0
		columnResizers: 	an OrderedCollection()
		withHLines: 	false
		preferedPaneColor: 	nil
		indentGap: 	20
		expandedToggleImage: 	an ImageMorph(67371008)
		notExpandedToggleImage: 	an ImageMorph(233832448)
		resizerWidth: 	3
		gapAfterToggle: 	5
		hasToggleAtRoot: 	nil
		topHeader: 	a Morph(316669952)
		topHeaderBackground: 	Color transparent
		unboundLastColumn: 	true
		columnDropUnabled: 	nil
		columnColors: 	{Color transparent. Color transparent}
		rowColors: 	{Color transparent. Color transparent}
		nodeList: 	an OrderedCollection(Node(a DynamicClassGroup ( Last Modified Classes...etc...
		iconBlock: 	nil
		treeLineWidth: 	0
		lineColorBlock: 	nil
		treeLineDashes: 	nil
		listManager: 	a MorphTreeListManager
		mouseOverAllowed: 	false
		maxNodeWidth: 	155
		enabled: 	true


MouseButtonEvent>>sentTo:
	Receiver: [(119@131) mouseUp 486931 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphTreeMorph(68943872)
	Receiver's instance variables: 
		timeStamp: 	486931
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(119@131)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


MorphTreeMorph(Morph)>>handleEvent:
	Receiver: a MorphTreeMorph(68943872)
	Arguments and temporary variables: 
		anEvent: 	[(119@131) mouseUp 486931 nil]
	Receiver's instance variables: 
		bounds: 	(45.0@75.0) corner: (253.0@301.0)
		owner: 	a PanelMorph(13893632)
		submorphs: 	an Array(a Morph(316669952) a MorphTreeTransformMorph(448790528))
		fullBounds: 	nil
		color: 	(Color r: 0.979 g: 0.979 b: 0.979 alpha: 1.0)
		extension: 	a MorphExtension (986447872) [other:  (dropEnabled -> true) (announc...etc...
		borderWidth: 	0
		borderColor: 	Color black
		model: 	a PackageTreeModel
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(122421248)
		scroller: 	a MorphTreeTransformMorph(448790528)
		getMenuSelector: 	#menu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(918552576)
		columns: 	an OrderedCollection(a MorphTreeColumn)
		potentialDropMorph: 	nil
		rowInset: 	0
		columnInset: 	0
		columnResizers: 	an OrderedCollection()
		withHLines: 	false
		preferedPaneColor: 	nil
		indentGap: 	20
		expandedToggleImage: 	an ImageMorph(67371008)
		notExpandedToggleImage: 	an ImageMorph(233832448)
		resizerWidth: 	3
		gapAfterToggle: 	5
		hasToggleAtRoot: 	nil
		topHeader: 	a Morph(316669952)
		topHeaderBackground: 	Color transparent
		unboundLastColumn: 	true
		columnDropUnabled: 	nil
		columnColors: 	{Color transparent. Color transparent}
		rowColors: 	{Color transparent. Color transparent}
		nodeList: 	an OrderedCollection(Node(a DynamicClassGroup ( Last Modified Classes...etc...
		iconBlock: 	nil
		treeLineWidth: 	0
		lineColorBlock: 	nil
		treeLineDashes: 	nil
		listManager: 	a MorphTreeListManager
		mouseOverAllowed: 	false
		maxNodeWidth: 	155
		enabled: 	true


MorphTreeMorph(Morph)>>handleFocusEvent:
	Receiver: a MorphTreeMorph(68943872)
	Arguments and temporary variables: 
		anEvent: 	[(119@131) mouseUp 486931 nil]
	Receiver's instance variables: 
		bounds: 	(45.0@75.0) corner: (253.0@301.0)
		owner: 	a PanelMorph(13893632)
		submorphs: 	an Array(a Morph(316669952) a MorphTreeTransformMorph(448790528))
		fullBounds: 	nil
		color: 	(Color r: 0.979 g: 0.979 b: 0.979 alpha: 1.0)
		extension: 	a MorphExtension (986447872) [other:  (dropEnabled -> true) (announc...etc...
		borderWidth: 	0
		borderColor: 	Color black
		model: 	a PackageTreeModel
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(122421248)
		scroller: 	a MorphTreeTransformMorph(448790528)
		getMenuSelector: 	#menu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(918552576)
		columns: 	an OrderedCollection(a MorphTreeColumn)
		potentialDropMorph: 	nil
		rowInset: 	0
		columnInset: 	0
		columnResizers: 	an OrderedCollection()
		withHLines: 	false
		preferedPaneColor: 	nil
		indentGap: 	20
		expandedToggleImage: 	an ImageMorph(67371008)
		notExpandedToggleImage: 	an ImageMorph(233832448)
		resizerWidth: 	3
		gapAfterToggle: 	5
		hasToggleAtRoot: 	nil
		topHeader: 	a Morph(316669952)
		topHeaderBackground: 	Color transparent
		unboundLastColumn: 	true
		columnDropUnabled: 	nil
		columnColors: 	{Color transparent. Color transparent}
		rowColors: 	{Color transparent. Color transparent}
		nodeList: 	an OrderedCollection(Node(a DynamicClassGroup ( Last Modified Classes...etc...
		iconBlock: 	nil
		treeLineWidth: 	0
		lineColorBlock: 	nil
		treeLineDashes: 	nil
		listManager: 	a MorphTreeListManager
		mouseOverAllowed: 	false
		maxNodeWidth: 	155
		enabled: 	true


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(119@131) mouseUp 486931 nil]
		focusHolder: 	a MorphTreeMorph(68943872)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(100@182.0) corner: (116@198.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(100@182.0) corner: (116@198.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableIconListMorph(153354240)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(100@182) mouseOver nil nil]
		targetOffset: 	(40.0@17.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 489910 100 182 0 0 0 1)
		lastKeyScanCode: 	27
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	[(119@131) mouseOver red nil nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1208@742)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a NautilusWindow(911998976) a Sys...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(119@131) mouseUp 486931 nil]
		focusHolder: 	a MorphTreeMorph(68943872)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		bounds: 	(100@182.0) corner: (116@198.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(100@182.0) corner: (116@198.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableIconListMorph(153354240)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(100@182) mouseOver nil nil]
		targetOffset: 	(40.0@17.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 489910 100 182 0 0 0 1)
		lastKeyScanCode: 	27
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(119@131) mouseUp 486931 nil]
		focusHolder: 	a MorphTreeMorph(68943872)
		aBlock: 	[ self mouseFocus: nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(100@182.0) corner: (116@198.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(100@182.0) corner: (116@198.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableIconListMorph(153354240)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(100@182) mouseOver nil nil]
		targetOffset: 	(40.0@17.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 489910 100 182 0 0 0 1)
		lastKeyScanCode: 	27
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(119@131) mouseUp 486931 nil]
	Receiver's instance variables: 
		bounds: 	(100@182.0) corner: (116@198.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(100@182.0) corner: (116@198.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableIconListMorph(153354240)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(100@182) mouseOver nil nil]
		targetOffset: 	(40.0@17.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 489910 100 182 0 0 0 1)
		lastKeyScanCode: 	27
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>handleEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(119@131) mouseUp 486931 nil]
		evt: 	[(119@131) mouseUp 486931 nil]
	Receiver's instance variables: 
		bounds: 	(100@182.0) corner: (116@198.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(100@182.0) corner: (116@198.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableIconListMorph(153354240)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(100@182) mouseOver nil nil]
		targetOffset: 	(40.0@17.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 489910 100 182 0 0 0 1)
		lastKeyScanCode: 	27
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


MouseClickState>>handleEvent:from:
	Receiver: a MouseClickState[#firstClickUp]
	Arguments and temporary variables: 
		evt: 	[(119@131) mouseUp 486931 nil]
		aHand: 	a HandMorph(760479744)
		localEvt: 	[(119@131) mouseUp 486931 nil]
		timedOut: 	false
		isDrag: 	false
	Receiver's instance variables: 
		clickClient: 	a MorphTreeMorph(68943872)
		clickState: 	#firstClickUp
		firstClickDown: 	[(119@131) mouseDown red 486850 nil]
		firstClickUp: 	[(119@131) mouseUp 486931 nil]
		firstClickTime: 	486850
		clickSelector: 	#click:
		dblClickSelector: 	#doubleClick:
		dblClickTime: 	350
		dblClickTimeoutSelector: 	nil
		dragSelector: 	nil
		dragThreshold: 	10


HandMorph>>handleEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(119@131) mouseUp 486931 nil]
		evt: 	[(119@131) mouseUp 486931 nil]
	Receiver's instance variables: 
		bounds: 	(100@182.0) corner: (116@198.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(100@182.0) corner: (116@198.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableIconListMorph(153354240)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(100@182) mouseOver nil nil]
		targetOffset: 	(40.0@17.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 489910 100 182 0 0 0 1)
		lastKeyScanCode: 	27
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>processEvents
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		evt: 	[(119@131) mouseUp 486931 nil]
		evtBuf: 	#(1 486931 119 131 0 0 0 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	(100@182.0) corner: (116@198.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(100@182.0) corner: (116@198.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableIconListMorph(153354240)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(100@182) mouseOver nil nil]
		targetOffset: 	(40.0@17.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 489910 100 182 0 0 0 1)
		lastKeyScanCode: 	27
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		h: 	a HandMorph(760479744)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1208@742)
		canvas: 	a FormCanvas on: DisplayScreen(1208x742x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a TickingSpecWindow(357826560))(a Tick...etc...
		lastStepTime: 	490360
		lastStepMessage: 	nil
		lastCycleTime: 	490354
		alarms: 	a Heap()
		lastAlarmTime: 	490360
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(760479744))
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(760479744))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1208@742)
		canvas: 	a FormCanvas on: DisplayScreen(1208x742x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(170917888))(a DropList...etc...
		lastStepTime: 	490685
		lastStepMessage: 	nil
		lastCycleTime: 	490685
		alarms: 	a Heap()
		lastAlarmTime: 	490685
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1208@742)
		canvas: 	a FormCanvas on: DisplayScreen(1208x742x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(170917888))(a DropList...etc...
		lastStepTime: 	490685
		lastStepMessage: 	nil
		lastCycleTime: 	490685
		alarms: 	a Heap()
		lastAlarmTime: 	490685
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1208@742)
		canvas: 	a FormCanvas on: DisplayScreen(1208x742x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(170917888))(a DropList...etc...
		lastStepTime: 	490685
		lastStepMessage: 	nil
		lastCycleTime: 	490685
		alarms: 	a Heap()
		lastAlarmTime: 	490685
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1208@742)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a NautilusWindow(911998976) a Sys...etc...
		fullBounds: 	(0@0) corner: (1208@742)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
World doOneCycle.
Processor yield.
false ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #lastClicked:
MorphTreeListManager>>lastClickedMorph:
MorphTreeListManager>>mouseUp:on:
MorphTreeMorph>>mouseUp:
MorphTreeMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
MorphTreeMorph(Morph)>>handleEvent:
MorphTreeMorph(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseClickState>>handleEvent:from:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: receiver of "lastClicked:" is nil
16 October 2014 4:07:09.552427 pm

VM: Mac OS - intel - 1090 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30858]

UndefinedObject(Object)>>doesNotUnderstand: #lastClicked:
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	lastClicked: false
		exception: 	MessageNotUnderstood: receiver of "lastClicked:" is nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

MorphTreeListManager>>lastClickedMorph:
	Receiver: a MorphTreeListManager
	Arguments and temporary variables: 
		aNodeMorph: 	NodeMorph(Node(a RPackage(PBE−LightsOut)))
	Receiver's instance variables: 
		keystrokeActionSelector: 	nil
		multipleSelection: 	true
		autoMultiSelection: 	false
		potentialDropMorph: 	nil
		firstClickedMorph: 	NodeMorph(Node(a RPackage(PBE−LightsOut)))
		lastClickedMorph: 	NodeMorph(nil)
		columnDropUnabled: 	nil
		doubleClickBlock: 	nil
		autoDeselection: 	false
		searchedElement: 	nil
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		lastSelection: 	0
		client: 	a MorphTreeMorph(68943872)
		isSelectionUpdateFromView: 	false
		isCheckList: 	false
		autoTargetMorph: 	nil
		selectedMorphList: 	a LinkedList(NodeMorph(Node(a RPackage(PBE-LightsOut))))
		removeOnlyLastSelected: 	false


MorphTreeListManager>>selectMorph:multiple:clickedTheCheckBox:
	Receiver: a MorphTreeListManager
	Arguments and temporary variables: 
		aNodeMorph: 	NodeMorph(Node(a RPackage(PBE−LightsOut)))		withMultipleSelection: 	false		checkBox: 	false		path: 	nil		mult: 	nil
	Receiver's instance variables: 
		keystrokeActionSelector: 	nil
		multipleSelection: 	true
		autoMultiSelection: 	false
		potentialDropMorph: 	nil
		firstClickedMorph: 	NodeMorph(Node(a RPackage(PBE−LightsOut)))
		lastClickedMorph: 	NodeMorph(nil)
		columnDropUnabled: 	nil
		doubleClickBlock: 	nil
		autoDeselection: 	false
		searchedElement: 	nil
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		lastSelection: 	0
		client: 	a MorphTreeMorph(68943872)
		isSelectionUpdateFromView: 	false
		isCheckList: 	false
		autoTargetMorph: 	nil
		selectedMorphList: 	a LinkedList(NodeMorph(Node(a RPackage(PBE-LightsOut))))
		removeOnlyLastSelected: 	false


MorphTreeListManager>>mouseUp:on:
	Receiver: a MorphTreeListManager
	Arguments and temporary variables: 
		event: 	[(147@150) mouseUp 497635 nil]		aNodeMorph: 	NodeMorph(Node(a RPackage(PBE−LightsOut)))		path: 	nil		cmdOrCtrl: 	false		clickedTheCheckbox: 	false
	Receiver's instance variables: 
		keystrokeActionSelector: 	nil
		multipleSelection: 	true
		autoMultiSelection: 	false
		potentialDropMorph: 	nil
		firstClickedMorph: 	NodeMorph(Node(a RPackage(PBE−LightsOut)))
		lastClickedMorph: 	NodeMorph(nil)
		columnDropUnabled: 	nil
		doubleClickBlock: 	nil
		autoDeselection: 	false
		searchedElement: 	nil
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		lastSelection: 	0
		client: 	a MorphTreeMorph(68943872)
		isSelectionUpdateFromView: 	false
		isCheckList: 	false
		autoTargetMorph: 	nil
		selectedMorphList: 	a LinkedList(NodeMorph(Node(a RPackage(PBE-LightsOut))))
		removeOnlyLastSelected: 	false


MorphTreeMorph>>mouseUp:
	Receiver: a MorphTreeMorph(68943872)
	Arguments and temporary variables: 
		event: 	[(147@150) mouseUp 497635 nil]		nodeMorph: 	NodeMorph(Node(a RPackage(PBE−LightsOut)))		wasHigh: 	true
	Receiver's instance variables: 
		bounds: 	(45.0@75.0) corner: (253.0@301.0)
		owner: 	a PanelMorph(13893632)
		submorphs: 	an Array(a Morph(316669952) a MorphTreeTransformMorph(448790528))
		fullBounds: 	(45@75) corner: (255@301)
		color: 	(Color r: 0.979 g: 0.979 b: 0.979 alpha: 1.0)
		extension: 	a MorphExtension (986447872) [other:  (dropEnabled -> true) (announc...etc...
		borderWidth: 	0
		borderColor: 	Color black
		model: 	a PackageTreeModel
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(122421248)
		scroller: 	a MorphTreeTransformMorph(448790528)
		getMenuSelector: 	#menu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(918552576)
		columns: 	an OrderedCollection(a MorphTreeColumn)
		potentialDropMorph: 	nil
		rowInset: 	0
		columnInset: 	0
		columnResizers: 	an OrderedCollection()
		withHLines: 	false
		preferedPaneColor: 	nil
		indentGap: 	20
		expandedToggleImage: 	an ImageMorph(67371008)
		notExpandedToggleImage: 	an ImageMorph(233832448)
		resizerWidth: 	3
		gapAfterToggle: 	5
		hasToggleAtRoot: 	nil
		topHeader: 	a Morph(316669952)
		topHeaderBackground: 	Color transparent
		unboundLastColumn: 	true
		columnDropUnabled: 	nil
		columnColors: 	{Color transparent. Color transparent}
		rowColors: 	{Color transparent. Color transparent}
		nodeList: 	an OrderedCollection(Node(a DynamicClassGroup ( Last Modified Classes...etc...
		iconBlock: 	nil
		treeLineWidth: 	0
		lineColorBlock: 	nil
		treeLineDashes: 	nil
		listManager: 	a MorphTreeListManager
		mouseOverAllowed: 	false
		maxNodeWidth: 	155
		enabled: 	true


MorphTreeMorph(Morph)>>handleMouseUp:
	Receiver: a MorphTreeMorph(68943872)
	Arguments and temporary variables: 
		anEvent: 	[(147@150) mouseUp 497635 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(45.0@75.0) corner: (253.0@301.0)
		owner: 	a PanelMorph(13893632)
		submorphs: 	an Array(a Morph(316669952) a MorphTreeTransformMorph(448790528))
		fullBounds: 	(45@75) corner: (255@301)
		color: 	(Color r: 0.979 g: 0.979 b: 0.979 alpha: 1.0)
		extension: 	a MorphExtension (986447872) [other:  (dropEnabled -> true) (announc...etc...
		borderWidth: 	0
		borderColor: 	Color black
		model: 	a PackageTreeModel
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(122421248)
		scroller: 	a MorphTreeTransformMorph(448790528)
		getMenuSelector: 	#menu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(918552576)
		columns: 	an OrderedCollection(a MorphTreeColumn)
		potentialDropMorph: 	nil
		rowInset: 	0
		columnInset: 	0
		columnResizers: 	an OrderedCollection()
		withHLines: 	false
		preferedPaneColor: 	nil
		indentGap: 	20
		expandedToggleImage: 	an ImageMorph(67371008)
		notExpandedToggleImage: 	an ImageMorph(233832448)
		resizerWidth: 	3
		gapAfterToggle: 	5
		hasToggleAtRoot: 	nil
		topHeader: 	a Morph(316669952)
		topHeaderBackground: 	Color transparent
		unboundLastColumn: 	true
		columnDropUnabled: 	nil
		columnColors: 	{Color transparent. Color transparent}
		rowColors: 	{Color transparent. Color transparent}
		nodeList: 	an OrderedCollection(Node(a DynamicClassGroup ( Last Modified Classes...etc...
		iconBlock: 	nil
		treeLineWidth: 	0
		lineColorBlock: 	nil
		treeLineDashes: 	nil
		listManager: 	a MorphTreeListManager
		mouseOverAllowed: 	false
		maxNodeWidth: 	155
		enabled: 	true


MouseButtonEvent>>sentTo:
	Receiver: [(147@150) mouseUp 497635 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphTreeMorph(68943872)
	Receiver's instance variables: 
		timeStamp: 	497635
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(147@150)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


MorphTreeMorph(Morph)>>handleEvent:
	Receiver: a MorphTreeMorph(68943872)
	Arguments and temporary variables: 
		anEvent: 	[(147@150) mouseUp 497635 nil]
	Receiver's instance variables: 
		bounds: 	(45.0@75.0) corner: (253.0@301.0)
		owner: 	a PanelMorph(13893632)
		submorphs: 	an Array(a Morph(316669952) a MorphTreeTransformMorph(448790528))
		fullBounds: 	(45@75) corner: (255@301)
		color: 	(Color r: 0.979 g: 0.979 b: 0.979 alpha: 1.0)
		extension: 	a MorphExtension (986447872) [other:  (dropEnabled -> true) (announc...etc...
		borderWidth: 	0
		borderColor: 	Color black
		model: 	a PackageTreeModel
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(122421248)
		scroller: 	a MorphTreeTransformMorph(448790528)
		getMenuSelector: 	#menu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(918552576)
		columns: 	an OrderedCollection(a MorphTreeColumn)
		potentialDropMorph: 	nil
		rowInset: 	0
		columnInset: 	0
		columnResizers: 	an OrderedCollection()
		withHLines: 	false
		preferedPaneColor: 	nil
		indentGap: 	20
		expandedToggleImage: 	an ImageMorph(67371008)
		notExpandedToggleImage: 	an ImageMorph(233832448)
		resizerWidth: 	3
		gapAfterToggle: 	5
		hasToggleAtRoot: 	nil
		topHeader: 	a Morph(316669952)
		topHeaderBackground: 	Color transparent
		unboundLastColumn: 	true
		columnDropUnabled: 	nil
		columnColors: 	{Color transparent. Color transparent}
		rowColors: 	{Color transparent. Color transparent}
		nodeList: 	an OrderedCollection(Node(a DynamicClassGroup ( Last Modified Classes...etc...
		iconBlock: 	nil
		treeLineWidth: 	0
		lineColorBlock: 	nil
		treeLineDashes: 	nil
		listManager: 	a MorphTreeListManager
		mouseOverAllowed: 	false
		maxNodeWidth: 	155
		enabled: 	true


MorphTreeMorph(Morph)>>handleFocusEvent:
	Receiver: a MorphTreeMorph(68943872)
	Arguments and temporary variables: 
		anEvent: 	[(147@150) mouseUp 497635 nil]
	Receiver's instance variables: 
		bounds: 	(45.0@75.0) corner: (253.0@301.0)
		owner: 	a PanelMorph(13893632)
		submorphs: 	an Array(a Morph(316669952) a MorphTreeTransformMorph(448790528))
		fullBounds: 	(45@75) corner: (255@301)
		color: 	(Color r: 0.979 g: 0.979 b: 0.979 alpha: 1.0)
		extension: 	a MorphExtension (986447872) [other:  (dropEnabled -> true) (announc...etc...
		borderWidth: 	0
		borderColor: 	Color black
		model: 	a PackageTreeModel
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(122421248)
		scroller: 	a MorphTreeTransformMorph(448790528)
		getMenuSelector: 	#menu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(918552576)
		columns: 	an OrderedCollection(a MorphTreeColumn)
		potentialDropMorph: 	nil
		rowInset: 	0
		columnInset: 	0
		columnResizers: 	an OrderedCollection()
		withHLines: 	false
		preferedPaneColor: 	nil
		indentGap: 	20
		expandedToggleImage: 	an ImageMorph(67371008)
		notExpandedToggleImage: 	an ImageMorph(233832448)
		resizerWidth: 	3
		gapAfterToggle: 	5
		hasToggleAtRoot: 	nil
		topHeader: 	a Morph(316669952)
		topHeaderBackground: 	Color transparent
		unboundLastColumn: 	true
		columnDropUnabled: 	nil
		columnColors: 	{Color transparent. Color transparent}
		rowColors: 	{Color transparent. Color transparent}
		nodeList: 	an OrderedCollection(Node(a DynamicClassGroup ( Last Modified Classes...etc...
		iconBlock: 	nil
		treeLineWidth: 	0
		lineColorBlock: 	nil
		treeLineDashes: 	nil
		listManager: 	a MorphTreeListManager
		mouseOverAllowed: 	false
		maxNodeWidth: 	155
		enabled: 	true


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(147@150) mouseUp 497635 nil]
		focusHolder: 	a MorphTreeMorph(68943872)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(147@150.0) corner: (163@166.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(147@150.0) corner: (163@166.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a MorphTreeMorph(68943872)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	a MouseClickState[#firstClickUp]
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(147@150) mouseUp 497635 nil]
		targetOffset: 	(102.0@75.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 497635 147 150 0 0 0 1)
		lastKeyScanCode: 	27
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	[(147@150) mouseOver red nil nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1208@742)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a NautilusWindow(911998976) a Sys...etc...
		fullBounds: 	(0@0) corner: (1208@742)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(147@150) mouseUp 497635 nil]
		focusHolder: 	a MorphTreeMorph(68943872)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		bounds: 	(147@150.0) corner: (163@166.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(147@150.0) corner: (163@166.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a MorphTreeMorph(68943872)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	a MouseClickState[#firstClickUp]
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(147@150) mouseUp 497635 nil]
		targetOffset: 	(102.0@75.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 497635 147 150 0 0 0 1)
		lastKeyScanCode: 	27
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(147@150) mouseUp 497635 nil]
		focusHolder: 	a MorphTreeMorph(68943872)
		aBlock: 	[ self mouseFocus: nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(147@150.0) corner: (163@166.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(147@150.0) corner: (163@166.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a MorphTreeMorph(68943872)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	a MouseClickState[#firstClickUp]
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(147@150) mouseUp 497635 nil]
		targetOffset: 	(102.0@75.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 497635 147 150 0 0 0 1)
		lastKeyScanCode: 	27
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(147@150) mouseUp 497635 nil]
	Receiver's instance variables: 
		bounds: 	(147@150.0) corner: (163@166.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(147@150.0) corner: (163@166.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a MorphTreeMorph(68943872)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	a MouseClickState[#firstClickUp]
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(147@150) mouseUp 497635 nil]
		targetOffset: 	(102.0@75.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 497635 147 150 0 0 0 1)
		lastKeyScanCode: 	27
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>handleEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(147@150) mouseUp 497635 nil]
		evt: 	[(147@150) mouseUp 497635 nil]
	Receiver's instance variables: 
		bounds: 	(147@150.0) corner: (163@166.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(147@150.0) corner: (163@166.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a MorphTreeMorph(68943872)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	a MouseClickState[#firstClickUp]
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(147@150) mouseUp 497635 nil]
		targetOffset: 	(102.0@75.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 497635 147 150 0 0 0 1)
		lastKeyScanCode: 	27
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


MouseClickState>>handleEvent:from:
	Receiver: a MouseClickState[#firstClickUp]
	Arguments and temporary variables: 
		evt: 	[(147@150) mouseUp 497635 nil]
		aHand: 	a HandMorph(760479744)
		localEvt: 	[(147@150) mouseUp 497635 nil]
		timedOut: 	false
		isDrag: 	false
	Receiver's instance variables: 
		clickClient: 	a MorphTreeMorph(68943872)
		clickState: 	#firstClickUp
		firstClickDown: 	[(147@150) mouseDown red 497582 nil]
		firstClickUp: 	[(147@150) mouseUp 497635 nil]
		firstClickTime: 	497582
		clickSelector: 	#click:
		dblClickSelector: 	#doubleClick:
		dblClickTime: 	350
		dblClickTimeoutSelector: 	nil
		dragSelector: 	nil
		dragThreshold: 	10


HandMorph>>handleEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(147@150) mouseUp 497635 nil]
		evt: 	[(147@150) mouseUp 497635 nil]
	Receiver's instance variables: 
		bounds: 	(147@150.0) corner: (163@166.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(147@150.0) corner: (163@166.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a MorphTreeMorph(68943872)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	a MouseClickState[#firstClickUp]
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(147@150) mouseUp 497635 nil]
		targetOffset: 	(102.0@75.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 497635 147 150 0 0 0 1)
		lastKeyScanCode: 	27
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>processEvents
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		evt: 	[(147@150) mouseUp 497635 nil]
		evtBuf: 	#(1 497635 147 150 0 0 0 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	(147@150.0) corner: (163@166.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(147@150.0) corner: (163@166.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a MorphTreeMorph(68943872)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	a MouseClickState[#firstClickUp]
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(147@150) mouseOver nil nil]
		targetOffset: 	(102.0@75.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 497635 147 150 0 0 0 1)
		lastKeyScanCode: 	27
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		h: 	a HandMorph(760479744)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1208@742)
		canvas: 	a FormCanvas on: DisplayScreen(1208x742x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(170917888))(a DropList...etc...
		lastStepTime: 	497900
		lastStepMessage: 	nil
		lastCycleTime: 	497900
		alarms: 	a Heap()
		lastAlarmTime: 	497900
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(760479744))
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(760479744))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1208@742)
		canvas: 	a FormCanvas on: DisplayScreen(1208x742x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(170917888))(a DropList...etc...
		lastStepTime: 	497900
		lastStepMessage: 	nil
		lastCycleTime: 	497900
		alarms: 	a Heap()
		lastAlarmTime: 	497900
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1208@742)
		canvas: 	a FormCanvas on: DisplayScreen(1208x742x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(170917888))(a DropList...etc...
		lastStepTime: 	497900
		lastStepMessage: 	nil
		lastCycleTime: 	497900
		alarms: 	a Heap()
		lastAlarmTime: 	497900
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1208@742)
		canvas: 	a FormCanvas on: DisplayScreen(1208x742x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(170917888))(a DropList...etc...
		lastStepTime: 	497900
		lastStepMessage: 	nil
		lastCycleTime: 	497900
		alarms: 	a Heap()
		lastAlarmTime: 	497900
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1208@742)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a NautilusWindow(911998976) a Sys...etc...
		fullBounds: 	(0@0) corner: (1208@742)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
World doOneCycle.
Processor yield.
false ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #lastClicked:
MorphTreeListManager>>lastClickedMorph:
MorphTreeListManager>>selectMorph:multiple:clickedTheCheckBox:
MorphTreeListManager>>mouseUp:on:
MorphTreeMorph>>mouseUp:
MorphTreeMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
MorphTreeMorph(Morph)>>handleEvent:
MorphTreeMorph(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseClickState>>handleEvent:from:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: receiver of "lastClicked:" is nil
16 October 2014 4:07:12.293262 pm

VM: Mac OS - intel - 1090 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30858]

UndefinedObject(Object)>>doesNotUnderstand: #lastClicked:
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	lastClicked: false
		exception: 	MessageNotUnderstood: receiver of "lastClicked:" is nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

MorphTreeListManager>>lastClickedMorph:
	Receiver: a MorphTreeListManager
	Arguments and temporary variables: 
		aNodeMorph: 	NodeMorph(Node(a RPackage(PBE−LightsOut)))
	Receiver's instance variables: 
		keystrokeActionSelector: 	nil
		multipleSelection: 	true
		autoMultiSelection: 	false
		potentialDropMorph: 	nil
		firstClickedMorph: 	NodeMorph(Node(a RPackage(PBE−LightsOut)))
		lastClickedMorph: 	NodeMorph(nil)
		columnDropUnabled: 	nil
		doubleClickBlock: 	nil
		autoDeselection: 	false
		searchedElement: 	nil
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		lastSelection: 	0
		client: 	a MorphTreeMorph(68943872)
		isSelectionUpdateFromView: 	false
		isCheckList: 	false
		autoTargetMorph: 	nil
		selectedMorphList: 	a LinkedList(NodeMorph(Node(a RPackage(PBE-LightsOut))))
		removeOnlyLastSelected: 	false


MorphTreeListManager>>selectMorph:multiple:clickedTheCheckBox:
	Receiver: a MorphTreeListManager
	Arguments and temporary variables: 
		aNodeMorph: 	NodeMorph(Node(a RPackage(PBE−LightsOut)))		withMultipleSelection: 	false		checkBox: 	false		path: 	nil		mult: 	nil
	Receiver's instance variables: 
		keystrokeActionSelector: 	nil
		multipleSelection: 	true
		autoMultiSelection: 	false
		potentialDropMorph: 	nil
		firstClickedMorph: 	NodeMorph(Node(a RPackage(PBE−LightsOut)))
		lastClickedMorph: 	NodeMorph(nil)
		columnDropUnabled: 	nil
		doubleClickBlock: 	nil
		autoDeselection: 	false
		searchedElement: 	nil
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		lastSelection: 	0
		client: 	a MorphTreeMorph(68943872)
		isSelectionUpdateFromView: 	false
		isCheckList: 	false
		autoTargetMorph: 	nil
		selectedMorphList: 	a LinkedList(NodeMorph(Node(a RPackage(PBE-LightsOut))))
		removeOnlyLastSelected: 	false


MorphTreeListManager>>mouseUp:on:
	Receiver: a MorphTreeListManager
	Arguments and temporary variables: 
		event: 	[(113@152) mouseUp 500476 nil]		aNodeMorph: 	NodeMorph(Node(a RPackage(PBE−LightsOut)))		path: 	nil		cmdOrCtrl: 	false		clickedTheCheckbox: 	false
	Receiver's instance variables: 
		keystrokeActionSelector: 	nil
		multipleSelection: 	true
		autoMultiSelection: 	false
		potentialDropMorph: 	nil
		firstClickedMorph: 	NodeMorph(Node(a RPackage(PBE−LightsOut)))
		lastClickedMorph: 	NodeMorph(nil)
		columnDropUnabled: 	nil
		doubleClickBlock: 	nil
		autoDeselection: 	false
		searchedElement: 	nil
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		lastSelection: 	0
		client: 	a MorphTreeMorph(68943872)
		isSelectionUpdateFromView: 	false
		isCheckList: 	false
		autoTargetMorph: 	nil
		selectedMorphList: 	a LinkedList(NodeMorph(Node(a RPackage(PBE-LightsOut))))
		removeOnlyLastSelected: 	false


MorphTreeMorph>>mouseUp:
	Receiver: a MorphTreeMorph(68943872)
	Arguments and temporary variables: 
		event: 	[(113@152) mouseUp 500476 nil]		nodeMorph: 	NodeMorph(Node(a RPackage(PBE−LightsOut)))		wasHigh: 	true
	Receiver's instance variables: 
		bounds: 	(45.0@75.0) corner: (253.0@301.0)
		owner: 	a PanelMorph(13893632)
		submorphs: 	an Array(a Morph(316669952) a MorphTreeTransformMorph(448790528))
		fullBounds: 	(45@75) corner: (255@301)
		color: 	(Color r: 0.979 g: 0.979 b: 0.979 alpha: 1.0)
		extension: 	a MorphExtension (986447872) [other:  (dropEnabled -> true) (announc...etc...
		borderWidth: 	0
		borderColor: 	Color black
		model: 	a PackageTreeModel
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(122421248)
		scroller: 	a MorphTreeTransformMorph(448790528)
		getMenuSelector: 	#menu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(918552576)
		columns: 	an OrderedCollection(a MorphTreeColumn)
		potentialDropMorph: 	nil
		rowInset: 	0
		columnInset: 	0
		columnResizers: 	an OrderedCollection()
		withHLines: 	false
		preferedPaneColor: 	nil
		indentGap: 	20
		expandedToggleImage: 	an ImageMorph(67371008)
		notExpandedToggleImage: 	an ImageMorph(233832448)
		resizerWidth: 	3
		gapAfterToggle: 	5
		hasToggleAtRoot: 	nil
		topHeader: 	a Morph(316669952)
		topHeaderBackground: 	Color transparent
		unboundLastColumn: 	true
		columnDropUnabled: 	nil
		columnColors: 	{Color transparent. Color transparent}
		rowColors: 	{Color transparent. Color transparent}
		nodeList: 	an OrderedCollection(Node(a DynamicClassGroup ( Last Modified Classes...etc...
		iconBlock: 	nil
		treeLineWidth: 	0
		lineColorBlock: 	nil
		treeLineDashes: 	nil
		listManager: 	a MorphTreeListManager
		mouseOverAllowed: 	false
		maxNodeWidth: 	155
		enabled: 	true


MorphTreeMorph(Morph)>>handleMouseUp:
	Receiver: a MorphTreeMorph(68943872)
	Arguments and temporary variables: 
		anEvent: 	[(113@152) mouseUp 500476 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(45.0@75.0) corner: (253.0@301.0)
		owner: 	a PanelMorph(13893632)
		submorphs: 	an Array(a Morph(316669952) a MorphTreeTransformMorph(448790528))
		fullBounds: 	(45@75) corner: (255@301)
		color: 	(Color r: 0.979 g: 0.979 b: 0.979 alpha: 1.0)
		extension: 	a MorphExtension (986447872) [other:  (dropEnabled -> true) (announc...etc...
		borderWidth: 	0
		borderColor: 	Color black
		model: 	a PackageTreeModel
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(122421248)
		scroller: 	a MorphTreeTransformMorph(448790528)
		getMenuSelector: 	#menu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(918552576)
		columns: 	an OrderedCollection(a MorphTreeColumn)
		potentialDropMorph: 	nil
		rowInset: 	0
		columnInset: 	0
		columnResizers: 	an OrderedCollection()
		withHLines: 	false
		preferedPaneColor: 	nil
		indentGap: 	20
		expandedToggleImage: 	an ImageMorph(67371008)
		notExpandedToggleImage: 	an ImageMorph(233832448)
		resizerWidth: 	3
		gapAfterToggle: 	5
		hasToggleAtRoot: 	nil
		topHeader: 	a Morph(316669952)
		topHeaderBackground: 	Color transparent
		unboundLastColumn: 	true
		columnDropUnabled: 	nil
		columnColors: 	{Color transparent. Color transparent}
		rowColors: 	{Color transparent. Color transparent}
		nodeList: 	an OrderedCollection(Node(a DynamicClassGroup ( Last Modified Classes...etc...
		iconBlock: 	nil
		treeLineWidth: 	0
		lineColorBlock: 	nil
		treeLineDashes: 	nil
		listManager: 	a MorphTreeListManager
		mouseOverAllowed: 	false
		maxNodeWidth: 	155
		enabled: 	true


MouseButtonEvent>>sentTo:
	Receiver: [(113@152) mouseUp 500476 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphTreeMorph(68943872)
	Receiver's instance variables: 
		timeStamp: 	500476
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(113@152)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


MorphTreeMorph(Morph)>>handleEvent:
	Receiver: a MorphTreeMorph(68943872)
	Arguments and temporary variables: 
		anEvent: 	[(113@152) mouseUp 500476 nil]
	Receiver's instance variables: 
		bounds: 	(45.0@75.0) corner: (253.0@301.0)
		owner: 	a PanelMorph(13893632)
		submorphs: 	an Array(a Morph(316669952) a MorphTreeTransformMorph(448790528))
		fullBounds: 	(45@75) corner: (255@301)
		color: 	(Color r: 0.979 g: 0.979 b: 0.979 alpha: 1.0)
		extension: 	a MorphExtension (986447872) [other:  (dropEnabled -> true) (announc...etc...
		borderWidth: 	0
		borderColor: 	Color black
		model: 	a PackageTreeModel
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(122421248)
		scroller: 	a MorphTreeTransformMorph(448790528)
		getMenuSelector: 	#menu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(918552576)
		columns: 	an OrderedCollection(a MorphTreeColumn)
		potentialDropMorph: 	nil
		rowInset: 	0
		columnInset: 	0
		columnResizers: 	an OrderedCollection()
		withHLines: 	false
		preferedPaneColor: 	nil
		indentGap: 	20
		expandedToggleImage: 	an ImageMorph(67371008)
		notExpandedToggleImage: 	an ImageMorph(233832448)
		resizerWidth: 	3
		gapAfterToggle: 	5
		hasToggleAtRoot: 	nil
		topHeader: 	a Morph(316669952)
		topHeaderBackground: 	Color transparent
		unboundLastColumn: 	true
		columnDropUnabled: 	nil
		columnColors: 	{Color transparent. Color transparent}
		rowColors: 	{Color transparent. Color transparent}
		nodeList: 	an OrderedCollection(Node(a DynamicClassGroup ( Last Modified Classes...etc...
		iconBlock: 	nil
		treeLineWidth: 	0
		lineColorBlock: 	nil
		treeLineDashes: 	nil
		listManager: 	a MorphTreeListManager
		mouseOverAllowed: 	false
		maxNodeWidth: 	155
		enabled: 	true


MorphTreeMorph(Morph)>>handleFocusEvent:
	Receiver: a MorphTreeMorph(68943872)
	Arguments and temporary variables: 
		anEvent: 	[(113@152) mouseUp 500476 nil]
	Receiver's instance variables: 
		bounds: 	(45.0@75.0) corner: (253.0@301.0)
		owner: 	a PanelMorph(13893632)
		submorphs: 	an Array(a Morph(316669952) a MorphTreeTransformMorph(448790528))
		fullBounds: 	(45@75) corner: (255@301)
		color: 	(Color r: 0.979 g: 0.979 b: 0.979 alpha: 1.0)
		extension: 	a MorphExtension (986447872) [other:  (dropEnabled -> true) (announc...etc...
		borderWidth: 	0
		borderColor: 	Color black
		model: 	a PackageTreeModel
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(122421248)
		scroller: 	a MorphTreeTransformMorph(448790528)
		getMenuSelector: 	#menu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(918552576)
		columns: 	an OrderedCollection(a MorphTreeColumn)
		potentialDropMorph: 	nil
		rowInset: 	0
		columnInset: 	0
		columnResizers: 	an OrderedCollection()
		withHLines: 	false
		preferedPaneColor: 	nil
		indentGap: 	20
		expandedToggleImage: 	an ImageMorph(67371008)
		notExpandedToggleImage: 	an ImageMorph(233832448)
		resizerWidth: 	3
		gapAfterToggle: 	5
		hasToggleAtRoot: 	nil
		topHeader: 	a Morph(316669952)
		topHeaderBackground: 	Color transparent
		unboundLastColumn: 	true
		columnDropUnabled: 	nil
		columnColors: 	{Color transparent. Color transparent}
		rowColors: 	{Color transparent. Color transparent}
		nodeList: 	an OrderedCollection(Node(a DynamicClassGroup ( Last Modified Classes...etc...
		iconBlock: 	nil
		treeLineWidth: 	0
		lineColorBlock: 	nil
		treeLineDashes: 	nil
		listManager: 	a MorphTreeListManager
		mouseOverAllowed: 	false
		maxNodeWidth: 	155
		enabled: 	true


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(113@152) mouseUp 500476 nil]
		focusHolder: 	a MorphTreeMorph(68943872)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(113@152.0) corner: (129@168.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(113@152.0) corner: (129@168.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a MorphTreeMorph(68943872)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	a MouseClickState[#firstClickUp]
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(113@152) mouseUp 500476 nil]
		targetOffset: 	(68.0@77.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 500476 113 152 0 0 0 1)
		lastKeyScanCode: 	27
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	[(113@152) mouseOver red nil nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1208@742)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a NautilusWindow(911998976) a Sys...etc...
		fullBounds: 	(0@0) corner: (1208@742)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(113@152) mouseUp 500476 nil]
		focusHolder: 	a MorphTreeMorph(68943872)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		bounds: 	(113@152.0) corner: (129@168.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(113@152.0) corner: (129@168.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a MorphTreeMorph(68943872)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	a MouseClickState[#firstClickUp]
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(113@152) mouseUp 500476 nil]
		targetOffset: 	(68.0@77.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 500476 113 152 0 0 0 1)
		lastKeyScanCode: 	27
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(113@152) mouseUp 500476 nil]
		focusHolder: 	a MorphTreeMorph(68943872)
		aBlock: 	[ self mouseFocus: nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(113@152.0) corner: (129@168.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(113@152.0) corner: (129@168.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a MorphTreeMorph(68943872)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	a MouseClickState[#firstClickUp]
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(113@152) mouseUp 500476 nil]
		targetOffset: 	(68.0@77.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 500476 113 152 0 0 0 1)
		lastKeyScanCode: 	27
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(113@152) mouseUp 500476 nil]
	Receiver's instance variables: 
		bounds: 	(113@152.0) corner: (129@168.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(113@152.0) corner: (129@168.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a MorphTreeMorph(68943872)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	a MouseClickState[#firstClickUp]
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(113@152) mouseUp 500476 nil]
		targetOffset: 	(68.0@77.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 500476 113 152 0 0 0 1)
		lastKeyScanCode: 	27
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>handleEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(113@152) mouseUp 500476 nil]
		evt: 	[(113@152) mouseUp 500476 nil]
	Receiver's instance variables: 
		bounds: 	(113@152.0) corner: (129@168.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(113@152.0) corner: (129@168.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a MorphTreeMorph(68943872)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	a MouseClickState[#firstClickUp]
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(113@152) mouseUp 500476 nil]
		targetOffset: 	(68.0@77.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 500476 113 152 0 0 0 1)
		lastKeyScanCode: 	27
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


MouseClickState>>handleEvent:from:
	Receiver: a MouseClickState[#firstClickUp]
	Arguments and temporary variables: 
		evt: 	[(113@152) mouseUp 500476 nil]
		aHand: 	a HandMorph(760479744)
		localEvt: 	[(113@152) mouseUp 500476 nil]
		timedOut: 	false
		isDrag: 	false
	Receiver's instance variables: 
		clickClient: 	a MorphTreeMorph(68943872)
		clickState: 	#firstClickUp
		firstClickDown: 	[(113@152) mouseDown red 500412 nil]
		firstClickUp: 	[(113@152) mouseUp 500476 nil]
		firstClickTime: 	500412
		clickSelector: 	#click:
		dblClickSelector: 	#doubleClick:
		dblClickTime: 	350
		dblClickTimeoutSelector: 	nil
		dragSelector: 	nil
		dragThreshold: 	10


HandMorph>>handleEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(113@152) mouseUp 500476 nil]
		evt: 	[(113@152) mouseUp 500476 nil]
	Receiver's instance variables: 
		bounds: 	(113@152.0) corner: (129@168.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(113@152.0) corner: (129@168.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a MorphTreeMorph(68943872)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	a MouseClickState[#firstClickUp]
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(113@152) mouseUp 500476 nil]
		targetOffset: 	(68.0@77.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 500476 113 152 0 0 0 1)
		lastKeyScanCode: 	27
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>processEvents
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		evt: 	[(113@152) mouseUp 500476 nil]
		evtBuf: 	#(1 500476 113 152 0 0 0 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	(113@152.0) corner: (129@168.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(113@152.0) corner: (129@168.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a MorphTreeMorph(68943872)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	a MouseClickState[#firstClickUp]
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(113@152) mouseUp 500476 nil]
		targetOffset: 	(68.0@77.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 500476 113 152 0 0 0 1)
		lastKeyScanCode: 	27
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		h: 	a HandMorph(760479744)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1208@742)
		canvas: 	a FormCanvas on: DisplayScreen(1208x742x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(652738560))(a SearchMorp...etc...
		lastStepTime: 	500415
		lastStepMessage: 	nil
		lastCycleTime: 	500493
		alarms: 	a Heap()
		lastAlarmTime: 	500415
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(760479744))
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(760479744))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1208@742)
		canvas: 	a FormCanvas on: DisplayScreen(1208x742x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(652738560))(a SearchMorp...etc...
		lastStepTime: 	500415
		lastStepMessage: 	nil
		lastCycleTime: 	500493
		alarms: 	a Heap()
		lastAlarmTime: 	500415
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1208@742)
		canvas: 	a FormCanvas on: DisplayScreen(1208x742x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(652738560))(a SearchMorp...etc...
		lastStepTime: 	500415
		lastStepMessage: 	nil
		lastCycleTime: 	500493
		alarms: 	a Heap()
		lastAlarmTime: 	500415
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1208@742)
		canvas: 	a FormCanvas on: DisplayScreen(1208x742x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SpecDropListMorph(127139840))(a Spec...etc...
		lastStepTime: 	500621
		lastStepMessage: 	nil
		lastCycleTime: 	500621
		alarms: 	a Heap()
		lastAlarmTime: 	500621
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1208@742)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a NautilusWindow(911998976) a Sys...etc...
		fullBounds: 	(0@0) corner: (1208@742)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
World doOneCycle.
Processor yield.
false ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #lastClicked:
MorphTreeListManager>>lastClickedMorph:
MorphTreeListManager>>selectMorph:multiple:clickedTheCheckBox:
MorphTreeListManager>>mouseUp:on:
MorphTreeMorph>>mouseUp:
MorphTreeMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
MorphTreeMorph(Morph)>>handleEvent:
MorphTreeMorph(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseClickState>>handleEvent:from:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: receiver of "lastClicked:" is nil
16 October 2014 4:07:20.558306 pm

VM: Mac OS - intel - 1090 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30858]

UndefinedObject(Object)>>doesNotUnderstand: #lastClicked:
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	lastClicked: false
		exception: 	MessageNotUnderstood: receiver of "lastClicked:" is nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

MorphTreeListManager>>lastClickedMorph:
	Receiver: a MorphTreeListManager
	Arguments and temporary variables: 
		aNodeMorph: 	NodeMorph(Node(a DynamicClassGroup ( Most Viewed Classes )))
	Receiver's instance variables: 
		keystrokeActionSelector: 	nil
		multipleSelection: 	true
		autoMultiSelection: 	false
		potentialDropMorph: 	nil
		firstClickedMorph: 	NodeMorph(Node(a DynamicClassGroup ( Most Viewed Classes )))...etc...
		lastClickedMorph: 	NodeMorph(nil)
		columnDropUnabled: 	nil
		doubleClickBlock: 	nil
		autoDeselection: 	false
		searchedElement: 	nil
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		lastSelection: 	0
		client: 	a MorphTreeMorph(68943872)
		isSelectionUpdateFromView: 	false
		isCheckList: 	false
		autoTargetMorph: 	nil
		selectedMorphList: 	a LinkedList(NodeMorph(Node(a RPackage(PBE-LightsOut))))
		removeOnlyLastSelected: 	false


MorphTreeListManager>>selectMorph:multiple:clickedTheCheckBox:
	Receiver: a MorphTreeListManager
	Arguments and temporary variables: 
		aNodeMorph: 	NodeMorph(Node(a DynamicClassGroup ( Most Viewed Classes )))
		withMultipleSelection: 	false
		checkBox: 	false
		path: 	nil
		mult: 	nil
	Receiver's instance variables: 
		keystrokeActionSelector: 	nil
		multipleSelection: 	true
		autoMultiSelection: 	false
		potentialDropMorph: 	nil
		firstClickedMorph: 	NodeMorph(Node(a DynamicClassGroup ( Most Viewed Classes )))...etc...
		lastClickedMorph: 	NodeMorph(nil)
		columnDropUnabled: 	nil
		doubleClickBlock: 	nil
		autoDeselection: 	false
		searchedElement: 	nil
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		lastSelection: 	0
		client: 	a MorphTreeMorph(68943872)
		isSelectionUpdateFromView: 	false
		isCheckList: 	false
		autoTargetMorph: 	nil
		selectedMorphList: 	a LinkedList(NodeMorph(Node(a RPackage(PBE-LightsOut))))
		removeOnlyLastSelected: 	false


MorphTreeListManager>>mouseUp:on:
	Receiver: a MorphTreeListManager
	Arguments and temporary variables: 
		event: 	[(120@101) mouseUp 508658 nil]
		aNodeMorph: 	NodeMorph(Node(a DynamicClassGroup ( Most Viewed Classes )))
		path: 	nil
		cmdOrCtrl: 	false
		clickedTheCheckbox: 	false
	Receiver's instance variables: 
		keystrokeActionSelector: 	nil
		multipleSelection: 	true
		autoMultiSelection: 	false
		potentialDropMorph: 	nil
		firstClickedMorph: 	NodeMorph(Node(a DynamicClassGroup ( Most Viewed Classes )))...etc...
		lastClickedMorph: 	NodeMorph(nil)
		columnDropUnabled: 	nil
		doubleClickBlock: 	nil
		autoDeselection: 	false
		searchedElement: 	nil
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		lastSelection: 	0
		client: 	a MorphTreeMorph(68943872)
		isSelectionUpdateFromView: 	false
		isCheckList: 	false
		autoTargetMorph: 	nil
		selectedMorphList: 	a LinkedList(NodeMorph(Node(a RPackage(PBE-LightsOut))))
		removeOnlyLastSelected: 	false


MorphTreeMorph>>mouseUp:
	Receiver: a MorphTreeMorph(68943872)
	Arguments and temporary variables: 
		event: 	[(120@101) mouseUp 508658 nil]
		nodeMorph: 	NodeMorph(Node(a DynamicClassGroup ( Most Viewed Classes )))
		wasHigh: 	true
	Receiver's instance variables: 
		bounds: 	(45.0@75.0) corner: (253.0@301.0)
		owner: 	a PanelMorph(13893632)
		submorphs: 	an Array(a Morph(316669952) a MorphTreeTransformMorph(448790528))
		fullBounds: 	(45@75) corner: (255@301)
		color: 	(Color r: 0.979 g: 0.979 b: 0.979 alpha: 1.0)
		extension: 	a MorphExtension (986447872) [other:  (dropEnabled -> true) (announc...etc...
		borderWidth: 	0
		borderColor: 	Color black
		model: 	a PackageTreeModel
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(122421248)
		scroller: 	a MorphTreeTransformMorph(448790528)
		getMenuSelector: 	#menu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(918552576)
		columns: 	an OrderedCollection(a MorphTreeColumn)
		potentialDropMorph: 	nil
		rowInset: 	0
		columnInset: 	0
		columnResizers: 	an OrderedCollection()
		withHLines: 	false
		preferedPaneColor: 	nil
		indentGap: 	20
		expandedToggleImage: 	an ImageMorph(67371008)
		notExpandedToggleImage: 	an ImageMorph(233832448)
		resizerWidth: 	3
		gapAfterToggle: 	5
		hasToggleAtRoot: 	nil
		topHeader: 	a Morph(316669952)
		topHeaderBackground: 	Color transparent
		unboundLastColumn: 	true
		columnDropUnabled: 	nil
		columnColors: 	{Color transparent. Color transparent}
		rowColors: 	{Color transparent. Color transparent}
		nodeList: 	an OrderedCollection(Node(a DynamicClassGroup ( Last Modified Classes...etc...
		iconBlock: 	nil
		treeLineWidth: 	0
		lineColorBlock: 	nil
		treeLineDashes: 	nil
		listManager: 	a MorphTreeListManager
		mouseOverAllowed: 	false
		maxNodeWidth: 	155
		enabled: 	true


MorphTreeMorph(Morph)>>handleMouseUp:
	Receiver: a MorphTreeMorph(68943872)
	Arguments and temporary variables: 
		anEvent: 	[(120@101) mouseUp 508658 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(45.0@75.0) corner: (253.0@301.0)
		owner: 	a PanelMorph(13893632)
		submorphs: 	an Array(a Morph(316669952) a MorphTreeTransformMorph(448790528))
		fullBounds: 	(45@75) corner: (255@301)
		color: 	(Color r: 0.979 g: 0.979 b: 0.979 alpha: 1.0)
		extension: 	a MorphExtension (986447872) [other:  (dropEnabled -> true) (announc...etc...
		borderWidth: 	0
		borderColor: 	Color black
		model: 	a PackageTreeModel
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(122421248)
		scroller: 	a MorphTreeTransformMorph(448790528)
		getMenuSelector: 	#menu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(918552576)
		columns: 	an OrderedCollection(a MorphTreeColumn)
		potentialDropMorph: 	nil
		rowInset: 	0
		columnInset: 	0
		columnResizers: 	an OrderedCollection()
		withHLines: 	false
		preferedPaneColor: 	nil
		indentGap: 	20
		expandedToggleImage: 	an ImageMorph(67371008)
		notExpandedToggleImage: 	an ImageMorph(233832448)
		resizerWidth: 	3
		gapAfterToggle: 	5
		hasToggleAtRoot: 	nil
		topHeader: 	a Morph(316669952)
		topHeaderBackground: 	Color transparent
		unboundLastColumn: 	true
		columnDropUnabled: 	nil
		columnColors: 	{Color transparent. Color transparent}
		rowColors: 	{Color transparent. Color transparent}
		nodeList: 	an OrderedCollection(Node(a DynamicClassGroup ( Last Modified Classes...etc...
		iconBlock: 	nil
		treeLineWidth: 	0
		lineColorBlock: 	nil
		treeLineDashes: 	nil
		listManager: 	a MorphTreeListManager
		mouseOverAllowed: 	false
		maxNodeWidth: 	155
		enabled: 	true


MouseButtonEvent>>sentTo:
	Receiver: [(120@101) mouseUp 508658 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphTreeMorph(68943872)
	Receiver's instance variables: 
		timeStamp: 	508658
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(120@101)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


MorphTreeMorph(Morph)>>handleEvent:
	Receiver: a MorphTreeMorph(68943872)
	Arguments and temporary variables: 
		anEvent: 	[(120@101) mouseUp 508658 nil]
	Receiver's instance variables: 
		bounds: 	(45.0@75.0) corner: (253.0@301.0)
		owner: 	a PanelMorph(13893632)
		submorphs: 	an Array(a Morph(316669952) a MorphTreeTransformMorph(448790528))
		fullBounds: 	(45@75) corner: (255@301)
		color: 	(Color r: 0.979 g: 0.979 b: 0.979 alpha: 1.0)
		extension: 	a MorphExtension (986447872) [other:  (dropEnabled -> true) (announc...etc...
		borderWidth: 	0
		borderColor: 	Color black
		model: 	a PackageTreeModel
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(122421248)
		scroller: 	a MorphTreeTransformMorph(448790528)
		getMenuSelector: 	#menu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(918552576)
		columns: 	an OrderedCollection(a MorphTreeColumn)
		potentialDropMorph: 	nil
		rowInset: 	0
		columnInset: 	0
		columnResizers: 	an OrderedCollection()
		withHLines: 	false
		preferedPaneColor: 	nil
		indentGap: 	20
		expandedToggleImage: 	an ImageMorph(67371008)
		notExpandedToggleImage: 	an ImageMorph(233832448)
		resizerWidth: 	3
		gapAfterToggle: 	5
		hasToggleAtRoot: 	nil
		topHeader: 	a Morph(316669952)
		topHeaderBackground: 	Color transparent
		unboundLastColumn: 	true
		columnDropUnabled: 	nil
		columnColors: 	{Color transparent. Color transparent}
		rowColors: 	{Color transparent. Color transparent}
		nodeList: 	an OrderedCollection(Node(a DynamicClassGroup ( Last Modified Classes...etc...
		iconBlock: 	nil
		treeLineWidth: 	0
		lineColorBlock: 	nil
		treeLineDashes: 	nil
		listManager: 	a MorphTreeListManager
		mouseOverAllowed: 	false
		maxNodeWidth: 	155
		enabled: 	true


MorphTreeMorph(Morph)>>handleFocusEvent:
	Receiver: a MorphTreeMorph(68943872)
	Arguments and temporary variables: 
		anEvent: 	[(120@101) mouseUp 508658 nil]
	Receiver's instance variables: 
		bounds: 	(45.0@75.0) corner: (253.0@301.0)
		owner: 	a PanelMorph(13893632)
		submorphs: 	an Array(a Morph(316669952) a MorphTreeTransformMorph(448790528))
		fullBounds: 	(45@75) corner: (255@301)
		color: 	(Color r: 0.979 g: 0.979 b: 0.979 alpha: 1.0)
		extension: 	a MorphExtension (986447872) [other:  (dropEnabled -> true) (announc...etc...
		borderWidth: 	0
		borderColor: 	Color black
		model: 	a PackageTreeModel
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(122421248)
		scroller: 	a MorphTreeTransformMorph(448790528)
		getMenuSelector: 	#menu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(918552576)
		columns: 	an OrderedCollection(a MorphTreeColumn)
		potentialDropMorph: 	nil
		rowInset: 	0
		columnInset: 	0
		columnResizers: 	an OrderedCollection()
		withHLines: 	false
		preferedPaneColor: 	nil
		indentGap: 	20
		expandedToggleImage: 	an ImageMorph(67371008)
		notExpandedToggleImage: 	an ImageMorph(233832448)
		resizerWidth: 	3
		gapAfterToggle: 	5
		hasToggleAtRoot: 	nil
		topHeader: 	a Morph(316669952)
		topHeaderBackground: 	Color transparent
		unboundLastColumn: 	true
		columnDropUnabled: 	nil
		columnColors: 	{Color transparent. Color transparent}
		rowColors: 	{Color transparent. Color transparent}
		nodeList: 	an OrderedCollection(Node(a DynamicClassGroup ( Last Modified Classes...etc...
		iconBlock: 	nil
		treeLineWidth: 	0
		lineColorBlock: 	nil
		treeLineDashes: 	nil
		listManager: 	a MorphTreeListManager
		mouseOverAllowed: 	false
		maxNodeWidth: 	155
		enabled: 	true


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(120@101) mouseUp 508658 nil]
		focusHolder: 	a MorphTreeMorph(68943872)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(120@101.0) corner: (136@117.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(120@101.0) corner: (136@117.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a MorphTreeMorph(68943872)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	a MouseClickState[#firstClickUp]
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(120@101) mouseUp 508658 nil]
		targetOffset: 	(75.0@26.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 508658 120 101 0 0 0 1)
		lastKeyScanCode: 	27
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	[(120@101) mouseOver red nil nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1208@742)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a NautilusWindow(911998976) a Sys...etc...
		fullBounds: 	(0@0) corner: (1208@742)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(120@101) mouseUp 508658 nil]
		focusHolder: 	a MorphTreeMorph(68943872)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		bounds: 	(120@101.0) corner: (136@117.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(120@101.0) corner: (136@117.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a MorphTreeMorph(68943872)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	a MouseClickState[#firstClickUp]
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(120@101) mouseUp 508658 nil]
		targetOffset: 	(75.0@26.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 508658 120 101 0 0 0 1)
		lastKeyScanCode: 	27
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(120@101) mouseUp 508658 nil]
		focusHolder: 	a MorphTreeMorph(68943872)
		aBlock: 	[ self mouseFocus: nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(120@101.0) corner: (136@117.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(120@101.0) corner: (136@117.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a MorphTreeMorph(68943872)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	a MouseClickState[#firstClickUp]
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(120@101) mouseUp 508658 nil]
		targetOffset: 	(75.0@26.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 508658 120 101 0 0 0 1)
		lastKeyScanCode: 	27
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(120@101) mouseUp 508658 nil]
	Receiver's instance variables: 
		bounds: 	(120@101.0) corner: (136@117.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(120@101.0) corner: (136@117.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a MorphTreeMorph(68943872)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	a MouseClickState[#firstClickUp]
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(120@101) mouseUp 508658 nil]
		targetOffset: 	(75.0@26.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 508658 120 101 0 0 0 1)
		lastKeyScanCode: 	27
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>handleEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(120@101) mouseUp 508658 nil]
		evt: 	[(120@101) mouseUp 508658 nil]
	Receiver's instance variables: 
		bounds: 	(120@101.0) corner: (136@117.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(120@101.0) corner: (136@117.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a MorphTreeMorph(68943872)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	a MouseClickState[#firstClickUp]
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(120@101) mouseUp 508658 nil]
		targetOffset: 	(75.0@26.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 508658 120 101 0 0 0 1)
		lastKeyScanCode: 	27
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


MouseClickState>>handleEvent:from:
	Receiver: a MouseClickState[#firstClickUp]
	Arguments and temporary variables: 
		evt: 	[(120@101) mouseUp 508658 nil]
		aHand: 	a HandMorph(760479744)
		localEvt: 	[(120@101) mouseUp 508658 nil]
		timedOut: 	false
		isDrag: 	false
	Receiver's instance variables: 
		clickClient: 	a MorphTreeMorph(68943872)
		clickState: 	#firstClickUp
		firstClickDown: 	[(120@101) mouseDown red 508594 nil]
		firstClickUp: 	[(120@101) mouseUp 508658 nil]
		firstClickTime: 	508594
		clickSelector: 	#click:
		dblClickSelector: 	#doubleClick:
		dblClickTime: 	350
		dblClickTimeoutSelector: 	nil
		dragSelector: 	nil
		dragThreshold: 	10


HandMorph>>handleEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(120@101) mouseUp 508658 nil]
		evt: 	[(120@101) mouseUp 508658 nil]
	Receiver's instance variables: 
		bounds: 	(120@101.0) corner: (136@117.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(120@101.0) corner: (136@117.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a MorphTreeMorph(68943872)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	a MouseClickState[#firstClickUp]
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(120@101) mouseUp 508658 nil]
		targetOffset: 	(75.0@26.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 508658 120 101 0 0 0 1)
		lastKeyScanCode: 	27
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>processEvents
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		evt: 	[(120@101) mouseUp 508658 nil]
		evtBuf: 	#(1 508658 120 101 0 0 0 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	(120@101.0) corner: (136@117.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(120@101.0) corner: (136@117.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a MorphTreeMorph(68943872)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	a MouseClickState[#firstClickUp]
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(120@101) mouseUp 508658 nil]
		targetOffset: 	(75.0@26.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 508658 120 101 0 0 0 1)
		lastKeyScanCode: 	27
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		h: 	a HandMorph(760479744)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1208@742)
		canvas: 	a FormCanvas on: DisplayScreen(1208x742x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(652738560))(a SearchMorp...etc...
		lastStepTime: 	508610
		lastStepMessage: 	nil
		lastCycleTime: 	508758
		alarms: 	a Heap()
		lastAlarmTime: 	508610
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(760479744))
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(760479744))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1208@742)
		canvas: 	a FormCanvas on: DisplayScreen(1208x742x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(652738560))(a SearchMorp...etc...
		lastStepTime: 	508610
		lastStepMessage: 	nil
		lastCycleTime: 	508758
		alarms: 	a Heap()
		lastAlarmTime: 	508610
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1208@742)
		canvas: 	a FormCanvas on: DisplayScreen(1208x742x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(652738560))(a SearchMorp...etc...
		lastStepTime: 	508610
		lastStepMessage: 	nil
		lastCycleTime: 	508758
		alarms: 	a Heap()
		lastAlarmTime: 	508610
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1208@742)
		canvas: 	a FormCanvas on: DisplayScreen(1208x742x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(652738560))(a SearchMorp...etc...
		lastStepTime: 	508610
		lastStepMessage: 	nil
		lastCycleTime: 	508758
		alarms: 	a Heap()
		lastAlarmTime: 	508610
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1208@742)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a NautilusWindow(911998976) a Sys...etc...
		fullBounds: 	(0@0) corner: (1208@742)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
World doOneCycle.
Processor yield.
false ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #lastClicked:
MorphTreeListManager>>lastClickedMorph:
MorphTreeListManager>>selectMorph:multiple:clickedTheCheckBox:
MorphTreeListManager>>mouseUp:on:
MorphTreeMorph>>mouseUp:
MorphTreeMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
MorphTreeMorph(Morph)>>handleEvent:
MorphTreeMorph(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseClickState>>handleEvent:from:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: LOGame>>cellsPerSide
16 October 2014 4:12:32.399179 pm

VM: Mac OS - intel - 1090 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30858]

LOGame(Object)>>doesNotUnderstand: #cellsPerSide
	Receiver: a LOGame(1052770304)
	Arguments and temporary variables: 
		aMessage: 	cellsPerSide
		exception: 	MessageNotUnderstood: LOGame>>cellsPerSide
		resumeValue: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (50@40)
		owner: 	nil
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	nil
		borderWidth: 	2
		borderColor: 	Color black
		cells: 	nil


LOGame>>initialize
	Receiver: a LOGame(1052770304)
	Arguments and temporary variables: 
		sampleCell: 	nil
		width: 	nil
		height: 	nil
		n: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (50@40)
		owner: 	nil
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	nil
		borderWidth: 	2
		borderColor: 	Color black
		cells: 	nil


LOGame class(Behavior)>>new
	Receiver: LOGame
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	BorderedMorph
		methodDict: 	a MethodDictionary(#initialize->LOGame>>#initialize )
		format: 	148
		layout: 	a FixedLayout
		instanceVariables: 	#(#cells)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#LOGame
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'PBE-LightsOut'
		traitComposition: 	{}
		localSelectors: 	nil
		announcer: 	nil


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'LOGame new'
		itsSelection: 	a Text for 'LOGame new'
		itsSelectionString: 	'LOGame new'
	Receiver's instance variables: 
		ast: 	DoIt
	^ LOGame new
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


SmalltalkEditor>>evaluateSelectionAndDo:
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | result inspect ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(381419520)
		selectionShowing: 	true
		model: 	a Workspace
		editingState: 	a SmalltalkEditingState


[ textMorph editor evaluateSelectionAndDo: [ :result | result inspect ] ] in PluggableTextMorph>>inspectIt
	Receiver: a PluggableTextMorph(570949632)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(488.0@523.0) corner: (928.0@690.0)
		owner: 	a SystemWindow(481034240)
		submorphs: 	an Array(a TransformMorph(508559360))
		fullBounds: 	(488@523) corner: (928@690)
		color: 	Color white
		extension: 	a MorphExtension (360185856) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(610795520)
		scroller: 	a TransformMorph(508559360)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(526123008)
		textMorph: 	a TextMorphForEditView(381419520)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 10)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


[ result := editBlock value ] in PluggableTextMorph>>handleEdit:
	Receiver: a PluggableTextMorph(570949632)
	Arguments and temporary variables: 
		editBlock: 	[ textMorph editor evaluateSelectionAndDo: [ :result | result inspec...etc...
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(488.0@523.0) corner: (928.0@690.0)
		owner: 	a SystemWindow(481034240)
		submorphs: 	an Array(a TransformMorph(508559360))
		fullBounds: 	(488@523) corner: (928@690)
		color: 	Color white
		extension: 	a MorphExtension (360185856) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(610795520)
		scroller: 	a TransformMorph(508559360)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(526123008)
		textMorph: 	a TextMorphForEditView(381419520)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 10)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


TextMorphForEditView(TextMorph)>>handleEdit:
	Receiver: a TextMorphForEditView(381419520)
	Arguments and temporary variables: 
		editBlock: 	[ result := editBlock value ]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@18)
		owner: 	a TransformMorph(508559360)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@18)
		color: 	Color black
		extension: 	a MorphExtension (436207616) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'LOGame new'
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(570949632)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


PluggableTextMorph>>handleEdit:
	Receiver: a PluggableTextMorph(570949632)
	Arguments and temporary variables: 
		result: 	nil
		editBlock: 	[ textMorph editor evaluateSelectionAndDo: [ :result | result inspec...etc...
	Receiver's instance variables: 
		bounds: 	(488.0@523.0) corner: (928.0@690.0)
		owner: 	a SystemWindow(481034240)
		submorphs: 	an Array(a TransformMorph(508559360))
		fullBounds: 	(488@523) corner: (928@690)
		color: 	Color white
		extension: 	a MorphExtension (360185856) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(610795520)
		scroller: 	a TransformMorph(508559360)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(526123008)
		textMorph: 	a TextMorphForEditView(381419520)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 10)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


PluggableTextMorph>>inspectIt
	Receiver: a PluggableTextMorph(570949632)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(488.0@523.0) corner: (928.0@690.0)
		owner: 	a SystemWindow(481034240)
		submorphs: 	an Array(a TransformMorph(508559360))
		fullBounds: 	(488@523) corner: (928@690)
		color: 	Color white
		extension: 	a MorphExtension (360185856) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(610795520)
		scroller: 	a TransformMorph(508559360)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(526123008)
		textMorph: 	a TextMorphForEditView(381419520)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 10)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


[ :morph | morph inspectIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
	Receiver: SmalltalkEditor
	Arguments and temporary variables: 
		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a PluggableTextMorph(570949632)
	Receiver's instance variables: 
		superclass: 	TextEditor
		methodDict: 	a MethodDictionary(#argAdvance:->SmalltalkEditor>>#argAdvance: #bro...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SmalltalkEditor
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Text-Edition'
		traitComposition: 	{}
		localSelectors: 	nil
		cmdActions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop...etc...
		shiftCmdActions: 	#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #m...etc...


BlockClosure>>cull:
	Receiver: [ :morph | morph inspectIt ]
	Arguments and temporary variables: 
		anArg: 	a PluggableTextMorph(570949632)
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	182
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :morph | morph inspectIt ]
	Arguments and temporary variables: 
		firstArg: 	a PluggableTextMorph(570949632)
		secondArg: 	a PluggableTextMorph(570949632)
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	182
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :morph | morph inspectIt ]
	Arguments and temporary variables: 
		firstArg: 	a PluggableTextMorph(570949632)
		secondArg: 	a PluggableTextMorph(570949632)
		thirdArg: 	[keystroke '<Cmd-i>']
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	182
		numArgs: 	1


KMCategoryBinding>>completeMatch:buffer:
	Receiver: aKMCategoryTarget(#SmalltalkEditor)
	Arguments and temporary variables: 
		aKeymap: 	#inspectIt on Cmd + I do [ :morph | morph inspectIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
	Receiver's instance variables: 
		target: 	a PluggableTextMorph(570949632)
		category: 	a KMCategory
		morph: 	a PluggableTextMorph(570949632)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #inspectIt on Cmd + I do [ :morph | morph inspectIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		l: 	aKMCategoryTarget(#SmalltalkEditor)
	Receiver's instance variables: 
		action: 	[ :morph | morph inspectIt ]
		name: 	#inspectIt
		shortcut: 	Cmd + I
		defaultShortcut: 	Cmd + I
		description: 	''


Array(SequenceableCollection)>>do:
	Receiver: an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #inspectIt on Cmd + I do [ :morph | morph inspectIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ :morph | morph inspectIt ]
		name: 	#inspectIt
		shortcut: 	Cmd + I
		defaultShortcut: 	Cmd + I
		description: 	''


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: #inspectIt on Cmd + I do [ :morph | morph inspectIt ]

	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		action: 	[ :morph | morph inspectIt ]
		name: 	#inspectIt
		shortcut: 	Cmd + I
		defaultShortcut: 	Cmd + I
		description: 	''


[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#inspectIt on Cmd + I do [ :morph | morph inspectIt ]

	Receiver's instance variables: 
		name: 	#SmalltalkEditor
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


Set>>do:
	Receiver: a Set(#printIt on Cmd + P do [ :morph | morph printIt ]
 #previousSelection on Cmd + Shift...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	13
		each: 	#inspectIt on Cmd + I do [ :morph | morph inspectIt ]

	Receiver's instance variables: 
		tally: 	14
		array: 	an Array(#printIt on Cmd + P do [ :morph | morph printIt ]
 #previousSel...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
	Receiver's instance variables: 
		name: 	#SmalltalkEditor
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: aKMCategoryTarget(#SmalltalkEditor)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		target: 	a PluggableTextMorph(570949632)
		category: 	a KMCategory
		morph: 	a PluggableTextMorph(570949632)


[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#SmalltalkEditor)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#SmalltalkEditor) aKMCategoryTarget(#TextMorph...etc...
		morph: 	a PluggableTextMorph(570949632)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#SmalltalkEditor) aKMCategor...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	2
	Receiver's instance variables: 
		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#SmalltalkEditor) aKMC...etc...
		firstIndex: 	1
		lastIndex: 	7


KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		association: 	nil
		match: 	nil
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#SmalltalkEditor) aKMCategoryTarget(#TextMorph...etc...
		morph: 	a PluggableTextMorph(570949632)
		directKeymaps: 	a KMCategory


KMTarget>>dispatch:
	Receiver: a KMTarget
	Arguments and temporary variables: 
		buffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
	Receiver's instance variables: 
		realTarget: 	nil
		morph: 	a PluggableTextMorph(570949632)
		targetSelector: 	#yourself
		directKeymaps: 	nil
		perInstanceCategories: 	nil


[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Cmd-i>']
		targetToDispatch: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>do:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Cmd-i>']
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatcher>>dispatchKeystroke:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		aKeyEvent: 	[keystroke '<Cmd-i>']
		chain: 	a KMDispatchChain
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#MorphFocusCtrlN...etc...
		morph: 	a TextMorphForEditView(381419520)
		directKeymaps: 	a KMCategory


TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
	Receiver: a TextMorphForEditView(381419520)
	Arguments and temporary variables: 
		evt: 	[keystroke '<Cmd-i>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@18)
		owner: 	a TransformMorph(508559360)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@18)
		color: 	Color black
		extension: 	a MorphExtension (436207616) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'LOGame new'
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(570949632)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(TextMorph)>>handleKeystroke:
	Receiver: a TextMorphForEditView(381419520)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-i>']
		pasteUp: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@18)
		owner: 	a TransformMorph(508559360)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@18)
		color: 	Color black
		extension: 	a MorphExtension (436207616) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'LOGame new'
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(570949632)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


KeyboardEvent>>sentTo:
	Receiver: [keystroke '<Cmd-i>']
	Arguments and temporary variables: 
		anObject: 	a TextMorphForEditView(381419520)
	Receiver's instance variables: 
		timeStamp: 	820572
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#keystroke
		buttons: 	64
		position: 	(-4.0@7.0)
		handler: 	nil
		wasHandled: 	true
		keyValue: 	105
		charCode: 	105
		scanCode: 	34


TextMorphForEditView(Morph)>>handleEvent:
	Receiver: a TextMorphForEditView(381419520)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-i>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@18)
		owner: 	a TransformMorph(508559360)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@18)
		color: 	Color black
		extension: 	a MorphExtension (436207616) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'LOGame new'
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(570949632)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(Morph)>>handleFocusEvent:
	Receiver: a TextMorphForEditView(381419520)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-i>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@18)
		owner: 	a TransformMorph(508559360)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@18)
		color: 	Color black
		extension: 	a MorphExtension (436207616) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'LOGame new'
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(570949632)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-i>']
		focusHolder: 	a TextMorphForEditView(381419520)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(488@531.0) corner: (504@547.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a TextMorphForEditView(381419520)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(488@531) mouseOver nil nil]
		targetOffset: 	(162.0@36.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 817460 488 531 0 0 0 1)
		lastKeyScanCode: 	34
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	8


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0



--- The full stack ---
LOGame(Object)>>doesNotUnderstand: #cellsPerSide
LOGame>>initialize
LOGame class(Behavior)>>new
UndefinedObject>>DoIt
OpalCompiler>>evaluate
SmalltalkEditor>>evaluateSelectionAndDo:
[ textMorph editor evaluateSelectionAndDo: [ :result | result inspect ] ] in PluggableTextMorph>>inspectIt
[ result := editBlock value ] in PluggableTextMorph>>handleEdit:
TextMorphForEditView(TextMorph)>>handleEdit:
PluggableTextMorph>>handleEdit:
PluggableTextMorph>>inspectIt
[ :morph | morph inspectIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
TextMorphForEditView(TextMorph)>>handleKeystroke:
KeyboardEvent>>sentTo:
TextMorphForEditView(Morph)>>handleEvent:
TextMorphForEditView(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: LOGame>>cellsPerSide
16 October 2014 4:12:35.563799 pm

VM: Mac OS - intel - 1090 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30858]

LOGame(Object)>>doesNotUnderstand: #cellsPerSide
	Receiver: a LOGame(1052770304)
	Arguments and temporary variables: 
		aMessage: 	cellsPerSide
		exception: 	MessageNotUnderstood: LOGame>>cellsPerSide
		resumeValue: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (50@40)
		owner: 	nil
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	nil
		borderWidth: 	2
		borderColor: 	Color black
		cells: 	nil


Message>>sentTo:
	Receiver: cellsPerSide
	Arguments and temporary variables: 
		receiver: 	a LOGame(1052770304)
	Receiver's instance variables: 
		selector: 	#cellsPerSide
		args: 	#()
		lookupClass: 	LOGame


LOGame(Object)>>doesNotUnderstand: #cellsPerSide
	Receiver: a LOGame(1052770304)
	Arguments and temporary variables: 
		aMessage: 	cellsPerSide
		exception: 	MessageNotUnderstood: LOGame>>cellsPerSide
		resumeValue: 	MessageNotUnderstood: LOGame>>cellsPerSide
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (50@40)
		owner: 	nil
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	nil
		borderWidth: 	2
		borderColor: 	Color black
		cells: 	nil


LOGame>>initialize
	Receiver: a LOGame(1052770304)
	Arguments and temporary variables: 
		sampleCell: 	nil
		width: 	nil
		height: 	nil
		n: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (50@40)
		owner: 	nil
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	nil
		borderWidth: 	2
		borderColor: 	Color black
		cells: 	nil


LOGame class(Behavior)>>new
	Receiver: LOGame
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	BorderedMorph
		methodDict: 	a MethodDictionary(#initialize->LOGame>>#initialize )
		format: 	148
		layout: 	a FixedLayout
		instanceVariables: 	#(#cells)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#LOGame
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'PBE-LightsOut'
		traitComposition: 	{}
		localSelectors: 	nil
		announcer: 	nil


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'LOGame new'
		itsSelection: 	a Text for 'LOGame new'
		itsSelectionString: 	'LOGame new'
	Receiver's instance variables: 
		ast: 	DoIt
	^ LOGame new
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


SmalltalkEditor>>evaluateSelectionAndDo:
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | result inspect ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(381419520)
		selectionShowing: 	true
		model: 	a Workspace
		editingState: 	a SmalltalkEditingState


[ textMorph editor evaluateSelectionAndDo: [ :result | result inspect ] ] in PluggableTextMorph>>inspectIt
	Receiver: a PluggableTextMorph(570949632)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(488.0@523.0) corner: (928.0@690.0)
		owner: 	a SystemWindow(481034240)
		submorphs: 	an Array(a TransformMorph(508559360))
		fullBounds: 	(488@523) corner: (928@690)
		color: 	Color white
		extension: 	a MorphExtension (360185856) [locked]  [other:  (kmDispatcher -> a K...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(610795520)
		scroller: 	a TransformMorph(508559360)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(526123008)
		textMorph: 	a TextMorphForEditView(381419520)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 10)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


[ result := editBlock value ] in PluggableTextMorph>>handleEdit:
	Receiver: a PluggableTextMorph(570949632)
	Arguments and temporary variables: 
		editBlock: 	[ textMorph editor evaluateSelectionAndDo: [ :result | result inspec...etc...
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(488.0@523.0) corner: (928.0@690.0)
		owner: 	a SystemWindow(481034240)
		submorphs: 	an Array(a TransformMorph(508559360))
		fullBounds: 	(488@523) corner: (928@690)
		color: 	Color white
		extension: 	a MorphExtension (360185856) [locked]  [other:  (kmDispatcher -> a K...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(610795520)
		scroller: 	a TransformMorph(508559360)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(526123008)
		textMorph: 	a TextMorphForEditView(381419520)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 10)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


TextMorphForEditView(TextMorph)>>handleEdit:
	Receiver: a TextMorphForEditView(381419520)
	Arguments and temporary variables: 
		editBlock: 	[ result := editBlock value ]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@18)
		owner: 	a TransformMorph(508559360)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@18)
		color: 	Color black
		extension: 	a MorphExtension (436207616) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'LOGame new'
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(570949632)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


PluggableTextMorph>>handleEdit:
	Receiver: a PluggableTextMorph(570949632)
	Arguments and temporary variables: 
		result: 	nil
		editBlock: 	[ textMorph editor evaluateSelectionAndDo: [ :result | result inspec...etc...
	Receiver's instance variables: 
		bounds: 	(488.0@523.0) corner: (928.0@690.0)
		owner: 	a SystemWindow(481034240)
		submorphs: 	an Array(a TransformMorph(508559360))
		fullBounds: 	(488@523) corner: (928@690)
		color: 	Color white
		extension: 	a MorphExtension (360185856) [locked]  [other:  (kmDispatcher -> a K...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(610795520)
		scroller: 	a TransformMorph(508559360)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(526123008)
		textMorph: 	a TextMorphForEditView(381419520)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 10)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


PluggableTextMorph>>inspectIt
	Receiver: a PluggableTextMorph(570949632)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(488.0@523.0) corner: (928.0@690.0)
		owner: 	a SystemWindow(481034240)
		submorphs: 	an Array(a TransformMorph(508559360))
		fullBounds: 	(488@523) corner: (928@690)
		color: 	Color white
		extension: 	a MorphExtension (360185856) [locked]  [other:  (kmDispatcher -> a K...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(610795520)
		scroller: 	a TransformMorph(508559360)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(526123008)
		textMorph: 	a TextMorphForEditView(381419520)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 10)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


[ :morph | morph inspectIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
	Receiver: SmalltalkEditor
	Arguments and temporary variables: 
		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a PluggableTextMorph(570949632)
	Receiver's instance variables: 
		superclass: 	TextEditor
		methodDict: 	a MethodDictionary(#argAdvance:->SmalltalkEditor>>#argAdvance: #bro...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SmalltalkEditor
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Text-Edition'
		traitComposition: 	{}
		localSelectors: 	nil
		cmdActions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop...etc...
		shiftCmdActions: 	#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #m...etc...


BlockClosure>>cull:
	Receiver: [ :morph | morph inspectIt ]
	Arguments and temporary variables: 
		anArg: 	a PluggableTextMorph(570949632)
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	182
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :morph | morph inspectIt ]
	Arguments and temporary variables: 
		firstArg: 	a PluggableTextMorph(570949632)
		secondArg: 	a PluggableTextMorph(570949632)
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	182
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :morph | morph inspectIt ]
	Arguments and temporary variables: 
		firstArg: 	a PluggableTextMorph(570949632)
		secondArg: 	a PluggableTextMorph(570949632)
		thirdArg: 	[keystroke '<Cmd-i>']
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	182
		numArgs: 	1


KMCategoryBinding>>completeMatch:buffer:
	Receiver: aKMCategoryTarget(#SmalltalkEditor)
	Arguments and temporary variables: 
		aKeymap: 	#inspectIt on Cmd + I do [ :morph | morph inspectIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
	Receiver's instance variables: 
		target: 	a PluggableTextMorph(570949632)
		category: 	a KMCategory
		morph: 	a PluggableTextMorph(570949632)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #inspectIt on Cmd + I do [ :morph | morph inspectIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		l: 	aKMCategoryTarget(#SmalltalkEditor)
	Receiver's instance variables: 
		action: 	[ :morph | morph inspectIt ]
		name: 	#inspectIt
		shortcut: 	Cmd + I
		defaultShortcut: 	Cmd + I
		description: 	''


Array(SequenceableCollection)>>do:
	Receiver: an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #inspectIt on Cmd + I do [ :morph | morph inspectIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ :morph | morph inspectIt ]
		name: 	#inspectIt
		shortcut: 	Cmd + I
		defaultShortcut: 	Cmd + I
		description: 	''


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: #inspectIt on Cmd + I do [ :morph | morph inspectIt ]

	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		action: 	[ :morph | morph inspectIt ]
		name: 	#inspectIt
		shortcut: 	Cmd + I
		defaultShortcut: 	Cmd + I
		description: 	''


[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#inspectIt on Cmd + I do [ :morph | morph inspectIt ]

	Receiver's instance variables: 
		name: 	#SmalltalkEditor
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


Set>>do:
	Receiver: a Set(#printIt on Cmd + P do [ :morph | morph printIt ]
 #previousSelection on Cmd + Shift...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	13
		each: 	#inspectIt on Cmd + I do [ :morph | morph inspectIt ]

	Receiver's instance variables: 
		tally: 	14
		array: 	an Array(#printIt on Cmd + P do [ :morph | morph printIt ]
 #previousSel...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
	Receiver's instance variables: 
		name: 	#SmalltalkEditor
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: aKMCategoryTarget(#SmalltalkEditor)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		target: 	a PluggableTextMorph(570949632)
		category: 	a KMCategory
		morph: 	a PluggableTextMorph(570949632)


[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#SmalltalkEditor)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#SmalltalkEditor) aKMCategoryTarget(#TextMorph...etc...
		morph: 	a PluggableTextMorph(570949632)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#SmalltalkEditor) aKMCategor...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	2
	Receiver's instance variables: 
		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#SmalltalkEditor) aKMC...etc...
		firstIndex: 	1
		lastIndex: 	7


KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		association: 	nil
		match: 	nil
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#SmalltalkEditor) aKMCategoryTarget(#TextMorph...etc...
		morph: 	a PluggableTextMorph(570949632)
		directKeymaps: 	a KMCategory


KMTarget>>dispatch:
	Receiver: a KMTarget
	Arguments and temporary variables: 
		buffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
	Receiver's instance variables: 
		realTarget: 	nil
		morph: 	a PluggableTextMorph(570949632)
		targetSelector: 	#yourself
		directKeymaps: 	nil
		perInstanceCategories: 	nil


[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Cmd-i>']
		targetToDispatch: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>do:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Cmd-i>']
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatcher>>dispatchKeystroke:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		aKeyEvent: 	[keystroke '<Cmd-i>']
		chain: 	a KMDispatchChain
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#MorphFocusCtrlN...etc...
		morph: 	a TextMorphForEditView(381419520)
		directKeymaps: 	a KMCategory


TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
	Receiver: a TextMorphForEditView(381419520)
	Arguments and temporary variables: 
		evt: 	[keystroke '<Cmd-i>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@18)
		owner: 	a TransformMorph(508559360)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@18)
		color: 	Color black
		extension: 	a MorphExtension (436207616) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'LOGame new'
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(570949632)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(TextMorph)>>handleKeystroke:
	Receiver: a TextMorphForEditView(381419520)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-i>']
		pasteUp: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@18)
		owner: 	a TransformMorph(508559360)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@18)
		color: 	Color black
		extension: 	a MorphExtension (436207616) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'LOGame new'
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(570949632)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


KeyboardEvent>>sentTo:
	Receiver: [keystroke '<Cmd-i>']
	Arguments and temporary variables: 
		anObject: 	a TextMorphForEditView(381419520)
	Receiver's instance variables: 
		timeStamp: 	820572
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#keystroke
		buttons: 	64
		position: 	(-4.0@7.0)
		handler: 	nil
		wasHandled: 	true
		keyValue: 	105
		charCode: 	105
		scanCode: 	34


TextMorphForEditView(Morph)>>handleEvent:
	Receiver: a TextMorphForEditView(381419520)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-i>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@18)
		owner: 	a TransformMorph(508559360)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@18)
		color: 	Color black
		extension: 	a MorphExtension (436207616) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'LOGame new'
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(570949632)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(Morph)>>handleFocusEvent:
	Receiver: a TextMorphForEditView(381419520)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-i>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@18)
		owner: 	a TransformMorph(508559360)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@18)
		color: 	Color black
		extension: 	a MorphExtension (436207616) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'LOGame new'
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(570949632)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil



--- The full stack ---
LOGame(Object)>>doesNotUnderstand: #cellsPerSide
Message>>sentTo:
LOGame(Object)>>doesNotUnderstand: #cellsPerSide
LOGame>>initialize
LOGame class(Behavior)>>new
UndefinedObject>>DoIt
OpalCompiler>>evaluate
SmalltalkEditor>>evaluateSelectionAndDo:
[ textMorph editor evaluateSelectionAndDo: [ :result | result inspect ] ] in PluggableTextMorph>>inspectIt
[ result := editBlock value ] in PluggableTextMorph>>handleEdit:
TextMorphForEditView(TextMorph)>>handleEdit:
PluggableTextMorph>>handleEdit:
PluggableTextMorph>>inspectIt
[ :morph | morph inspectIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
TextMorphForEditView(TextMorph)>>handleKeystroke:
KeyboardEvent>>sentTo:
TextMorphForEditView(Morph)>>handleEvent:
TextMorphForEditView(Morph)>>handleFocusEvent:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: LOGame>>cellsPerSide
16 October 2014 4:12:36.993405 pm

VM: Mac OS - intel - 1090 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30858]

LOGame(Object)>>doesNotUnderstand: #cellsPerSide
	Receiver: a LOGame(1052770304)
	Arguments and temporary variables: 
		aMessage: 	cellsPerSide
		exception: 	MessageNotUnderstood: LOGame>>cellsPerSide
		resumeValue: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (50@40)
		owner: 	nil
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	nil
		borderWidth: 	2
		borderColor: 	Color black
		cells: 	nil


Message>>sentTo:
	Receiver: cellsPerSide
	Arguments and temporary variables: 
		receiver: 	a LOGame(1052770304)
	Receiver's instance variables: 
		selector: 	#cellsPerSide
		args: 	#()
		lookupClass: 	LOGame


LOGame(Object)>>doesNotUnderstand: #cellsPerSide
	Receiver: a LOGame(1052770304)
	Arguments and temporary variables: 
		aMessage: 	cellsPerSide
		exception: 	MessageNotUnderstood: LOGame>>cellsPerSide
		resumeValue: 	MessageNotUnderstood: LOGame>>cellsPerSide
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (50@40)
		owner: 	nil
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	nil
		borderWidth: 	2
		borderColor: 	Color black
		cells: 	nil


Message>>sentTo:
	Receiver: cellsPerSide
	Arguments and temporary variables: 
		receiver: 	a LOGame(1052770304)
	Receiver's instance variables: 
		selector: 	#cellsPerSide
		args: 	#()
		lookupClass: 	LOGame


LOGame(Object)>>doesNotUnderstand: #cellsPerSide
	Receiver: a LOGame(1052770304)
	Arguments and temporary variables: 
		aMessage: 	cellsPerSide
		exception: 	MessageNotUnderstood: LOGame>>cellsPerSide
		resumeValue: 	MessageNotUnderstood: LOGame>>cellsPerSide
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (50@40)
		owner: 	nil
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	nil
		borderWidth: 	2
		borderColor: 	Color black
		cells: 	nil


LOGame>>initialize
	Receiver: a LOGame(1052770304)
	Arguments and temporary variables: 
		sampleCell: 	nil
		width: 	nil
		height: 	nil
		n: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (50@40)
		owner: 	nil
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	nil
		borderWidth: 	2
		borderColor: 	Color black
		cells: 	nil


LOGame class(Behavior)>>new
	Receiver: LOGame
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	BorderedMorph
		methodDict: 	a MethodDictionary(#initialize->LOGame>>#initialize )
		format: 	148
		layout: 	a FixedLayout
		instanceVariables: 	#(#cells)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#LOGame
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'PBE-LightsOut'
		traitComposition: 	{}
		localSelectors: 	nil
		announcer: 	nil


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'LOGame new'
		itsSelection: 	a Text for 'LOGame new'
		itsSelectionString: 	'LOGame new'
	Receiver's instance variables: 
		ast: 	DoIt
	^ LOGame new
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


SmalltalkEditor>>evaluateSelectionAndDo:
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | result inspect ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(381419520)
		selectionShowing: 	true
		model: 	a Workspace
		editingState: 	a SmalltalkEditingState


[ textMorph editor evaluateSelectionAndDo: [ :result | result inspect ] ] in PluggableTextMorph>>inspectIt
	Receiver: a PluggableTextMorph(570949632)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(488.0@523.0) corner: (928.0@690.0)
		owner: 	a SystemWindow(481034240)
		submorphs: 	an Array(a TransformMorph(508559360))
		fullBounds: 	(488@523) corner: (928@690)
		color: 	Color white
		extension: 	a MorphExtension (360185856) [locked]  [other:  (kmDispatcher -> a K...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(610795520)
		scroller: 	a TransformMorph(508559360)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(526123008)
		textMorph: 	a TextMorphForEditView(381419520)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 10)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


[ result := editBlock value ] in PluggableTextMorph>>handleEdit:
	Receiver: a PluggableTextMorph(570949632)
	Arguments and temporary variables: 
		editBlock: 	[ textMorph editor evaluateSelectionAndDo: [ :result | result inspec...etc...
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(488.0@523.0) corner: (928.0@690.0)
		owner: 	a SystemWindow(481034240)
		submorphs: 	an Array(a TransformMorph(508559360))
		fullBounds: 	(488@523) corner: (928@690)
		color: 	Color white
		extension: 	a MorphExtension (360185856) [locked]  [other:  (kmDispatcher -> a K...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(610795520)
		scroller: 	a TransformMorph(508559360)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(526123008)
		textMorph: 	a TextMorphForEditView(381419520)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 10)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


TextMorphForEditView(TextMorph)>>handleEdit:
	Receiver: a TextMorphForEditView(381419520)
	Arguments and temporary variables: 
		editBlock: 	[ result := editBlock value ]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@18)
		owner: 	a TransformMorph(508559360)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@18)
		color: 	Color black
		extension: 	a MorphExtension (436207616) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'LOGame new'
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(570949632)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


PluggableTextMorph>>handleEdit:
	Receiver: a PluggableTextMorph(570949632)
	Arguments and temporary variables: 
		result: 	nil
		editBlock: 	[ textMorph editor evaluateSelectionAndDo: [ :result | result inspec...etc...
	Receiver's instance variables: 
		bounds: 	(488.0@523.0) corner: (928.0@690.0)
		owner: 	a SystemWindow(481034240)
		submorphs: 	an Array(a TransformMorph(508559360))
		fullBounds: 	(488@523) corner: (928@690)
		color: 	Color white
		extension: 	a MorphExtension (360185856) [locked]  [other:  (kmDispatcher -> a K...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(610795520)
		scroller: 	a TransformMorph(508559360)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(526123008)
		textMorph: 	a TextMorphForEditView(381419520)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 10)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


PluggableTextMorph>>inspectIt
	Receiver: a PluggableTextMorph(570949632)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(488.0@523.0) corner: (928.0@690.0)
		owner: 	a SystemWindow(481034240)
		submorphs: 	an Array(a TransformMorph(508559360))
		fullBounds: 	(488@523) corner: (928@690)
		color: 	Color white
		extension: 	a MorphExtension (360185856) [locked]  [other:  (kmDispatcher -> a K...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(610795520)
		scroller: 	a TransformMorph(508559360)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(526123008)
		textMorph: 	a TextMorphForEditView(381419520)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 10)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


[ :morph | morph inspectIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
	Receiver: SmalltalkEditor
	Arguments and temporary variables: 
		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a PluggableTextMorph(570949632)
	Receiver's instance variables: 
		superclass: 	TextEditor
		methodDict: 	a MethodDictionary(#argAdvance:->SmalltalkEditor>>#argAdvance: #bro...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SmalltalkEditor
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Text-Edition'
		traitComposition: 	{}
		localSelectors: 	nil
		cmdActions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop...etc...
		shiftCmdActions: 	#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #m...etc...


BlockClosure>>cull:
	Receiver: [ :morph | morph inspectIt ]
	Arguments and temporary variables: 
		anArg: 	a PluggableTextMorph(570949632)
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	182
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :morph | morph inspectIt ]
	Arguments and temporary variables: 
		firstArg: 	a PluggableTextMorph(570949632)
		secondArg: 	a PluggableTextMorph(570949632)
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	182
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :morph | morph inspectIt ]
	Arguments and temporary variables: 
		firstArg: 	a PluggableTextMorph(570949632)
		secondArg: 	a PluggableTextMorph(570949632)
		thirdArg: 	[keystroke '<Cmd-i>']
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	182
		numArgs: 	1


KMCategoryBinding>>completeMatch:buffer:
	Receiver: aKMCategoryTarget(#SmalltalkEditor)
	Arguments and temporary variables: 
		aKeymap: 	#inspectIt on Cmd + I do [ :morph | morph inspectIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
	Receiver's instance variables: 
		target: 	a PluggableTextMorph(570949632)
		category: 	a KMCategory
		morph: 	a PluggableTextMorph(570949632)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #inspectIt on Cmd + I do [ :morph | morph inspectIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		l: 	aKMCategoryTarget(#SmalltalkEditor)
	Receiver's instance variables: 
		action: 	[ :morph | morph inspectIt ]
		name: 	#inspectIt
		shortcut: 	Cmd + I
		defaultShortcut: 	Cmd + I
		description: 	''


Array(SequenceableCollection)>>do:
	Receiver: an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #inspectIt on Cmd + I do [ :morph | morph inspectIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ :morph | morph inspectIt ]
		name: 	#inspectIt
		shortcut: 	Cmd + I
		defaultShortcut: 	Cmd + I
		description: 	''


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: #inspectIt on Cmd + I do [ :morph | morph inspectIt ]

	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		action: 	[ :morph | morph inspectIt ]
		name: 	#inspectIt
		shortcut: 	Cmd + I
		defaultShortcut: 	Cmd + I
		description: 	''


[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#inspectIt on Cmd + I do [ :morph | morph inspectIt ]

	Receiver's instance variables: 
		name: 	#SmalltalkEditor
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


Set>>do:
	Receiver: a Set(#printIt on Cmd + P do [ :morph | morph printIt ]
 #previousSelection on Cmd + Shift...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	13
		each: 	#inspectIt on Cmd + I do [ :morph | morph inspectIt ]

	Receiver's instance variables: 
		tally: 	14
		array: 	an Array(#printIt on Cmd + P do [ :morph | morph printIt ]
 #previousSel...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
	Receiver's instance variables: 
		name: 	#SmalltalkEditor
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: aKMCategoryTarget(#SmalltalkEditor)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		target: 	a PluggableTextMorph(570949632)
		category: 	a KMCategory
		morph: 	a PluggableTextMorph(570949632)


[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#SmalltalkEditor)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#SmalltalkEditor) aKMCategoryTarget(#TextMorph...etc...
		morph: 	a PluggableTextMorph(570949632)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#SmalltalkEditor) aKMCategor...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	2
	Receiver's instance variables: 
		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#SmalltalkEditor) aKMC...etc...
		firstIndex: 	1
		lastIndex: 	7


KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		association: 	nil
		match: 	nil
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#SmalltalkEditor) aKMCategoryTarget(#TextMorph...etc...
		morph: 	a PluggableTextMorph(570949632)
		directKeymaps: 	a KMCategory


KMTarget>>dispatch:
	Receiver: a KMTarget
	Arguments and temporary variables: 
		buffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
	Receiver's instance variables: 
		realTarget: 	nil
		morph: 	a PluggableTextMorph(570949632)
		targetSelector: 	#yourself
		directKeymaps: 	nil
		perInstanceCategories: 	nil


[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Cmd-i>']
		targetToDispatch: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>do:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Cmd-i>']
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatcher>>dispatchKeystroke:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		aKeyEvent: 	[keystroke '<Cmd-i>']
		chain: 	a KMDispatchChain
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#MorphFocusCtrlN...etc...
		morph: 	a TextMorphForEditView(381419520)
		directKeymaps: 	a KMCategory


TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
	Receiver: a TextMorphForEditView(381419520)
	Arguments and temporary variables: 
		evt: 	[keystroke '<Cmd-i>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@18)
		owner: 	a TransformMorph(508559360)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@18)
		color: 	Color black
		extension: 	a MorphExtension (436207616) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'LOGame new'
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(570949632)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(TextMorph)>>handleKeystroke:
	Receiver: a TextMorphForEditView(381419520)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-i>']
		pasteUp: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@18)
		owner: 	a TransformMorph(508559360)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@18)
		color: 	Color black
		extension: 	a MorphExtension (436207616) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'LOGame new'
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(570949632)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


KeyboardEvent>>sentTo:
	Receiver: [keystroke '<Cmd-i>']
	Arguments and temporary variables: 
		anObject: 	a TextMorphForEditView(381419520)
	Receiver's instance variables: 
		timeStamp: 	820572
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#keystroke
		buttons: 	64
		position: 	(-4.0@7.0)
		handler: 	nil
		wasHandled: 	true
		keyValue: 	105
		charCode: 	105
		scanCode: 	34



--- The full stack ---
LOGame(Object)>>doesNotUnderstand: #cellsPerSide
Message>>sentTo:
LOGame(Object)>>doesNotUnderstand: #cellsPerSide
Message>>sentTo:
LOGame(Object)>>doesNotUnderstand: #cellsPerSide
LOGame>>initialize
LOGame class(Behavior)>>new
UndefinedObject>>DoIt
OpalCompiler>>evaluate
SmalltalkEditor>>evaluateSelectionAndDo:
[ textMorph editor evaluateSelectionAndDo: [ :result | result inspect ] ] in PluggableTextMorph>>inspectIt
[ result := editBlock value ] in PluggableTextMorph>>handleEdit:
TextMorphForEditView(TextMorph)>>handleEdit:
PluggableTextMorph>>handleEdit:
PluggableTextMorph>>inspectIt
[ :morph | morph inspectIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
TextMorphForEditView(TextMorph)>>handleKeystroke:
KeyboardEvent>>sentTo:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
TextMorphForEditView(Morph)>>handleEvent:
TextMorphForEditView(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: LOGame>>cellsPerSide
16 October 2014 4:12:38.393787 pm

VM: Mac OS - intel - 1090 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30858]

LOGame(Object)>>doesNotUnderstand: #cellsPerSide
	Receiver: a LOGame(1052770304)
	Arguments and temporary variables: 
		aMessage: 	cellsPerSide
		exception: 	MessageNotUnderstood: LOGame>>cellsPerSide
		resumeValue: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (50@40)
		owner: 	nil
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	nil
		borderWidth: 	2
		borderColor: 	Color black
		cells: 	nil


Message>>sentTo:
	Receiver: cellsPerSide
	Arguments and temporary variables: 
		receiver: 	a LOGame(1052770304)
	Receiver's instance variables: 
		selector: 	#cellsPerSide
		args: 	#()
		lookupClass: 	LOGame


LOGame(Object)>>doesNotUnderstand: #cellsPerSide
	Receiver: a LOGame(1052770304)
	Arguments and temporary variables: 
		aMessage: 	cellsPerSide
		exception: 	MessageNotUnderstood: LOGame>>cellsPerSide
		resumeValue: 	MessageNotUnderstood: LOGame>>cellsPerSide
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (50@40)
		owner: 	nil
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	nil
		borderWidth: 	2
		borderColor: 	Color black
		cells: 	nil


Message>>sentTo:
	Receiver: cellsPerSide
	Arguments and temporary variables: 
		receiver: 	a LOGame(1052770304)
	Receiver's instance variables: 
		selector: 	#cellsPerSide
		args: 	#()
		lookupClass: 	LOGame


LOGame(Object)>>doesNotUnderstand: #cellsPerSide
	Receiver: a LOGame(1052770304)
	Arguments and temporary variables: 
		aMessage: 	cellsPerSide
		exception: 	MessageNotUnderstood: LOGame>>cellsPerSide
		resumeValue: 	MessageNotUnderstood: LOGame>>cellsPerSide
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (50@40)
		owner: 	nil
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	nil
		borderWidth: 	2
		borderColor: 	Color black
		cells: 	nil


Message>>sentTo:
	Receiver: cellsPerSide
	Arguments and temporary variables: 
		receiver: 	a LOGame(1052770304)
	Receiver's instance variables: 
		selector: 	#cellsPerSide
		args: 	#()
		lookupClass: 	LOGame


LOGame(Object)>>doesNotUnderstand: #cellsPerSide
	Receiver: a LOGame(1052770304)
	Arguments and temporary variables: 
		aMessage: 	cellsPerSide
		exception: 	MessageNotUnderstood: LOGame>>cellsPerSide
		resumeValue: 	MessageNotUnderstood: LOGame>>cellsPerSide
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (50@40)
		owner: 	nil
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	nil
		borderWidth: 	2
		borderColor: 	Color black
		cells: 	nil


LOGame>>initialize
	Receiver: a LOGame(1052770304)
	Arguments and temporary variables: 
		sampleCell: 	nil
		width: 	nil
		height: 	nil
		n: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (50@40)
		owner: 	nil
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	nil
		borderWidth: 	2
		borderColor: 	Color black
		cells: 	nil


LOGame class(Behavior)>>new
	Receiver: LOGame
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	BorderedMorph
		methodDict: 	a MethodDictionary(#initialize->LOGame>>#initialize )
		format: 	148
		layout: 	a FixedLayout
		instanceVariables: 	#(#cells)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#LOGame
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'PBE-LightsOut'
		traitComposition: 	{}
		localSelectors: 	nil
		announcer: 	nil


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'LOGame new'
		itsSelection: 	a Text for 'LOGame new'
		itsSelectionString: 	'LOGame new'
	Receiver's instance variables: 
		ast: 	DoIt
	^ LOGame new
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


SmalltalkEditor>>evaluateSelectionAndDo:
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | result inspect ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(381419520)
		selectionShowing: 	true
		model: 	a Workspace
		editingState: 	a SmalltalkEditingState


[ textMorph editor evaluateSelectionAndDo: [ :result | result inspect ] ] in PluggableTextMorph>>inspectIt
	Receiver: a PluggableTextMorph(570949632)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(488.0@523.0) corner: (928.0@690.0)
		owner: 	a SystemWindow(481034240)
		submorphs: 	an Array(a TransformMorph(508559360))
		fullBounds: 	(488@523) corner: (928@690)
		color: 	Color white
		extension: 	a MorphExtension (360185856) [locked]  [other:  (kmDispatcher -> a K...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(610795520)
		scroller: 	a TransformMorph(508559360)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(526123008)
		textMorph: 	a TextMorphForEditView(381419520)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 10)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


[ result := editBlock value ] in PluggableTextMorph>>handleEdit:
	Receiver: a PluggableTextMorph(570949632)
	Arguments and temporary variables: 
		editBlock: 	[ textMorph editor evaluateSelectionAndDo: [ :result | result inspec...etc...
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(488.0@523.0) corner: (928.0@690.0)
		owner: 	a SystemWindow(481034240)
		submorphs: 	an Array(a TransformMorph(508559360))
		fullBounds: 	(488@523) corner: (928@690)
		color: 	Color white
		extension: 	a MorphExtension (360185856) [locked]  [other:  (kmDispatcher -> a K...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(610795520)
		scroller: 	a TransformMorph(508559360)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(526123008)
		textMorph: 	a TextMorphForEditView(381419520)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 10)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


TextMorphForEditView(TextMorph)>>handleEdit:
	Receiver: a TextMorphForEditView(381419520)
	Arguments and temporary variables: 
		editBlock: 	[ result := editBlock value ]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@18)
		owner: 	a TransformMorph(508559360)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@18)
		color: 	Color black
		extension: 	a MorphExtension (436207616) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'LOGame new'
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(570949632)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


PluggableTextMorph>>handleEdit:
	Receiver: a PluggableTextMorph(570949632)
	Arguments and temporary variables: 
		result: 	nil
		editBlock: 	[ textMorph editor evaluateSelectionAndDo: [ :result | result inspec...etc...
	Receiver's instance variables: 
		bounds: 	(488.0@523.0) corner: (928.0@690.0)
		owner: 	a SystemWindow(481034240)
		submorphs: 	an Array(a TransformMorph(508559360))
		fullBounds: 	(488@523) corner: (928@690)
		color: 	Color white
		extension: 	a MorphExtension (360185856) [locked]  [other:  (kmDispatcher -> a K...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(610795520)
		scroller: 	a TransformMorph(508559360)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(526123008)
		textMorph: 	a TextMorphForEditView(381419520)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 10)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


PluggableTextMorph>>inspectIt
	Receiver: a PluggableTextMorph(570949632)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(488.0@523.0) corner: (928.0@690.0)
		owner: 	a SystemWindow(481034240)
		submorphs: 	an Array(a TransformMorph(508559360))
		fullBounds: 	(488@523) corner: (928@690)
		color: 	Color white
		extension: 	a MorphExtension (360185856) [locked]  [other:  (kmDispatcher -> a K...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(610795520)
		scroller: 	a TransformMorph(508559360)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(526123008)
		textMorph: 	a TextMorphForEditView(381419520)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 10)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


[ :morph | morph inspectIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
	Receiver: SmalltalkEditor
	Arguments and temporary variables: 
		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a PluggableTextMorph(570949632)
	Receiver's instance variables: 
		superclass: 	TextEditor
		methodDict: 	a MethodDictionary(#argAdvance:->SmalltalkEditor>>#argAdvance: #bro...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SmalltalkEditor
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Text-Edition'
		traitComposition: 	{}
		localSelectors: 	nil
		cmdActions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop...etc...
		shiftCmdActions: 	#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #m...etc...


BlockClosure>>cull:
	Receiver: [ :morph | morph inspectIt ]
	Arguments and temporary variables: 
		anArg: 	a PluggableTextMorph(570949632)
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	182
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :morph | morph inspectIt ]
	Arguments and temporary variables: 
		firstArg: 	a PluggableTextMorph(570949632)
		secondArg: 	a PluggableTextMorph(570949632)
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	182
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :morph | morph inspectIt ]
	Arguments and temporary variables: 
		firstArg: 	a PluggableTextMorph(570949632)
		secondArg: 	a PluggableTextMorph(570949632)
		thirdArg: 	[keystroke '<Cmd-i>']
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	182
		numArgs: 	1


KMCategoryBinding>>completeMatch:buffer:
	Receiver: aKMCategoryTarget(#SmalltalkEditor)
	Arguments and temporary variables: 
		aKeymap: 	#inspectIt on Cmd + I do [ :morph | morph inspectIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
	Receiver's instance variables: 
		target: 	a PluggableTextMorph(570949632)
		category: 	a KMCategory
		morph: 	a PluggableTextMorph(570949632)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #inspectIt on Cmd + I do [ :morph | morph inspectIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		l: 	aKMCategoryTarget(#SmalltalkEditor)
	Receiver's instance variables: 
		action: 	[ :morph | morph inspectIt ]
		name: 	#inspectIt
		shortcut: 	Cmd + I
		defaultShortcut: 	Cmd + I
		description: 	''


Array(SequenceableCollection)>>do:
	Receiver: an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #inspectIt on Cmd + I do [ :morph | morph inspectIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ :morph | morph inspectIt ]
		name: 	#inspectIt
		shortcut: 	Cmd + I
		defaultShortcut: 	Cmd + I
		description: 	''


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: #inspectIt on Cmd + I do [ :morph | morph inspectIt ]

	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		action: 	[ :morph | morph inspectIt ]
		name: 	#inspectIt
		shortcut: 	Cmd + I
		defaultShortcut: 	Cmd + I
		description: 	''


[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#inspectIt on Cmd + I do [ :morph | morph inspectIt ]

	Receiver's instance variables: 
		name: 	#SmalltalkEditor
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


Set>>do:
	Receiver: a Set(#printIt on Cmd + P do [ :morph | morph printIt ]
 #previousSelection on Cmd + Shift...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	13
		each: 	#inspectIt on Cmd + I do [ :morph | morph inspectIt ]

	Receiver's instance variables: 
		tally: 	14
		array: 	an Array(#printIt on Cmd + P do [ :morph | morph printIt ]
 #previousSel...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
	Receiver's instance variables: 
		name: 	#SmalltalkEditor
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: aKMCategoryTarget(#SmalltalkEditor)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		target: 	a PluggableTextMorph(570949632)
		category: 	a KMCategory
		morph: 	a PluggableTextMorph(570949632)


[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#SmalltalkEditor)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#SmalltalkEditor) aKMCategoryTarget(#TextMorph...etc...
		morph: 	a PluggableTextMorph(570949632)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#SmalltalkEditor) aKMCategor...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	2
	Receiver's instance variables: 
		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#SmalltalkEditor) aKMC...etc...
		firstIndex: 	1
		lastIndex: 	7


KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		association: 	nil
		match: 	nil
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#SmalltalkEditor) aKMCategoryTarget(#TextMorph...etc...
		morph: 	a PluggableTextMorph(570949632)
		directKeymaps: 	a KMCategory


KMTarget>>dispatch:
	Receiver: a KMTarget
	Arguments and temporary variables: 
		buffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
	Receiver's instance variables: 
		realTarget: 	nil
		morph: 	a PluggableTextMorph(570949632)
		targetSelector: 	#yourself
		directKeymaps: 	nil
		perInstanceCategories: 	nil


[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Cmd-i>']
		targetToDispatch: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>do:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Cmd-i>']
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatcher>>dispatchKeystroke:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		aKeyEvent: 	[keystroke '<Cmd-i>']
		chain: 	a KMDispatchChain
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#MorphFocusCtrlN...etc...
		morph: 	a TextMorphForEditView(381419520)
		directKeymaps: 	a KMCategory


TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
	Receiver: a TextMorphForEditView(381419520)
	Arguments and temporary variables: 
		evt: 	[keystroke '<Cmd-i>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@18)
		owner: 	a TransformMorph(508559360)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@18)
		color: 	Color black
		extension: 	a MorphExtension (436207616) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'LOGame new'
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(570949632)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil



--- The full stack ---
LOGame(Object)>>doesNotUnderstand: #cellsPerSide
Message>>sentTo:
LOGame(Object)>>doesNotUnderstand: #cellsPerSide
Message>>sentTo:
LOGame(Object)>>doesNotUnderstand: #cellsPerSide
Message>>sentTo:
LOGame(Object)>>doesNotUnderstand: #cellsPerSide
LOGame>>initialize
LOGame class(Behavior)>>new
UndefinedObject>>DoIt
OpalCompiler>>evaluate
SmalltalkEditor>>evaluateSelectionAndDo:
[ textMorph editor evaluateSelectionAndDo: [ :result | result inspect ] ] in PluggableTextMorph>>inspectIt
[ result := editBlock value ] in PluggableTextMorph>>handleEdit:
TextMorphForEditView(TextMorph)>>handleEdit:
PluggableTextMorph>>handleEdit:
PluggableTextMorph>>inspectIt
[ :morph | morph inspectIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
TextMorphForEditView(TextMorph)>>handleKeystroke:
KeyboardEvent>>sentTo:
TextMorphForEditView(Morph)>>handleEvent:
TextMorphForEditView(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: LOGame>>cellsPerSide
16 October 2014 4:12:39.702702 pm

VM: Mac OS - intel - 1090 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30858]

LOGame(Object)>>doesNotUnderstand: #cellsPerSide
	Receiver: a LOGame(1052770304)
	Arguments and temporary variables: 
		aMessage: 	cellsPerSide
		exception: 	MessageNotUnderstood: LOGame>>cellsPerSide
		resumeValue: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (50@40)
		owner: 	nil
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	nil
		borderWidth: 	2
		borderColor: 	Color black
		cells: 	nil


Message>>sentTo:
	Receiver: cellsPerSide
	Arguments and temporary variables: 
		receiver: 	a LOGame(1052770304)
	Receiver's instance variables: 
		selector: 	#cellsPerSide
		args: 	#()
		lookupClass: 	LOGame


LOGame(Object)>>doesNotUnderstand: #cellsPerSide
	Receiver: a LOGame(1052770304)
	Arguments and temporary variables: 
		aMessage: 	cellsPerSide
		exception: 	MessageNotUnderstood: LOGame>>cellsPerSide
		resumeValue: 	MessageNotUnderstood: LOGame>>cellsPerSide
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (50@40)
		owner: 	nil
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	nil
		borderWidth: 	2
		borderColor: 	Color black
		cells: 	nil


Message>>sentTo:
	Receiver: cellsPerSide
	Arguments and temporary variables: 
		receiver: 	a LOGame(1052770304)
	Receiver's instance variables: 
		selector: 	#cellsPerSide
		args: 	#()
		lookupClass: 	LOGame


LOGame(Object)>>doesNotUnderstand: #cellsPerSide
	Receiver: a LOGame(1052770304)
	Arguments and temporary variables: 
		aMessage: 	cellsPerSide
		exception: 	MessageNotUnderstood: LOGame>>cellsPerSide
		resumeValue: 	MessageNotUnderstood: LOGame>>cellsPerSide
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (50@40)
		owner: 	nil
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	nil
		borderWidth: 	2
		borderColor: 	Color black
		cells: 	nil


Message>>sentTo:
	Receiver: cellsPerSide
	Arguments and temporary variables: 
		receiver: 	a LOGame(1052770304)
	Receiver's instance variables: 
		selector: 	#cellsPerSide
		args: 	#()
		lookupClass: 	LOGame


LOGame(Object)>>doesNotUnderstand: #cellsPerSide
	Receiver: a LOGame(1052770304)
	Arguments and temporary variables: 
		aMessage: 	cellsPerSide
		exception: 	MessageNotUnderstood: LOGame>>cellsPerSide
		resumeValue: 	MessageNotUnderstood: LOGame>>cellsPerSide
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (50@40)
		owner: 	nil
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	nil
		borderWidth: 	2
		borderColor: 	Color black
		cells: 	nil


Message>>sentTo:
	Receiver: cellsPerSide
	Arguments and temporary variables: 
		receiver: 	a LOGame(1052770304)
	Receiver's instance variables: 
		selector: 	#cellsPerSide
		args: 	#()
		lookupClass: 	LOGame


LOGame(Object)>>doesNotUnderstand: #cellsPerSide
	Receiver: a LOGame(1052770304)
	Arguments and temporary variables: 
		aMessage: 	cellsPerSide
		exception: 	MessageNotUnderstood: LOGame>>cellsPerSide
		resumeValue: 	MessageNotUnderstood: LOGame>>cellsPerSide
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (50@40)
		owner: 	nil
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	nil
		borderWidth: 	2
		borderColor: 	Color black
		cells: 	nil


LOGame>>initialize
	Receiver: a LOGame(1052770304)
	Arguments and temporary variables: 
		sampleCell: 	nil
		width: 	nil
		height: 	nil
		n: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (50@40)
		owner: 	nil
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	nil
		borderWidth: 	2
		borderColor: 	Color black
		cells: 	nil


LOGame class(Behavior)>>new
	Receiver: LOGame
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	BorderedMorph
		methodDict: 	a MethodDictionary(#initialize->LOGame>>#initialize )
		format: 	148
		layout: 	a FixedLayout
		instanceVariables: 	#(#cells)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#LOGame
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'PBE-LightsOut'
		traitComposition: 	{}
		localSelectors: 	nil
		announcer: 	nil


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'LOGame new'
		itsSelection: 	a Text for 'LOGame new'
		itsSelectionString: 	'LOGame new'
	Receiver's instance variables: 
		ast: 	DoIt
	^ LOGame new
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


SmalltalkEditor>>evaluateSelectionAndDo:
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | result inspect ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(381419520)
		selectionShowing: 	true
		model: 	a Workspace
		editingState: 	a SmalltalkEditingState


[ textMorph editor evaluateSelectionAndDo: [ :result | result inspect ] ] in PluggableTextMorph>>inspectIt
	Receiver: a PluggableTextMorph(570949632)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(488.0@523.0) corner: (928.0@690.0)
		owner: 	a SystemWindow(481034240)
		submorphs: 	an Array(a TransformMorph(508559360))
		fullBounds: 	(488@523) corner: (928@690)
		color: 	Color white
		extension: 	a MorphExtension (360185856) [locked]  [other:  (kmDispatcher -> a K...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(610795520)
		scroller: 	a TransformMorph(508559360)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(526123008)
		textMorph: 	a TextMorphForEditView(381419520)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 10)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


[ result := editBlock value ] in PluggableTextMorph>>handleEdit:
	Receiver: a PluggableTextMorph(570949632)
	Arguments and temporary variables: 
		editBlock: 	[ textMorph editor evaluateSelectionAndDo: [ :result | result inspec...etc...
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(488.0@523.0) corner: (928.0@690.0)
		owner: 	a SystemWindow(481034240)
		submorphs: 	an Array(a TransformMorph(508559360))
		fullBounds: 	(488@523) corner: (928@690)
		color: 	Color white
		extension: 	a MorphExtension (360185856) [locked]  [other:  (kmDispatcher -> a K...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(610795520)
		scroller: 	a TransformMorph(508559360)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(526123008)
		textMorph: 	a TextMorphForEditView(381419520)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 10)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


TextMorphForEditView(TextMorph)>>handleEdit:
	Receiver: a TextMorphForEditView(381419520)
	Arguments and temporary variables: 
		editBlock: 	[ result := editBlock value ]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@18)
		owner: 	a TransformMorph(508559360)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@18)
		color: 	Color black
		extension: 	a MorphExtension (436207616) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'LOGame new'
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(570949632)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


PluggableTextMorph>>handleEdit:
	Receiver: a PluggableTextMorph(570949632)
	Arguments and temporary variables: 
		result: 	nil
		editBlock: 	[ textMorph editor evaluateSelectionAndDo: [ :result | result inspec...etc...
	Receiver's instance variables: 
		bounds: 	(488.0@523.0) corner: (928.0@690.0)
		owner: 	a SystemWindow(481034240)
		submorphs: 	an Array(a TransformMorph(508559360))
		fullBounds: 	(488@523) corner: (928@690)
		color: 	Color white
		extension: 	a MorphExtension (360185856) [locked]  [other:  (kmDispatcher -> a K...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(610795520)
		scroller: 	a TransformMorph(508559360)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(526123008)
		textMorph: 	a TextMorphForEditView(381419520)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 10)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


PluggableTextMorph>>inspectIt
	Receiver: a PluggableTextMorph(570949632)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(488.0@523.0) corner: (928.0@690.0)
		owner: 	a SystemWindow(481034240)
		submorphs: 	an Array(a TransformMorph(508559360))
		fullBounds: 	(488@523) corner: (928@690)
		color: 	Color white
		extension: 	a MorphExtension (360185856) [locked]  [other:  (kmDispatcher -> a K...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(610795520)
		scroller: 	a TransformMorph(508559360)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(526123008)
		textMorph: 	a TextMorphForEditView(381419520)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 10)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


[ :morph | morph inspectIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
	Receiver: SmalltalkEditor
	Arguments and temporary variables: 
		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a PluggableTextMorph(570949632)
	Receiver's instance variables: 
		superclass: 	TextEditor
		methodDict: 	a MethodDictionary(#argAdvance:->SmalltalkEditor>>#argAdvance: #bro...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SmalltalkEditor
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Text-Edition'
		traitComposition: 	{}
		localSelectors: 	nil
		cmdActions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop...etc...
		shiftCmdActions: 	#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #m...etc...


BlockClosure>>cull:
	Receiver: [ :morph | morph inspectIt ]
	Arguments and temporary variables: 
		anArg: 	a PluggableTextMorph(570949632)
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	182
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :morph | morph inspectIt ]
	Arguments and temporary variables: 
		firstArg: 	a PluggableTextMorph(570949632)
		secondArg: 	a PluggableTextMorph(570949632)
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	182
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :morph | morph inspectIt ]
	Arguments and temporary variables: 
		firstArg: 	a PluggableTextMorph(570949632)
		secondArg: 	a PluggableTextMorph(570949632)
		thirdArg: 	[keystroke '<Cmd-i>']
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	182
		numArgs: 	1


KMCategoryBinding>>completeMatch:buffer:
	Receiver: aKMCategoryTarget(#SmalltalkEditor)
	Arguments and temporary variables: 
		aKeymap: 	#inspectIt on Cmd + I do [ :morph | morph inspectIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
	Receiver's instance variables: 
		target: 	a PluggableTextMorph(570949632)
		category: 	a KMCategory
		morph: 	a PluggableTextMorph(570949632)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #inspectIt on Cmd + I do [ :morph | morph inspectIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		l: 	aKMCategoryTarget(#SmalltalkEditor)
	Receiver's instance variables: 
		action: 	[ :morph | morph inspectIt ]
		name: 	#inspectIt
		shortcut: 	Cmd + I
		defaultShortcut: 	Cmd + I
		description: 	''


Array(SequenceableCollection)>>do:
	Receiver: an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #inspectIt on Cmd + I do [ :morph | morph inspectIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ :morph | morph inspectIt ]
		name: 	#inspectIt
		shortcut: 	Cmd + I
		defaultShortcut: 	Cmd + I
		description: 	''


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: #inspectIt on Cmd + I do [ :morph | morph inspectIt ]

	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		action: 	[ :morph | morph inspectIt ]
		name: 	#inspectIt
		shortcut: 	Cmd + I
		defaultShortcut: 	Cmd + I
		description: 	''


[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#inspectIt on Cmd + I do [ :morph | morph inspectIt ]

	Receiver's instance variables: 
		name: 	#SmalltalkEditor
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


Set>>do:
	Receiver: a Set(#printIt on Cmd + P do [ :morph | morph printIt ]
 #previousSelection on Cmd + Shift...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	13
		each: 	#inspectIt on Cmd + I do [ :morph | morph inspectIt ]

	Receiver's instance variables: 
		tally: 	14
		array: 	an Array(#printIt on Cmd + P do [ :morph | morph printIt ]
 #previousSel...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
	Receiver's instance variables: 
		name: 	#SmalltalkEditor
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: aKMCategoryTarget(#SmalltalkEditor)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		target: 	a PluggableTextMorph(570949632)
		category: 	a KMCategory
		morph: 	a PluggableTextMorph(570949632)


[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#SmalltalkEditor)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#SmalltalkEditor) aKMCategoryTarget(#TextMorph...etc...
		morph: 	a PluggableTextMorph(570949632)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#SmalltalkEditor) aKMCategor...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	2
	Receiver's instance variables: 
		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#SmalltalkEditor) aKMC...etc...
		firstIndex: 	1
		lastIndex: 	7


KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		association: 	nil
		match: 	nil
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#SmalltalkEditor) aKMCategoryTarget(#TextMorph...etc...
		morph: 	a PluggableTextMorph(570949632)
		directKeymaps: 	a KMCategory


KMTarget>>dispatch:
	Receiver: a KMTarget
	Arguments and temporary variables: 
		buffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
	Receiver's instance variables: 
		realTarget: 	nil
		morph: 	a PluggableTextMorph(570949632)
		targetSelector: 	#yourself
		directKeymaps: 	nil
		perInstanceCategories: 	nil


[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Cmd-i>']
		targetToDispatch: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>do:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Cmd-i>']
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher



--- The full stack ---
LOGame(Object)>>doesNotUnderstand: #cellsPerSide
Message>>sentTo:
LOGame(Object)>>doesNotUnderstand: #cellsPerSide
Message>>sentTo:
LOGame(Object)>>doesNotUnderstand: #cellsPerSide
Message>>sentTo:
LOGame(Object)>>doesNotUnderstand: #cellsPerSide
Message>>sentTo:
LOGame(Object)>>doesNotUnderstand: #cellsPerSide
LOGame>>initialize
LOGame class(Behavior)>>new
UndefinedObject>>DoIt
OpalCompiler>>evaluate
SmalltalkEditor>>evaluateSelectionAndDo:
[ textMorph editor evaluateSelectionAndDo: [ :result | result inspect ] ] in PluggableTextMorph>>inspectIt
[ result := editBlock value ] in PluggableTextMorph>>handleEdit:
TextMorphForEditView(TextMorph)>>handleEdit:
PluggableTextMorph>>handleEdit:
PluggableTextMorph>>inspectIt
[ :morph | morph inspectIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
KMDispatcher>>dispatchKeystroke:
TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
TextMorphForEditView(TextMorph)>>handleKeystroke:
KeyboardEvent>>sentTo:
TextMorphForEditView(Morph)>>handleEvent:
TextMorphForEditView(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: LOGame>>cellsPerSide
16 October 2014 4:12:40.911825 pm

VM: Mac OS - intel - 1090 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30858]

LOGame(Object)>>doesNotUnderstand: #cellsPerSide
	Receiver: a LOGame(1052770304)
	Arguments and temporary variables: 
		aMessage: 	cellsPerSide
		exception: 	MessageNotUnderstood: LOGame>>cellsPerSide
		resumeValue: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (50@40)
		owner: 	nil
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	nil
		borderWidth: 	2
		borderColor: 	Color black
		cells: 	nil


Message>>sentTo:
	Receiver: cellsPerSide
	Arguments and temporary variables: 
		receiver: 	a LOGame(1052770304)
	Receiver's instance variables: 
		selector: 	#cellsPerSide
		args: 	#()
		lookupClass: 	LOGame


LOGame(Object)>>doesNotUnderstand: #cellsPerSide
	Receiver: a LOGame(1052770304)
	Arguments and temporary variables: 
		aMessage: 	cellsPerSide
		exception: 	MessageNotUnderstood: LOGame>>cellsPerSide
		resumeValue: 	MessageNotUnderstood: LOGame>>cellsPerSide
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (50@40)
		owner: 	nil
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	nil
		borderWidth: 	2
		borderColor: 	Color black
		cells: 	nil


Message>>sentTo:
	Receiver: cellsPerSide
	Arguments and temporary variables: 
		receiver: 	a LOGame(1052770304)
	Receiver's instance variables: 
		selector: 	#cellsPerSide
		args: 	#()
		lookupClass: 	LOGame


LOGame(Object)>>doesNotUnderstand: #cellsPerSide
	Receiver: a LOGame(1052770304)
	Arguments and temporary variables: 
		aMessage: 	cellsPerSide
		exception: 	MessageNotUnderstood: LOGame>>cellsPerSide
		resumeValue: 	MessageNotUnderstood: LOGame>>cellsPerSide
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (50@40)
		owner: 	nil
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	nil
		borderWidth: 	2
		borderColor: 	Color black
		cells: 	nil


Message>>sentTo:
	Receiver: cellsPerSide
	Arguments and temporary variables: 
		receiver: 	a LOGame(1052770304)
	Receiver's instance variables: 
		selector: 	#cellsPerSide
		args: 	#()
		lookupClass: 	LOGame


LOGame(Object)>>doesNotUnderstand: #cellsPerSide
	Receiver: a LOGame(1052770304)
	Arguments and temporary variables: 
		aMessage: 	cellsPerSide
		exception: 	MessageNotUnderstood: LOGame>>cellsPerSide
		resumeValue: 	MessageNotUnderstood: LOGame>>cellsPerSide
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (50@40)
		owner: 	nil
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	nil
		borderWidth: 	2
		borderColor: 	Color black
		cells: 	nil


Message>>sentTo:
	Receiver: cellsPerSide
	Arguments and temporary variables: 
		receiver: 	a LOGame(1052770304)
	Receiver's instance variables: 
		selector: 	#cellsPerSide
		args: 	#()
		lookupClass: 	LOGame


LOGame(Object)>>doesNotUnderstand: #cellsPerSide
	Receiver: a LOGame(1052770304)
	Arguments and temporary variables: 
		aMessage: 	cellsPerSide
		exception: 	MessageNotUnderstood: LOGame>>cellsPerSide
		resumeValue: 	MessageNotUnderstood: LOGame>>cellsPerSide
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (50@40)
		owner: 	nil
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	nil
		borderWidth: 	2
		borderColor: 	Color black
		cells: 	nil


Message>>sentTo:
	Receiver: cellsPerSide
	Arguments and temporary variables: 
		receiver: 	a LOGame(1052770304)
	Receiver's instance variables: 
		selector: 	#cellsPerSide
		args: 	#()
		lookupClass: 	LOGame


LOGame(Object)>>doesNotUnderstand: #cellsPerSide
	Receiver: a LOGame(1052770304)
	Arguments and temporary variables: 
		aMessage: 	cellsPerSide
		exception: 	MessageNotUnderstood: LOGame>>cellsPerSide
		resumeValue: 	MessageNotUnderstood: LOGame>>cellsPerSide
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (50@40)
		owner: 	nil
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	nil
		borderWidth: 	2
		borderColor: 	Color black
		cells: 	nil


LOGame>>initialize
	Receiver: a LOGame(1052770304)
	Arguments and temporary variables: 
		sampleCell: 	nil
		width: 	nil
		height: 	nil
		n: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (50@40)
		owner: 	nil
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	nil
		borderWidth: 	2
		borderColor: 	Color black
		cells: 	nil


LOGame class(Behavior)>>new
	Receiver: LOGame
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	BorderedMorph
		methodDict: 	a MethodDictionary(#initialize->LOGame>>#initialize )
		format: 	148
		layout: 	a FixedLayout
		instanceVariables: 	#(#cells)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#LOGame
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'PBE-LightsOut'
		traitComposition: 	{}
		localSelectors: 	nil
		announcer: 	nil


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'LOGame new'
		itsSelection: 	a Text for 'LOGame new'
		itsSelectionString: 	'LOGame new'
	Receiver's instance variables: 
		ast: 	DoIt
	^ LOGame new
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


SmalltalkEditor>>evaluateSelectionAndDo:
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | result inspect ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(381419520)
		selectionShowing: 	true
		model: 	a Workspace
		editingState: 	a SmalltalkEditingState


[ textMorph editor evaluateSelectionAndDo: [ :result | result inspect ] ] in PluggableTextMorph>>inspectIt
	Receiver: a PluggableTextMorph(570949632)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(488.0@523.0) corner: (928.0@690.0)
		owner: 	a SystemWindow(481034240)
		submorphs: 	an Array(a TransformMorph(508559360))
		fullBounds: 	(488@523) corner: (928@690)
		color: 	Color white
		extension: 	a MorphExtension (360185856) [locked]  [other:  (kmDispatcher -> a K...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(610795520)
		scroller: 	a TransformMorph(508559360)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(526123008)
		textMorph: 	a TextMorphForEditView(381419520)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 10)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


[ result := editBlock value ] in PluggableTextMorph>>handleEdit:
	Receiver: a PluggableTextMorph(570949632)
	Arguments and temporary variables: 
		editBlock: 	[ textMorph editor evaluateSelectionAndDo: [ :result | result inspec...etc...
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(488.0@523.0) corner: (928.0@690.0)
		owner: 	a SystemWindow(481034240)
		submorphs: 	an Array(a TransformMorph(508559360))
		fullBounds: 	(488@523) corner: (928@690)
		color: 	Color white
		extension: 	a MorphExtension (360185856) [locked]  [other:  (kmDispatcher -> a K...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(610795520)
		scroller: 	a TransformMorph(508559360)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(526123008)
		textMorph: 	a TextMorphForEditView(381419520)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 10)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


TextMorphForEditView(TextMorph)>>handleEdit:
	Receiver: a TextMorphForEditView(381419520)
	Arguments and temporary variables: 
		editBlock: 	[ result := editBlock value ]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@18)
		owner: 	a TransformMorph(508559360)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@18)
		color: 	Color black
		extension: 	a MorphExtension (436207616) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'LOGame new'
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(570949632)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


PluggableTextMorph>>handleEdit:
	Receiver: a PluggableTextMorph(570949632)
	Arguments and temporary variables: 
		result: 	nil
		editBlock: 	[ textMorph editor evaluateSelectionAndDo: [ :result | result inspec...etc...
	Receiver's instance variables: 
		bounds: 	(488.0@523.0) corner: (928.0@690.0)
		owner: 	a SystemWindow(481034240)
		submorphs: 	an Array(a TransformMorph(508559360))
		fullBounds: 	(488@523) corner: (928@690)
		color: 	Color white
		extension: 	a MorphExtension (360185856) [locked]  [other:  (kmDispatcher -> a K...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(610795520)
		scroller: 	a TransformMorph(508559360)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(526123008)
		textMorph: 	a TextMorphForEditView(381419520)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 10)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


PluggableTextMorph>>inspectIt
	Receiver: a PluggableTextMorph(570949632)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(488.0@523.0) corner: (928.0@690.0)
		owner: 	a SystemWindow(481034240)
		submorphs: 	an Array(a TransformMorph(508559360))
		fullBounds: 	(488@523) corner: (928@690)
		color: 	Color white
		extension: 	a MorphExtension (360185856) [locked]  [other:  (kmDispatcher -> a K...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(610795520)
		scroller: 	a TransformMorph(508559360)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(526123008)
		textMorph: 	a TextMorphForEditView(381419520)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 10)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


[ :morph | morph inspectIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
	Receiver: SmalltalkEditor
	Arguments and temporary variables: 
		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a PluggableTextMorph(570949632)
	Receiver's instance variables: 
		superclass: 	TextEditor
		methodDict: 	a MethodDictionary(#argAdvance:->SmalltalkEditor>>#argAdvance: #bro...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SmalltalkEditor
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Text-Edition'
		traitComposition: 	{}
		localSelectors: 	nil
		cmdActions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop...etc...
		shiftCmdActions: 	#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #m...etc...


BlockClosure>>cull:
	Receiver: [ :morph | morph inspectIt ]
	Arguments and temporary variables: 
		anArg: 	a PluggableTextMorph(570949632)
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	182
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :morph | morph inspectIt ]
	Arguments and temporary variables: 
		firstArg: 	a PluggableTextMorph(570949632)
		secondArg: 	a PluggableTextMorph(570949632)
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	182
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :morph | morph inspectIt ]
	Arguments and temporary variables: 
		firstArg: 	a PluggableTextMorph(570949632)
		secondArg: 	a PluggableTextMorph(570949632)
		thirdArg: 	[keystroke '<Cmd-i>']
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	182
		numArgs: 	1


KMCategoryBinding>>completeMatch:buffer:
	Receiver: aKMCategoryTarget(#SmalltalkEditor)
	Arguments and temporary variables: 
		aKeymap: 	#inspectIt on Cmd + I do [ :morph | morph inspectIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
	Receiver's instance variables: 
		target: 	a PluggableTextMorph(570949632)
		category: 	a KMCategory
		morph: 	a PluggableTextMorph(570949632)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #inspectIt on Cmd + I do [ :morph | morph inspectIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		l: 	aKMCategoryTarget(#SmalltalkEditor)
	Receiver's instance variables: 
		action: 	[ :morph | morph inspectIt ]
		name: 	#inspectIt
		shortcut: 	Cmd + I
		defaultShortcut: 	Cmd + I
		description: 	''


Array(SequenceableCollection)>>do:
	Receiver: an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #inspectIt on Cmd + I do [ :morph | morph inspectIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ :morph | morph inspectIt ]
		name: 	#inspectIt
		shortcut: 	Cmd + I
		defaultShortcut: 	Cmd + I
		description: 	''


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: #inspectIt on Cmd + I do [ :morph | morph inspectIt ]

	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		action: 	[ :morph | morph inspectIt ]
		name: 	#inspectIt
		shortcut: 	Cmd + I
		defaultShortcut: 	Cmd + I
		description: 	''


[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#inspectIt on Cmd + I do [ :morph | morph inspectIt ]

	Receiver's instance variables: 
		name: 	#SmalltalkEditor
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


Set>>do:
	Receiver: a Set(#printIt on Cmd + P do [ :morph | morph printIt ]
 #previousSelection on Cmd + Shift...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	13
		each: 	#inspectIt on Cmd + I do [ :morph | morph inspectIt ]

	Receiver's instance variables: 
		tally: 	14
		array: 	an Array(#printIt on Cmd + P do [ :morph | morph printIt ]
 #previousSel...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
	Receiver's instance variables: 
		name: 	#SmalltalkEditor
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: aKMCategoryTarget(#SmalltalkEditor)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		target: 	a PluggableTextMorph(570949632)
		category: 	a KMCategory
		morph: 	a PluggableTextMorph(570949632)


[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#SmalltalkEditor)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#SmalltalkEditor) aKMCategoryTarget(#TextMorph...etc...
		morph: 	a PluggableTextMorph(570949632)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#SmalltalkEditor) aKMCategor...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	2
	Receiver's instance variables: 
		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#SmalltalkEditor) aKMC...etc...
		firstIndex: 	1
		lastIndex: 	7


KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		association: 	nil
		match: 	nil
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#SmalltalkEditor) aKMCategoryTarget(#TextMorph...etc...
		morph: 	a PluggableTextMorph(570949632)
		directKeymaps: 	a KMCategory


KMTarget>>dispatch:
	Receiver: a KMTarget
	Arguments and temporary variables: 
		buffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
	Receiver's instance variables: 
		realTarget: 	nil
		morph: 	a PluggableTextMorph(570949632)
		targetSelector: 	#yourself
		directKeymaps: 	nil
		perInstanceCategories: 	nil


[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Cmd-i>']
		targetToDispatch: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher



--- The full stack ---
LOGame(Object)>>doesNotUnderstand: #cellsPerSide
Message>>sentTo:
LOGame(Object)>>doesNotUnderstand: #cellsPerSide
Message>>sentTo:
LOGame(Object)>>doesNotUnderstand: #cellsPerSide
Message>>sentTo:
LOGame(Object)>>doesNotUnderstand: #cellsPerSide
Message>>sentTo:
LOGame(Object)>>doesNotUnderstand: #cellsPerSide
Message>>sentTo:
LOGame(Object)>>doesNotUnderstand: #cellsPerSide
LOGame>>initialize
LOGame class(Behavior)>>new
UndefinedObject>>DoIt
OpalCompiler>>evaluate
SmalltalkEditor>>evaluateSelectionAndDo:
[ textMorph editor evaluateSelectionAndDo: [ :result | result inspect ] ] in PluggableTextMorph>>inspectIt
[ result := editBlock value ] in PluggableTextMorph>>handleEdit:
TextMorphForEditView(TextMorph)>>handleEdit:
PluggableTextMorph>>handleEdit:
PluggableTextMorph>>inspectIt
[ :morph | morph inspectIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
TextMorphForEditView(TextMorph)>>handleKeystroke:
KeyboardEvent>>sentTo:
TextMorphForEditView(Morph)>>handleEvent:
TextMorphForEditView(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: LOGame>>cellsPerSide
16 October 2014 4:12:42.148478 pm

VM: Mac OS - intel - 1090 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30858]

LOGame(Object)>>doesNotUnderstand: #cellsPerSide
	Receiver: a LOGame(1052770304)
	Arguments and temporary variables: 
		aMessage: 	cellsPerSide
		exception: 	MessageNotUnderstood: LOGame>>cellsPerSide
		resumeValue: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (50@40)
		owner: 	nil
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	nil
		borderWidth: 	2
		borderColor: 	Color black
		cells: 	nil


Message>>sentTo:
	Receiver: cellsPerSide
	Arguments and temporary variables: 
		receiver: 	a LOGame(1052770304)
	Receiver's instance variables: 
		selector: 	#cellsPerSide
		args: 	#()
		lookupClass: 	LOGame


LOGame(Object)>>doesNotUnderstand: #cellsPerSide
	Receiver: a LOGame(1052770304)
	Arguments and temporary variables: 
		aMessage: 	cellsPerSide
		exception: 	MessageNotUnderstood: LOGame>>cellsPerSide
		resumeValue: 	MessageNotUnderstood: LOGame>>cellsPerSide
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (50@40)
		owner: 	nil
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	nil
		borderWidth: 	2
		borderColor: 	Color black
		cells: 	nil


Message>>sentTo:
	Receiver: cellsPerSide
	Arguments and temporary variables: 
		receiver: 	a LOGame(1052770304)
	Receiver's instance variables: 
		selector: 	#cellsPerSide
		args: 	#()
		lookupClass: 	LOGame


LOGame(Object)>>doesNotUnderstand: #cellsPerSide
	Receiver: a LOGame(1052770304)
	Arguments and temporary variables: 
		aMessage: 	cellsPerSide
		exception: 	MessageNotUnderstood: LOGame>>cellsPerSide
		resumeValue: 	MessageNotUnderstood: LOGame>>cellsPerSide
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (50@40)
		owner: 	nil
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	nil
		borderWidth: 	2
		borderColor: 	Color black
		cells: 	nil


Message>>sentTo:
	Receiver: cellsPerSide
	Arguments and temporary variables: 
		receiver: 	a LOGame(1052770304)
	Receiver's instance variables: 
		selector: 	#cellsPerSide
		args: 	#()
		lookupClass: 	LOGame


LOGame(Object)>>doesNotUnderstand: #cellsPerSide
	Receiver: a LOGame(1052770304)
	Arguments and temporary variables: 
		aMessage: 	cellsPerSide
		exception: 	MessageNotUnderstood: LOGame>>cellsPerSide
		resumeValue: 	MessageNotUnderstood: LOGame>>cellsPerSide
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (50@40)
		owner: 	nil
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	nil
		borderWidth: 	2
		borderColor: 	Color black
		cells: 	nil


Message>>sentTo:
	Receiver: cellsPerSide
	Arguments and temporary variables: 
		receiver: 	a LOGame(1052770304)
	Receiver's instance variables: 
		selector: 	#cellsPerSide
		args: 	#()
		lookupClass: 	LOGame


LOGame(Object)>>doesNotUnderstand: #cellsPerSide
	Receiver: a LOGame(1052770304)
	Arguments and temporary variables: 
		aMessage: 	cellsPerSide
		exception: 	MessageNotUnderstood: LOGame>>cellsPerSide
		resumeValue: 	MessageNotUnderstood: LOGame>>cellsPerSide
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (50@40)
		owner: 	nil
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	nil
		borderWidth: 	2
		borderColor: 	Color black
		cells: 	nil


Message>>sentTo:
	Receiver: cellsPerSide
	Arguments and temporary variables: 
		receiver: 	a LOGame(1052770304)
	Receiver's instance variables: 
		selector: 	#cellsPerSide
		args: 	#()
		lookupClass: 	LOGame


LOGame(Object)>>doesNotUnderstand: #cellsPerSide
	Receiver: a LOGame(1052770304)
	Arguments and temporary variables: 
		aMessage: 	cellsPerSide
		exception: 	MessageNotUnderstood: LOGame>>cellsPerSide
		resumeValue: 	MessageNotUnderstood: LOGame>>cellsPerSide
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (50@40)
		owner: 	nil
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	nil
		borderWidth: 	2
		borderColor: 	Color black
		cells: 	nil


Message>>sentTo:
	Receiver: cellsPerSide
	Arguments and temporary variables: 
		receiver: 	a LOGame(1052770304)
	Receiver's instance variables: 
		selector: 	#cellsPerSide
		args: 	#()
		lookupClass: 	LOGame


LOGame(Object)>>doesNotUnderstand: #cellsPerSide
	Receiver: a LOGame(1052770304)
	Arguments and temporary variables: 
		aMessage: 	cellsPerSide
		exception: 	MessageNotUnderstood: LOGame>>cellsPerSide
		resumeValue: 	MessageNotUnderstood: LOGame>>cellsPerSide
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (50@40)
		owner: 	nil
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	nil
		borderWidth: 	2
		borderColor: 	Color black
		cells: 	nil


LOGame>>initialize
	Receiver: a LOGame(1052770304)
	Arguments and temporary variables: 
		sampleCell: 	nil
		width: 	nil
		height: 	nil
		n: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (50@40)
		owner: 	nil
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	nil
		borderWidth: 	2
		borderColor: 	Color black
		cells: 	nil


LOGame class(Behavior)>>new
	Receiver: LOGame
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	BorderedMorph
		methodDict: 	a MethodDictionary(#initialize->LOGame>>#initialize )
		format: 	148
		layout: 	a FixedLayout
		instanceVariables: 	#(#cells)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#LOGame
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'PBE-LightsOut'
		traitComposition: 	{}
		localSelectors: 	nil
		announcer: 	nil


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'LOGame new'
		itsSelection: 	a Text for 'LOGame new'
		itsSelectionString: 	'LOGame new'
	Receiver's instance variables: 
		ast: 	DoIt
	^ LOGame new
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


SmalltalkEditor>>evaluateSelectionAndDo:
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | result inspect ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(381419520)
		selectionShowing: 	true
		model: 	a Workspace
		editingState: 	a SmalltalkEditingState


[ textMorph editor evaluateSelectionAndDo: [ :result | result inspect ] ] in PluggableTextMorph>>inspectIt
	Receiver: a PluggableTextMorph(570949632)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(488.0@523.0) corner: (928.0@690.0)
		owner: 	a SystemWindow(481034240)
		submorphs: 	an Array(a TransformMorph(508559360))
		fullBounds: 	(488@523) corner: (928@690)
		color: 	Color white
		extension: 	a MorphExtension (360185856) [locked]  [other:  (kmDispatcher -> a K...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(610795520)
		scroller: 	a TransformMorph(508559360)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(526123008)
		textMorph: 	a TextMorphForEditView(381419520)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 10)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


[ result := editBlock value ] in PluggableTextMorph>>handleEdit:
	Receiver: a PluggableTextMorph(570949632)
	Arguments and temporary variables: 
		editBlock: 	[ textMorph editor evaluateSelectionAndDo: [ :result | result inspec...etc...
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(488.0@523.0) corner: (928.0@690.0)
		owner: 	a SystemWindow(481034240)
		submorphs: 	an Array(a TransformMorph(508559360))
		fullBounds: 	(488@523) corner: (928@690)
		color: 	Color white
		extension: 	a MorphExtension (360185856) [locked]  [other:  (kmDispatcher -> a K...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(610795520)
		scroller: 	a TransformMorph(508559360)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(526123008)
		textMorph: 	a TextMorphForEditView(381419520)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 10)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


TextMorphForEditView(TextMorph)>>handleEdit:
	Receiver: a TextMorphForEditView(381419520)
	Arguments and temporary variables: 
		editBlock: 	[ result := editBlock value ]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@18)
		owner: 	a TransformMorph(508559360)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@18)
		color: 	Color black
		extension: 	a MorphExtension (436207616) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'LOGame new'
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(570949632)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


PluggableTextMorph>>handleEdit:
	Receiver: a PluggableTextMorph(570949632)
	Arguments and temporary variables: 
		result: 	nil
		editBlock: 	[ textMorph editor evaluateSelectionAndDo: [ :result | result inspec...etc...
	Receiver's instance variables: 
		bounds: 	(488.0@523.0) corner: (928.0@690.0)
		owner: 	a SystemWindow(481034240)
		submorphs: 	an Array(a TransformMorph(508559360))
		fullBounds: 	(488@523) corner: (928@690)
		color: 	Color white
		extension: 	a MorphExtension (360185856) [locked]  [other:  (kmDispatcher -> a K...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(610795520)
		scroller: 	a TransformMorph(508559360)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(526123008)
		textMorph: 	a TextMorphForEditView(381419520)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 10)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


PluggableTextMorph>>inspectIt
	Receiver: a PluggableTextMorph(570949632)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(488.0@523.0) corner: (928.0@690.0)
		owner: 	a SystemWindow(481034240)
		submorphs: 	an Array(a TransformMorph(508559360))
		fullBounds: 	(488@523) corner: (928@690)
		color: 	Color white
		extension: 	a MorphExtension (360185856) [locked]  [other:  (kmDispatcher -> a K...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(610795520)
		scroller: 	a TransformMorph(508559360)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(526123008)
		textMorph: 	a TextMorphForEditView(381419520)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 10)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


[ :morph | morph inspectIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
	Receiver: SmalltalkEditor
	Arguments and temporary variables: 
		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a PluggableTextMorph(570949632)
	Receiver's instance variables: 
		superclass: 	TextEditor
		methodDict: 	a MethodDictionary(#argAdvance:->SmalltalkEditor>>#argAdvance: #bro...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SmalltalkEditor
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Text-Edition'
		traitComposition: 	{}
		localSelectors: 	nil
		cmdActions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop...etc...
		shiftCmdActions: 	#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #m...etc...


BlockClosure>>cull:
	Receiver: [ :morph | morph inspectIt ]
	Arguments and temporary variables: 
		anArg: 	a PluggableTextMorph(570949632)
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	182
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :morph | morph inspectIt ]
	Arguments and temporary variables: 
		firstArg: 	a PluggableTextMorph(570949632)
		secondArg: 	a PluggableTextMorph(570949632)
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	182
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :morph | morph inspectIt ]
	Arguments and temporary variables: 
		firstArg: 	a PluggableTextMorph(570949632)
		secondArg: 	a PluggableTextMorph(570949632)
		thirdArg: 	[keystroke '<Cmd-i>']
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	182
		numArgs: 	1


KMCategoryBinding>>completeMatch:buffer:
	Receiver: aKMCategoryTarget(#SmalltalkEditor)
	Arguments and temporary variables: 
		aKeymap: 	#inspectIt on Cmd + I do [ :morph | morph inspectIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
	Receiver's instance variables: 
		target: 	a PluggableTextMorph(570949632)
		category: 	a KMCategory
		morph: 	a PluggableTextMorph(570949632)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #inspectIt on Cmd + I do [ :morph | morph inspectIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		l: 	aKMCategoryTarget(#SmalltalkEditor)
	Receiver's instance variables: 
		action: 	[ :morph | morph inspectIt ]
		name: 	#inspectIt
		shortcut: 	Cmd + I
		defaultShortcut: 	Cmd + I
		description: 	''


Array(SequenceableCollection)>>do:
	Receiver: an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #inspectIt on Cmd + I do [ :morph | morph inspectIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ :morph | morph inspectIt ]
		name: 	#inspectIt
		shortcut: 	Cmd + I
		defaultShortcut: 	Cmd + I
		description: 	''


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: #inspectIt on Cmd + I do [ :morph | morph inspectIt ]

	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		action: 	[ :morph | morph inspectIt ]
		name: 	#inspectIt
		shortcut: 	Cmd + I
		defaultShortcut: 	Cmd + I
		description: 	''


[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#inspectIt on Cmd + I do [ :morph | morph inspectIt ]

	Receiver's instance variables: 
		name: 	#SmalltalkEditor
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


Set>>do:
	Receiver: a Set(#printIt on Cmd + P do [ :morph | morph printIt ]
 #previousSelection on Cmd + Shift...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	13
		each: 	#inspectIt on Cmd + I do [ :morph | morph inspectIt ]

	Receiver's instance variables: 
		tally: 	14
		array: 	an Array(#printIt on Cmd + P do [ :morph | morph printIt ]
 #previousSel...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
	Receiver's instance variables: 
		name: 	#SmalltalkEditor
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: aKMCategoryTarget(#SmalltalkEditor)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		target: 	a PluggableTextMorph(570949632)
		category: 	a KMCategory
		morph: 	a PluggableTextMorph(570949632)


[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#SmalltalkEditor)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#SmalltalkEditor) aKMCategoryTarget(#TextMorph...etc...
		morph: 	a PluggableTextMorph(570949632)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#SmalltalkEditor) aKMCategor...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	2
	Receiver's instance variables: 
		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#SmalltalkEditor) aKMC...etc...
		firstIndex: 	1
		lastIndex: 	7


KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		association: 	nil
		match: 	nil
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#SmalltalkEditor) aKMCategoryTarget(#TextMorph...etc...
		morph: 	a PluggableTextMorph(570949632)
		directKeymaps: 	a KMCategory



--- The full stack ---
LOGame(Object)>>doesNotUnderstand: #cellsPerSide
Message>>sentTo:
LOGame(Object)>>doesNotUnderstand: #cellsPerSide
Message>>sentTo:
LOGame(Object)>>doesNotUnderstand: #cellsPerSide
Message>>sentTo:
LOGame(Object)>>doesNotUnderstand: #cellsPerSide
Message>>sentTo:
LOGame(Object)>>doesNotUnderstand: #cellsPerSide
Message>>sentTo:
LOGame(Object)>>doesNotUnderstand: #cellsPerSide
Message>>sentTo:
LOGame(Object)>>doesNotUnderstand: #cellsPerSide
LOGame>>initialize
LOGame class(Behavior)>>new
UndefinedObject>>DoIt
OpalCompiler>>evaluate
SmalltalkEditor>>evaluateSelectionAndDo:
[ textMorph editor evaluateSelectionAndDo: [ :result | result inspect ] ] in PluggableTextMorph>>inspectIt
[ result := editBlock value ] in PluggableTextMorph>>handleEdit:
TextMorphForEditView(TextMorph)>>handleEdit:
PluggableTextMorph>>handleEdit:
PluggableTextMorph>>inspectIt
[ :morph | morph inspectIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
KMTarget>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
TextMorphForEditView(TextMorph)>>handleKeystroke:
KeyboardEvent>>sentTo:
TextMorphForEditView(Morph)>>handleEvent:
TextMorphForEditView(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: LOGame>>cellsPerSide
16 October 2014 4:12:43.438653 pm

VM: Mac OS - intel - 1090 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30858]

LOGame(Object)>>doesNotUnderstand: #cellsPerSide
	Receiver: a LOGame(1052770304)
	Arguments and temporary variables: 
		aMessage: 	cellsPerSide
		exception: 	MessageNotUnderstood: LOGame>>cellsPerSide
		resumeValue: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (50@40)
		owner: 	nil
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	nil
		borderWidth: 	2
		borderColor: 	Color black
		cells: 	nil


Message>>sentTo:
	Receiver: cellsPerSide
	Arguments and temporary variables: 
		receiver: 	a LOGame(1052770304)
	Receiver's instance variables: 
		selector: 	#cellsPerSide
		args: 	#()
		lookupClass: 	LOGame


LOGame(Object)>>doesNotUnderstand: #cellsPerSide
	Receiver: a LOGame(1052770304)
	Arguments and temporary variables: 
		aMessage: 	cellsPerSide
		exception: 	MessageNotUnderstood: LOGame>>cellsPerSide
		resumeValue: 	MessageNotUnderstood: LOGame>>cellsPerSide
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (50@40)
		owner: 	nil
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	nil
		borderWidth: 	2
		borderColor: 	Color black
		cells: 	nil


Message>>sentTo:
	Receiver: cellsPerSide
	Arguments and temporary variables: 
		receiver: 	a LOGame(1052770304)
	Receiver's instance variables: 
		selector: 	#cellsPerSide
		args: 	#()
		lookupClass: 	LOGame


LOGame(Object)>>doesNotUnderstand: #cellsPerSide
	Receiver: a LOGame(1052770304)
	Arguments and temporary variables: 
		aMessage: 	cellsPerSide
		exception: 	MessageNotUnderstood: LOGame>>cellsPerSide
		resumeValue: 	MessageNotUnderstood: LOGame>>cellsPerSide
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (50@40)
		owner: 	nil
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	nil
		borderWidth: 	2
		borderColor: 	Color black
		cells: 	nil


Message>>sentTo:
	Receiver: cellsPerSide
	Arguments and temporary variables: 
		receiver: 	a LOGame(1052770304)
	Receiver's instance variables: 
		selector: 	#cellsPerSide
		args: 	#()
		lookupClass: 	LOGame


LOGame(Object)>>doesNotUnderstand: #cellsPerSide
	Receiver: a LOGame(1052770304)
	Arguments and temporary variables: 
		aMessage: 	cellsPerSide
		exception: 	MessageNotUnderstood: LOGame>>cellsPerSide
		resumeValue: 	MessageNotUnderstood: LOGame>>cellsPerSide
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (50@40)
		owner: 	nil
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	nil
		borderWidth: 	2
		borderColor: 	Color black
		cells: 	nil


Message>>sentTo:
	Receiver: cellsPerSide
	Arguments and temporary variables: 
		receiver: 	a LOGame(1052770304)
	Receiver's instance variables: 
		selector: 	#cellsPerSide
		args: 	#()
		lookupClass: 	LOGame


LOGame(Object)>>doesNotUnderstand: #cellsPerSide
	Receiver: a LOGame(1052770304)
	Arguments and temporary variables: 
		aMessage: 	cellsPerSide
		exception: 	MessageNotUnderstood: LOGame>>cellsPerSide
		resumeValue: 	MessageNotUnderstood: LOGame>>cellsPerSide
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (50@40)
		owner: 	nil
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	nil
		borderWidth: 	2
		borderColor: 	Color black
		cells: 	nil


Message>>sentTo:
	Receiver: cellsPerSide
	Arguments and temporary variables: 
		receiver: 	a LOGame(1052770304)
	Receiver's instance variables: 
		selector: 	#cellsPerSide
		args: 	#()
		lookupClass: 	LOGame


LOGame(Object)>>doesNotUnderstand: #cellsPerSide
	Receiver: a LOGame(1052770304)
	Arguments and temporary variables: 
		aMessage: 	cellsPerSide
		exception: 	MessageNotUnderstood: LOGame>>cellsPerSide
		resumeValue: 	MessageNotUnderstood: LOGame>>cellsPerSide
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (50@40)
		owner: 	nil
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	nil
		borderWidth: 	2
		borderColor: 	Color black
		cells: 	nil


Message>>sentTo:
	Receiver: cellsPerSide
	Arguments and temporary variables: 
		receiver: 	a LOGame(1052770304)
	Receiver's instance variables: 
		selector: 	#cellsPerSide
		args: 	#()
		lookupClass: 	LOGame


LOGame(Object)>>doesNotUnderstand: #cellsPerSide
	Receiver: a LOGame(1052770304)
	Arguments and temporary variables: 
		aMessage: 	cellsPerSide
		exception: 	MessageNotUnderstood: LOGame>>cellsPerSide
		resumeValue: 	MessageNotUnderstood: LOGame>>cellsPerSide
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (50@40)
		owner: 	nil
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	nil
		borderWidth: 	2
		borderColor: 	Color black
		cells: 	nil


Message>>sentTo:
	Receiver: cellsPerSide
	Arguments and temporary variables: 
		receiver: 	a LOGame(1052770304)
	Receiver's instance variables: 
		selector: 	#cellsPerSide
		args: 	#()
		lookupClass: 	LOGame


LOGame(Object)>>doesNotUnderstand: #cellsPerSide
	Receiver: a LOGame(1052770304)
	Arguments and temporary variables: 
		aMessage: 	cellsPerSide
		exception: 	MessageNotUnderstood: LOGame>>cellsPerSide
		resumeValue: 	MessageNotUnderstood: LOGame>>cellsPerSide
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (50@40)
		owner: 	nil
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	nil
		borderWidth: 	2
		borderColor: 	Color black
		cells: 	nil


LOGame>>initialize
	Receiver: a LOGame(1052770304)
	Arguments and temporary variables: 
		sampleCell: 	nil
		width: 	nil
		height: 	nil
		n: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (50@40)
		owner: 	nil
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	nil
		borderWidth: 	2
		borderColor: 	Color black
		cells: 	nil


LOGame class(Behavior)>>new
	Receiver: LOGame
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	BorderedMorph
		methodDict: 	a MethodDictionary(#initialize->LOGame>>#initialize )
		format: 	148
		layout: 	a FixedLayout
		instanceVariables: 	#(#cells)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#LOGame
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'PBE-LightsOut'
		traitComposition: 	{}
		localSelectors: 	nil
		announcer: 	nil


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'LOGame new'
		itsSelection: 	a Text for 'LOGame new'
		itsSelectionString: 	'LOGame new'
	Receiver's instance variables: 
		ast: 	DoIt
	^ LOGame new
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


SmalltalkEditor>>evaluateSelectionAndDo:
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | result inspect ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(381419520)
		selectionShowing: 	true
		model: 	a Workspace
		editingState: 	a SmalltalkEditingState


[ textMorph editor evaluateSelectionAndDo: [ :result | result inspect ] ] in PluggableTextMorph>>inspectIt
	Receiver: a PluggableTextMorph(570949632)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(488.0@523.0) corner: (928.0@690.0)
		owner: 	a SystemWindow(481034240)
		submorphs: 	an Array(a TransformMorph(508559360))
		fullBounds: 	(488@523) corner: (928@690)
		color: 	Color white
		extension: 	a MorphExtension (360185856) [locked]  [other:  (kmDispatcher -> a K...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(610795520)
		scroller: 	a TransformMorph(508559360)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(526123008)
		textMorph: 	a TextMorphForEditView(381419520)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 10)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


[ result := editBlock value ] in PluggableTextMorph>>handleEdit:
	Receiver: a PluggableTextMorph(570949632)
	Arguments and temporary variables: 
		editBlock: 	[ textMorph editor evaluateSelectionAndDo: [ :result | result inspec...etc...
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(488.0@523.0) corner: (928.0@690.0)
		owner: 	a SystemWindow(481034240)
		submorphs: 	an Array(a TransformMorph(508559360))
		fullBounds: 	(488@523) corner: (928@690)
		color: 	Color white
		extension: 	a MorphExtension (360185856) [locked]  [other:  (kmDispatcher -> a K...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(610795520)
		scroller: 	a TransformMorph(508559360)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(526123008)
		textMorph: 	a TextMorphForEditView(381419520)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 10)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


TextMorphForEditView(TextMorph)>>handleEdit:
	Receiver: a TextMorphForEditView(381419520)
	Arguments and temporary variables: 
		editBlock: 	[ result := editBlock value ]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@18)
		owner: 	a TransformMorph(508559360)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@18)
		color: 	Color black
		extension: 	a MorphExtension (436207616) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'LOGame new'
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(570949632)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


PluggableTextMorph>>handleEdit:
	Receiver: a PluggableTextMorph(570949632)
	Arguments and temporary variables: 
		result: 	nil
		editBlock: 	[ textMorph editor evaluateSelectionAndDo: [ :result | result inspec...etc...
	Receiver's instance variables: 
		bounds: 	(488.0@523.0) corner: (928.0@690.0)
		owner: 	a SystemWindow(481034240)
		submorphs: 	an Array(a TransformMorph(508559360))
		fullBounds: 	(488@523) corner: (928@690)
		color: 	Color white
		extension: 	a MorphExtension (360185856) [locked]  [other:  (kmDispatcher -> a K...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(610795520)
		scroller: 	a TransformMorph(508559360)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(526123008)
		textMorph: 	a TextMorphForEditView(381419520)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 10)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


PluggableTextMorph>>inspectIt
	Receiver: a PluggableTextMorph(570949632)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(488.0@523.0) corner: (928.0@690.0)
		owner: 	a SystemWindow(481034240)
		submorphs: 	an Array(a TransformMorph(508559360))
		fullBounds: 	(488@523) corner: (928@690)
		color: 	Color white
		extension: 	a MorphExtension (360185856) [locked]  [other:  (kmDispatcher -> a K...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(610795520)
		scroller: 	a TransformMorph(508559360)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(526123008)
		textMorph: 	a TextMorphForEditView(381419520)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 10)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


[ :morph | morph inspectIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
	Receiver: SmalltalkEditor
	Arguments and temporary variables: 
		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a PluggableTextMorph(570949632)
	Receiver's instance variables: 
		superclass: 	TextEditor
		methodDict: 	a MethodDictionary(#argAdvance:->SmalltalkEditor>>#argAdvance: #bro...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SmalltalkEditor
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Text-Edition'
		traitComposition: 	{}
		localSelectors: 	nil
		cmdActions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop...etc...
		shiftCmdActions: 	#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #m...etc...


BlockClosure>>cull:
	Receiver: [ :morph | morph inspectIt ]
	Arguments and temporary variables: 
		anArg: 	a PluggableTextMorph(570949632)
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	182
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :morph | morph inspectIt ]
	Arguments and temporary variables: 
		firstArg: 	a PluggableTextMorph(570949632)
		secondArg: 	a PluggableTextMorph(570949632)
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	182
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :morph | morph inspectIt ]
	Arguments and temporary variables: 
		firstArg: 	a PluggableTextMorph(570949632)
		secondArg: 	a PluggableTextMorph(570949632)
		thirdArg: 	[keystroke '<Cmd-i>']
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	182
		numArgs: 	1


KMCategoryBinding>>completeMatch:buffer:
	Receiver: aKMCategoryTarget(#SmalltalkEditor)
	Arguments and temporary variables: 
		aKeymap: 	#inspectIt on Cmd + I do [ :morph | morph inspectIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
	Receiver's instance variables: 
		target: 	a PluggableTextMorph(570949632)
		category: 	a KMCategory
		morph: 	a PluggableTextMorph(570949632)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #inspectIt on Cmd + I do [ :morph | morph inspectIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		l: 	aKMCategoryTarget(#SmalltalkEditor)
	Receiver's instance variables: 
		action: 	[ :morph | morph inspectIt ]
		name: 	#inspectIt
		shortcut: 	Cmd + I
		defaultShortcut: 	Cmd + I
		description: 	''


Array(SequenceableCollection)>>do:
	Receiver: an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #inspectIt on Cmd + I do [ :morph | morph inspectIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ :morph | morph inspectIt ]
		name: 	#inspectIt
		shortcut: 	Cmd + I
		defaultShortcut: 	Cmd + I
		description: 	''


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: #inspectIt on Cmd + I do [ :morph | morph inspectIt ]

	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		action: 	[ :morph | morph inspectIt ]
		name: 	#inspectIt
		shortcut: 	Cmd + I
		defaultShortcut: 	Cmd + I
		description: 	''


[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#inspectIt on Cmd + I do [ :morph | morph inspectIt ]

	Receiver's instance variables: 
		name: 	#SmalltalkEditor
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


Set>>do:
	Receiver: a Set(#printIt on Cmd + P do [ :morph | morph printIt ]
 #previousSelection on Cmd + Shift...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	13
		each: 	#inspectIt on Cmd + I do [ :morph | morph inspectIt ]

	Receiver's instance variables: 
		tally: 	14
		array: 	an Array(#printIt on Cmd + P do [ :morph | morph printIt ]
 #previousSel...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
	Receiver's instance variables: 
		name: 	#SmalltalkEditor
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: aKMCategoryTarget(#SmalltalkEditor)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		target: 	a PluggableTextMorph(570949632)
		category: 	a KMCategory
		morph: 	a PluggableTextMorph(570949632)


[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#SmalltalkEditor)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#SmalltalkEditor) aKMCategoryTarget(#TextMorph...etc...
		morph: 	a PluggableTextMorph(570949632)
		directKeymaps: 	a KMCategory



--- The full stack ---
LOGame(Object)>>doesNotUnderstand: #cellsPerSide
Message>>sentTo:
LOGame(Object)>>doesNotUnderstand: #cellsPerSide
Message>>sentTo:
LOGame(Object)>>doesNotUnderstand: #cellsPerSide
Message>>sentTo:
LOGame(Object)>>doesNotUnderstand: #cellsPerSide
Message>>sentTo:
LOGame(Object)>>doesNotUnderstand: #cellsPerSide
Message>>sentTo:
LOGame(Object)>>doesNotUnderstand: #cellsPerSide
Message>>sentTo:
LOGame(Object)>>doesNotUnderstand: #cellsPerSide
Message>>sentTo:
LOGame(Object)>>doesNotUnderstand: #cellsPerSide
LOGame>>initialize
LOGame class(Behavior)>>new
UndefinedObject>>DoIt
OpalCompiler>>evaluate
SmalltalkEditor>>evaluateSelectionAndDo:
[ textMorph editor evaluateSelectionAndDo: [ :result | result inspect ] ] in PluggableTextMorph>>inspectIt
[ result := editBlock value ] in PluggableTextMorph>>handleEdit:
TextMorphForEditView(TextMorph)>>handleEdit:
PluggableTextMorph>>handleEdit:
PluggableTextMorph>>inspectIt
[ :morph | morph inspectIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
TextMorphForEditView(TextMorph)>>handleKeystroke:
KeyboardEvent>>sentTo:
TextMorphForEditView(Morph)>>handleEvent:
TextMorphForEditView(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: LOGame>>cellsPerSide
16 October 2014 4:12:44.290869 pm

VM: Mac OS - intel - 1090 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30858]

LOGame(Object)>>doesNotUnderstand: #cellsPerSide
	Receiver: a LOGame(1052770304)
	Arguments and temporary variables: 
		aMessage: 	cellsPerSide
		exception: 	MessageNotUnderstood: LOGame>>cellsPerSide
		resumeValue: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (50@40)
		owner: 	nil
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	nil
		borderWidth: 	2
		borderColor: 	Color black
		cells: 	nil


Message>>sentTo:
	Receiver: cellsPerSide
	Arguments and temporary variables: 
		receiver: 	a LOGame(1052770304)
	Receiver's instance variables: 
		selector: 	#cellsPerSide
		args: 	#()
		lookupClass: 	LOGame


LOGame(Object)>>doesNotUnderstand: #cellsPerSide
	Receiver: a LOGame(1052770304)
	Arguments and temporary variables: 
		aMessage: 	cellsPerSide
		exception: 	MessageNotUnderstood: LOGame>>cellsPerSide
		resumeValue: 	MessageNotUnderstood: LOGame>>cellsPerSide
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (50@40)
		owner: 	nil
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	nil
		borderWidth: 	2
		borderColor: 	Color black
		cells: 	nil


Message>>sentTo:
	Receiver: cellsPerSide
	Arguments and temporary variables: 
		receiver: 	a LOGame(1052770304)
	Receiver's instance variables: 
		selector: 	#cellsPerSide
		args: 	#()
		lookupClass: 	LOGame


LOGame(Object)>>doesNotUnderstand: #cellsPerSide
	Receiver: a LOGame(1052770304)
	Arguments and temporary variables: 
		aMessage: 	cellsPerSide
		exception: 	MessageNotUnderstood: LOGame>>cellsPerSide
		resumeValue: 	MessageNotUnderstood: LOGame>>cellsPerSide
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (50@40)
		owner: 	nil
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	nil
		borderWidth: 	2
		borderColor: 	Color black
		cells: 	nil


Message>>sentTo:
	Receiver: cellsPerSide
	Arguments and temporary variables: 
		receiver: 	a LOGame(1052770304)
	Receiver's instance variables: 
		selector: 	#cellsPerSide
		args: 	#()
		lookupClass: 	LOGame


LOGame(Object)>>doesNotUnderstand: #cellsPerSide
	Receiver: a LOGame(1052770304)
	Arguments and temporary variables: 
		aMessage: 	cellsPerSide
		exception: 	MessageNotUnderstood: LOGame>>cellsPerSide
		resumeValue: 	MessageNotUnderstood: LOGame>>cellsPerSide
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (50@40)
		owner: 	nil
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	nil
		borderWidth: 	2
		borderColor: 	Color black
		cells: 	nil


Message>>sentTo:
	Receiver: cellsPerSide
	Arguments and temporary variables: 
		receiver: 	a LOGame(1052770304)
	Receiver's instance variables: 
		selector: 	#cellsPerSide
		args: 	#()
		lookupClass: 	LOGame


LOGame(Object)>>doesNotUnderstand: #cellsPerSide
	Receiver: a LOGame(1052770304)
	Arguments and temporary variables: 
		aMessage: 	cellsPerSide
		exception: 	MessageNotUnderstood: LOGame>>cellsPerSide
		resumeValue: 	MessageNotUnderstood: LOGame>>cellsPerSide
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (50@40)
		owner: 	nil
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	nil
		borderWidth: 	2
		borderColor: 	Color black
		cells: 	nil


Message>>sentTo:
	Receiver: cellsPerSide
	Arguments and temporary variables: 
		receiver: 	a LOGame(1052770304)
	Receiver's instance variables: 
		selector: 	#cellsPerSide
		args: 	#()
		lookupClass: 	LOGame


LOGame(Object)>>doesNotUnderstand: #cellsPerSide
	Receiver: a LOGame(1052770304)
	Arguments and temporary variables: 
		aMessage: 	cellsPerSide
		exception: 	MessageNotUnderstood: LOGame>>cellsPerSide
		resumeValue: 	MessageNotUnderstood: LOGame>>cellsPerSide
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (50@40)
		owner: 	nil
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	nil
		borderWidth: 	2
		borderColor: 	Color black
		cells: 	nil


Message>>sentTo:
	Receiver: cellsPerSide
	Arguments and temporary variables: 
		receiver: 	a LOGame(1052770304)
	Receiver's instance variables: 
		selector: 	#cellsPerSide
		args: 	#()
		lookupClass: 	LOGame


LOGame(Object)>>doesNotUnderstand: #cellsPerSide
	Receiver: a LOGame(1052770304)
	Arguments and temporary variables: 
		aMessage: 	cellsPerSide
		exception: 	MessageNotUnderstood: LOGame>>cellsPerSide
		resumeValue: 	MessageNotUnderstood: LOGame>>cellsPerSide
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (50@40)
		owner: 	nil
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	nil
		borderWidth: 	2
		borderColor: 	Color black
		cells: 	nil


Message>>sentTo:
	Receiver: cellsPerSide
	Arguments and temporary variables: 
		receiver: 	a LOGame(1052770304)
	Receiver's instance variables: 
		selector: 	#cellsPerSide
		args: 	#()
		lookupClass: 	LOGame


LOGame(Object)>>doesNotUnderstand: #cellsPerSide
	Receiver: a LOGame(1052770304)
	Arguments and temporary variables: 
		aMessage: 	cellsPerSide
		exception: 	MessageNotUnderstood: LOGame>>cellsPerSide
		resumeValue: 	MessageNotUnderstood: LOGame>>cellsPerSide
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (50@40)
		owner: 	nil
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	nil
		borderWidth: 	2
		borderColor: 	Color black
		cells: 	nil


Message>>sentTo:
	Receiver: cellsPerSide
	Arguments and temporary variables: 
		receiver: 	a LOGame(1052770304)
	Receiver's instance variables: 
		selector: 	#cellsPerSide
		args: 	#()
		lookupClass: 	LOGame


LOGame(Object)>>doesNotUnderstand: #cellsPerSide
	Receiver: a LOGame(1052770304)
	Arguments and temporary variables: 
		aMessage: 	cellsPerSide
		exception: 	MessageNotUnderstood: LOGame>>cellsPerSide
		resumeValue: 	MessageNotUnderstood: LOGame>>cellsPerSide
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (50@40)
		owner: 	nil
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	nil
		borderWidth: 	2
		borderColor: 	Color black
		cells: 	nil


LOGame>>initialize
	Receiver: a LOGame(1052770304)
	Arguments and temporary variables: 
		sampleCell: 	nil
		width: 	nil
		height: 	nil
		n: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (50@40)
		owner: 	nil
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	nil
		borderWidth: 	2
		borderColor: 	Color black
		cells: 	nil


LOGame class(Behavior)>>new
	Receiver: LOGame
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	BorderedMorph
		methodDict: 	a MethodDictionary(#initialize->LOGame>>#initialize )
		format: 	148
		layout: 	a FixedLayout
		instanceVariables: 	#(#cells)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#LOGame
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'PBE-LightsOut'
		traitComposition: 	{}
		localSelectors: 	nil
		announcer: 	nil


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'LOGame new'
		itsSelection: 	a Text for 'LOGame new'
		itsSelectionString: 	'LOGame new'
	Receiver's instance variables: 
		ast: 	DoIt
	^ LOGame new
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


SmalltalkEditor>>evaluateSelectionAndDo:
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | result inspect ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(381419520)
		selectionShowing: 	true
		model: 	a Workspace
		editingState: 	a SmalltalkEditingState


[ textMorph editor evaluateSelectionAndDo: [ :result | result inspect ] ] in PluggableTextMorph>>inspectIt
	Receiver: a PluggableTextMorph(570949632)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(488.0@523.0) corner: (928.0@690.0)
		owner: 	a SystemWindow(481034240)
		submorphs: 	an Array(a TransformMorph(508559360))
		fullBounds: 	(488@523) corner: (928@690)
		color: 	Color white
		extension: 	a MorphExtension (360185856) [locked]  [other:  (kmDispatcher -> a K...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(610795520)
		scroller: 	a TransformMorph(508559360)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(526123008)
		textMorph: 	a TextMorphForEditView(381419520)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 10)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


[ result := editBlock value ] in PluggableTextMorph>>handleEdit:
	Receiver: a PluggableTextMorph(570949632)
	Arguments and temporary variables: 
		editBlock: 	[ textMorph editor evaluateSelectionAndDo: [ :result | result inspec...etc...
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(488.0@523.0) corner: (928.0@690.0)
		owner: 	a SystemWindow(481034240)
		submorphs: 	an Array(a TransformMorph(508559360))
		fullBounds: 	(488@523) corner: (928@690)
		color: 	Color white
		extension: 	a MorphExtension (360185856) [locked]  [other:  (kmDispatcher -> a K...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(610795520)
		scroller: 	a TransformMorph(508559360)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(526123008)
		textMorph: 	a TextMorphForEditView(381419520)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 10)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


TextMorphForEditView(TextMorph)>>handleEdit:
	Receiver: a TextMorphForEditView(381419520)
	Arguments and temporary variables: 
		editBlock: 	[ result := editBlock value ]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@18)
		owner: 	a TransformMorph(508559360)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@18)
		color: 	Color black
		extension: 	a MorphExtension (436207616) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'LOGame new'
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(570949632)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


PluggableTextMorph>>handleEdit:
	Receiver: a PluggableTextMorph(570949632)
	Arguments and temporary variables: 
		result: 	nil
		editBlock: 	[ textMorph editor evaluateSelectionAndDo: [ :result | result inspec...etc...
	Receiver's instance variables: 
		bounds: 	(488.0@523.0) corner: (928.0@690.0)
		owner: 	a SystemWindow(481034240)
		submorphs: 	an Array(a TransformMorph(508559360))
		fullBounds: 	(488@523) corner: (928@690)
		color: 	Color white
		extension: 	a MorphExtension (360185856) [locked]  [other:  (kmDispatcher -> a K...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(610795520)
		scroller: 	a TransformMorph(508559360)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(526123008)
		textMorph: 	a TextMorphForEditView(381419520)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 10)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


PluggableTextMorph>>inspectIt
	Receiver: a PluggableTextMorph(570949632)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(488.0@523.0) corner: (928.0@690.0)
		owner: 	a SystemWindow(481034240)
		submorphs: 	an Array(a TransformMorph(508559360))
		fullBounds: 	(488@523) corner: (928@690)
		color: 	Color white
		extension: 	a MorphExtension (360185856) [locked]  [other:  (kmDispatcher -> a K...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(610795520)
		scroller: 	a TransformMorph(508559360)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(526123008)
		textMorph: 	a TextMorphForEditView(381419520)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 10)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


[ :morph | morph inspectIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
	Receiver: SmalltalkEditor
	Arguments and temporary variables: 
		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a PluggableTextMorph(570949632)
	Receiver's instance variables: 
		superclass: 	TextEditor
		methodDict: 	a MethodDictionary(#argAdvance:->SmalltalkEditor>>#argAdvance: #bro...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SmalltalkEditor
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Text-Edition'
		traitComposition: 	{}
		localSelectors: 	nil
		cmdActions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop...etc...
		shiftCmdActions: 	#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #m...etc...


BlockClosure>>cull:
	Receiver: [ :morph | morph inspectIt ]
	Arguments and temporary variables: 
		anArg: 	a PluggableTextMorph(570949632)
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	182
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :morph | morph inspectIt ]
	Arguments and temporary variables: 
		firstArg: 	a PluggableTextMorph(570949632)
		secondArg: 	a PluggableTextMorph(570949632)
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	182
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :morph | morph inspectIt ]
	Arguments and temporary variables: 
		firstArg: 	a PluggableTextMorph(570949632)
		secondArg: 	a PluggableTextMorph(570949632)
		thirdArg: 	[keystroke '<Cmd-i>']
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	182
		numArgs: 	1


KMCategoryBinding>>completeMatch:buffer:
	Receiver: aKMCategoryTarget(#SmalltalkEditor)
	Arguments and temporary variables: 
		aKeymap: 	#inspectIt on Cmd + I do [ :morph | morph inspectIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
	Receiver's instance variables: 
		target: 	a PluggableTextMorph(570949632)
		category: 	a KMCategory
		morph: 	a PluggableTextMorph(570949632)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #inspectIt on Cmd + I do [ :morph | morph inspectIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		l: 	aKMCategoryTarget(#SmalltalkEditor)
	Receiver's instance variables: 
		action: 	[ :morph | morph inspectIt ]
		name: 	#inspectIt
		shortcut: 	Cmd + I
		defaultShortcut: 	Cmd + I
		description: 	''


Array(SequenceableCollection)>>do:
	Receiver: an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #inspectIt on Cmd + I do [ :morph | morph inspectIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ :morph | morph inspectIt ]
		name: 	#inspectIt
		shortcut: 	Cmd + I
		defaultShortcut: 	Cmd + I
		description: 	''


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: #inspectIt on Cmd + I do [ :morph | morph inspectIt ]

	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		action: 	[ :morph | morph inspectIt ]
		name: 	#inspectIt
		shortcut: 	Cmd + I
		defaultShortcut: 	Cmd + I
		description: 	''


[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#inspectIt on Cmd + I do [ :morph | morph inspectIt ]

	Receiver's instance variables: 
		name: 	#SmalltalkEditor
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


Set>>do:
	Receiver: a Set(#printIt on Cmd + P do [ :morph | morph printIt ]
 #previousSelection on Cmd + Shift...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	13
		each: 	#inspectIt on Cmd + I do [ :morph | morph inspectIt ]

	Receiver's instance variables: 
		tally: 	14
		array: 	an Array(#printIt on Cmd + P do [ :morph | morph printIt ]
 #previousSel...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
	Receiver's instance variables: 
		name: 	#SmalltalkEditor
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...



--- The full stack ---
LOGame(Object)>>doesNotUnderstand: #cellsPerSide
Message>>sentTo:
LOGame(Object)>>doesNotUnderstand: #cellsPerSide
Message>>sentTo:
LOGame(Object)>>doesNotUnderstand: #cellsPerSide
Message>>sentTo:
LOGame(Object)>>doesNotUnderstand: #cellsPerSide
Message>>sentTo:
LOGame(Object)>>doesNotUnderstand: #cellsPerSide
Message>>sentTo:
LOGame(Object)>>doesNotUnderstand: #cellsPerSide
Message>>sentTo:
LOGame(Object)>>doesNotUnderstand: #cellsPerSide
Message>>sentTo:
LOGame(Object)>>doesNotUnderstand: #cellsPerSide
Message>>sentTo:
LOGame(Object)>>doesNotUnderstand: #cellsPerSide
LOGame>>initialize
LOGame class(Behavior)>>new
UndefinedObject>>DoIt
OpalCompiler>>evaluate
SmalltalkEditor>>evaluateSelectionAndDo:
[ textMorph editor evaluateSelectionAndDo: [ :result | result inspect ] ] in PluggableTextMorph>>inspectIt
[ result := editBlock value ] in PluggableTextMorph>>handleEdit:
TextMorphForEditView(TextMorph)>>handleEdit:
PluggableTextMorph>>handleEdit:
PluggableTextMorph>>inspectIt
[ :morph | morph inspectIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
TextMorphForEditView(TextMorph)>>handleKeystroke:
KeyboardEvent>>sentTo:
TextMorphForEditView(Morph)>>handleEvent:
TextMorphForEditView(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: LOGame>>cellsPerSide
16 October 2014 4:12:47.152321 pm

VM: Mac OS - intel - 1090 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30858]

LOGame(Object)>>doesNotUnderstand: #cellsPerSide
	Receiver: a LOGame(483131392)
	Arguments and temporary variables: 
		aMessage: 	cellsPerSide
		exception: 	MessageNotUnderstood: LOGame>>cellsPerSide
		resumeValue: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (50@40)
		owner: 	nil
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	nil
		borderWidth: 	2
		borderColor: 	Color black
		cells: 	nil


LOGame>>initialize
	Receiver: a LOGame(483131392)
	Arguments and temporary variables: 
		sampleCell: 	nil
		width: 	nil
		height: 	nil
		n: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (50@40)
		owner: 	nil
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	nil
		borderWidth: 	2
		borderColor: 	Color black
		cells: 	nil


LOGame class(Behavior)>>new
	Receiver: LOGame
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	BorderedMorph
		methodDict: 	a MethodDictionary(#initialize->LOGame>>#initialize )
		format: 	148
		layout: 	a FixedLayout
		instanceVariables: 	#(#cells)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#LOGame
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'PBE-LightsOut'
		traitComposition: 	{}
		localSelectors: 	nil
		announcer: 	nil


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'LOGame new'
		itsSelection: 	a Text for 'LOGame new'
		itsSelectionString: 	'LOGame new'
	Receiver's instance variables: 
		ast: 	DoIt
	^ LOGame new
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


SmalltalkEditor>>evaluateSelectionAndDo:
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | result inspect ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(381419520)
		selectionShowing: 	true
		model: 	a Workspace
		editingState: 	a SmalltalkEditingState


[ textMorph editor evaluateSelectionAndDo: [ :result | result inspect ] ] in PluggableTextMorph>>inspectIt
	Receiver: a PluggableTextMorph(570949632)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(488.0@523.0) corner: (928.0@690.0)
		owner: 	a SystemWindow(481034240)
		submorphs: 	an Array(a TransformMorph(508559360))
		fullBounds: 	(488@523) corner: (928@690)
		color: 	Color white
		extension: 	a MorphExtension (360185856) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(610795520)
		scroller: 	a TransformMorph(508559360)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(526123008)
		textMorph: 	a TextMorphForEditView(381419520)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 10)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


[ result := editBlock value ] in PluggableTextMorph>>handleEdit:
	Receiver: a PluggableTextMorph(570949632)
	Arguments and temporary variables: 
		editBlock: 	[ textMorph editor evaluateSelectionAndDo: [ :result | result inspec...etc...
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(488.0@523.0) corner: (928.0@690.0)
		owner: 	a SystemWindow(481034240)
		submorphs: 	an Array(a TransformMorph(508559360))
		fullBounds: 	(488@523) corner: (928@690)
		color: 	Color white
		extension: 	a MorphExtension (360185856) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(610795520)
		scroller: 	a TransformMorph(508559360)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(526123008)
		textMorph: 	a TextMorphForEditView(381419520)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 10)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


TextMorphForEditView(TextMorph)>>handleEdit:
	Receiver: a TextMorphForEditView(381419520)
	Arguments and temporary variables: 
		editBlock: 	[ result := editBlock value ]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@18)
		owner: 	a TransformMorph(508559360)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@18)
		color: 	Color black
		extension: 	a MorphExtension (436207616) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'LOGame new'
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(570949632)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


PluggableTextMorph>>handleEdit:
	Receiver: a PluggableTextMorph(570949632)
	Arguments and temporary variables: 
		result: 	nil
		editBlock: 	[ textMorph editor evaluateSelectionAndDo: [ :result | result inspec...etc...
	Receiver's instance variables: 
		bounds: 	(488.0@523.0) corner: (928.0@690.0)
		owner: 	a SystemWindow(481034240)
		submorphs: 	an Array(a TransformMorph(508559360))
		fullBounds: 	(488@523) corner: (928@690)
		color: 	Color white
		extension: 	a MorphExtension (360185856) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(610795520)
		scroller: 	a TransformMorph(508559360)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(526123008)
		textMorph: 	a TextMorphForEditView(381419520)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 10)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


PluggableTextMorph>>inspectIt
	Receiver: a PluggableTextMorph(570949632)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(488.0@523.0) corner: (928.0@690.0)
		owner: 	a SystemWindow(481034240)
		submorphs: 	an Array(a TransformMorph(508559360))
		fullBounds: 	(488@523) corner: (928@690)
		color: 	Color white
		extension: 	a MorphExtension (360185856) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(610795520)
		scroller: 	a TransformMorph(508559360)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(526123008)
		textMorph: 	a TextMorphForEditView(381419520)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 10)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


[ :morph | morph inspectIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
	Receiver: SmalltalkEditor
	Arguments and temporary variables: 
		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a PluggableTextMorph(570949632)
	Receiver's instance variables: 
		superclass: 	TextEditor
		methodDict: 	a MethodDictionary(#argAdvance:->SmalltalkEditor>>#argAdvance: #bro...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SmalltalkEditor
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Text-Edition'
		traitComposition: 	{}
		localSelectors: 	nil
		cmdActions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop...etc...
		shiftCmdActions: 	#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #m...etc...


BlockClosure>>cull:
	Receiver: [ :morph | morph inspectIt ]
	Arguments and temporary variables: 
		anArg: 	a PluggableTextMorph(570949632)
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	182
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :morph | morph inspectIt ]
	Arguments and temporary variables: 
		firstArg: 	a PluggableTextMorph(570949632)
		secondArg: 	a PluggableTextMorph(570949632)
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	182
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :morph | morph inspectIt ]
	Arguments and temporary variables: 
		firstArg: 	a PluggableTextMorph(570949632)
		secondArg: 	a PluggableTextMorph(570949632)
		thirdArg: 	[keystroke '<Cmd-i>']
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	182
		numArgs: 	1


KMCategoryBinding>>completeMatch:buffer:
	Receiver: aKMCategoryTarget(#SmalltalkEditor)
	Arguments and temporary variables: 
		aKeymap: 	#inspectIt on Cmd + I do [ :morph | morph inspectIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
	Receiver's instance variables: 
		target: 	a PluggableTextMorph(570949632)
		category: 	a KMCategory
		morph: 	a PluggableTextMorph(570949632)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #inspectIt on Cmd + I do [ :morph | morph inspectIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		l: 	aKMCategoryTarget(#SmalltalkEditor)
	Receiver's instance variables: 
		action: 	[ :morph | morph inspectIt ]
		name: 	#inspectIt
		shortcut: 	Cmd + I
		defaultShortcut: 	Cmd + I
		description: 	''


Array(SequenceableCollection)>>do:
	Receiver: an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #inspectIt on Cmd + I do [ :morph | morph inspectIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ :morph | morph inspectIt ]
		name: 	#inspectIt
		shortcut: 	Cmd + I
		defaultShortcut: 	Cmd + I
		description: 	''


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: #inspectIt on Cmd + I do [ :morph | morph inspectIt ]

	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		action: 	[ :morph | morph inspectIt ]
		name: 	#inspectIt
		shortcut: 	Cmd + I
		defaultShortcut: 	Cmd + I
		description: 	''


[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#inspectIt on Cmd + I do [ :morph | morph inspectIt ]

	Receiver's instance variables: 
		name: 	#SmalltalkEditor
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


Set>>do:
	Receiver: a Set(#printIt on Cmd + P do [ :morph | morph printIt ]
 #previousSelection on Cmd + Shift...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	13
		each: 	#inspectIt on Cmd + I do [ :morph | morph inspectIt ]

	Receiver's instance variables: 
		tally: 	14
		array: 	an Array(#printIt on Cmd + P do [ :morph | morph printIt ]
 #previousSel...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
	Receiver's instance variables: 
		name: 	#SmalltalkEditor
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: aKMCategoryTarget(#SmalltalkEditor)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		target: 	a PluggableTextMorph(570949632)
		category: 	a KMCategory
		morph: 	a PluggableTextMorph(570949632)


[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#SmalltalkEditor)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#SmalltalkEditor) aKMCategoryTarget(#TextMorph...etc...
		morph: 	a PluggableTextMorph(570949632)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#SmalltalkEditor) aKMCategor...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	2
	Receiver's instance variables: 
		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#SmalltalkEditor) aKMC...etc...
		firstIndex: 	1
		lastIndex: 	7


KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		association: 	nil
		match: 	nil
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#SmalltalkEditor) aKMCategoryTarget(#TextMorph...etc...
		morph: 	a PluggableTextMorph(570949632)
		directKeymaps: 	a KMCategory


KMTarget>>dispatch:
	Receiver: a KMTarget
	Arguments and temporary variables: 
		buffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
	Receiver's instance variables: 
		realTarget: 	nil
		morph: 	a PluggableTextMorph(570949632)
		targetSelector: 	#yourself
		directKeymaps: 	nil
		perInstanceCategories: 	nil


[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Cmd-i>']
		targetToDispatch: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>do:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Cmd-i>']
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatcher>>dispatchKeystroke:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		aKeyEvent: 	[keystroke '<Cmd-i>']
		chain: 	a KMDispatchChain
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#MorphFocusCtrlN...etc...
		morph: 	a TextMorphForEditView(381419520)
		directKeymaps: 	a KMCategory


TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
	Receiver: a TextMorphForEditView(381419520)
	Arguments and temporary variables: 
		evt: 	[keystroke '<Cmd-i>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@18)
		owner: 	a TransformMorph(508559360)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@18)
		color: 	Color black
		extension: 	a MorphExtension (436207616) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'LOGame new'
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(570949632)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(TextMorph)>>handleKeystroke:
	Receiver: a TextMorphForEditView(381419520)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-i>']
		pasteUp: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@18)
		owner: 	a TransformMorph(508559360)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@18)
		color: 	Color black
		extension: 	a MorphExtension (436207616) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'LOGame new'
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(570949632)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


KeyboardEvent>>sentTo:
	Receiver: [keystroke '<Cmd-i>']
	Arguments and temporary variables: 
		anObject: 	a TextMorphForEditView(381419520)
	Receiver's instance variables: 
		timeStamp: 	835342
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#keystroke
		buttons: 	64
		position: 	(142.0@5.0)
		handler: 	nil
		wasHandled: 	true
		keyValue: 	105
		charCode: 	105
		scanCode: 	34


TextMorphForEditView(Morph)>>handleEvent:
	Receiver: a TextMorphForEditView(381419520)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-i>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@18)
		owner: 	a TransformMorph(508559360)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@18)
		color: 	Color black
		extension: 	a MorphExtension (436207616) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'LOGame new'
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(570949632)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(Morph)>>handleFocusEvent:
	Receiver: a TextMorphForEditView(381419520)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-i>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@18)
		owner: 	a TransformMorph(508559360)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@18)
		color: 	Color black
		extension: 	a MorphExtension (436207616) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'LOGame new'
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(570949632)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-i>']
		focusHolder: 	a TextMorphForEditView(381419520)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(626@520.0) corner: (642@536.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(626@520.0) corner: (642@536.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a TextMorphForEditView(381419520)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(634@529) mouseOver nil nil]
		targetOffset: 	(9.0@9.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	Form(16x16x8)
		temporaryCursorOffset: 	(-8@ -9)
		hardwareCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r...etc...
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 834122 634 529 0 0 0 1)
		lastKeyScanCode: 	34
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	8


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0



--- The full stack ---
LOGame(Object)>>doesNotUnderstand: #cellsPerSide
LOGame>>initialize
LOGame class(Behavior)>>new
UndefinedObject>>DoIt
OpalCompiler>>evaluate
SmalltalkEditor>>evaluateSelectionAndDo:
[ textMorph editor evaluateSelectionAndDo: [ :result | result inspect ] ] in PluggableTextMorph>>inspectIt
[ result := editBlock value ] in PluggableTextMorph>>handleEdit:
TextMorphForEditView(TextMorph)>>handleEdit:
PluggableTextMorph>>handleEdit:
PluggableTextMorph>>inspectIt
[ :morph | morph inspectIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
TextMorphForEditView(TextMorph)>>handleKeystroke:
KeyboardEvent>>sentTo:
TextMorphForEditView(Morph)>>handleEvent:
TextMorphForEditView(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: LOGame>>cellsPerSide
16 October 2014 4:12:48.400287 pm

VM: Mac OS - intel - 1090 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30858]

LOGame(Object)>>doesNotUnderstand: #cellsPerSide
	Receiver: a LOGame(483131392)
	Arguments and temporary variables: 
		aMessage: 	cellsPerSide
		exception: 	MessageNotUnderstood: LOGame>>cellsPerSide
		resumeValue: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (50@40)
		owner: 	nil
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	nil
		borderWidth: 	2
		borderColor: 	Color black
		cells: 	nil


Message>>sentTo:
	Receiver: cellsPerSide
	Arguments and temporary variables: 
		receiver: 	a LOGame(483131392)
	Receiver's instance variables: 
		selector: 	#cellsPerSide
		args: 	#()
		lookupClass: 	LOGame


LOGame(Object)>>doesNotUnderstand: #cellsPerSide
	Receiver: a LOGame(483131392)
	Arguments and temporary variables: 
		aMessage: 	cellsPerSide
		exception: 	MessageNotUnderstood: LOGame>>cellsPerSide
		resumeValue: 	MessageNotUnderstood: LOGame>>cellsPerSide
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (50@40)
		owner: 	nil
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	nil
		borderWidth: 	2
		borderColor: 	Color black
		cells: 	nil


LOGame>>initialize
	Receiver: a LOGame(483131392)
	Arguments and temporary variables: 
		sampleCell: 	nil
		width: 	nil
		height: 	nil
		n: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (50@40)
		owner: 	nil
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	nil
		borderWidth: 	2
		borderColor: 	Color black
		cells: 	nil


LOGame class(Behavior)>>new
	Receiver: LOGame
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	BorderedMorph
		methodDict: 	a MethodDictionary(#initialize->LOGame>>#initialize )
		format: 	148
		layout: 	a FixedLayout
		instanceVariables: 	#(#cells)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#LOGame
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'PBE-LightsOut'
		traitComposition: 	{}
		localSelectors: 	nil
		announcer: 	nil


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'LOGame new'
		itsSelection: 	a Text for 'LOGame new'
		itsSelectionString: 	'LOGame new'
	Receiver's instance variables: 
		ast: 	DoIt
	^ LOGame new
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


SmalltalkEditor>>evaluateSelectionAndDo:
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | result inspect ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(381419520)
		selectionShowing: 	true
		model: 	a Workspace
		editingState: 	a SmalltalkEditingState


[ textMorph editor evaluateSelectionAndDo: [ :result | result inspect ] ] in PluggableTextMorph>>inspectIt
	Receiver: a PluggableTextMorph(570949632)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(488.0@523.0) corner: (928.0@690.0)
		owner: 	a SystemWindow(481034240)
		submorphs: 	an Array(a TransformMorph(508559360))
		fullBounds: 	(488@523) corner: (928@690)
		color: 	Color white
		extension: 	a MorphExtension (360185856) [locked]  [other:  (kmDispatcher -> a K...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(610795520)
		scroller: 	a TransformMorph(508559360)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(526123008)
		textMorph: 	a TextMorphForEditView(381419520)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 10)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


[ result := editBlock value ] in PluggableTextMorph>>handleEdit:
	Receiver: a PluggableTextMorph(570949632)
	Arguments and temporary variables: 
		editBlock: 	[ textMorph editor evaluateSelectionAndDo: [ :result | result inspec...etc...
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(488.0@523.0) corner: (928.0@690.0)
		owner: 	a SystemWindow(481034240)
		submorphs: 	an Array(a TransformMorph(508559360))
		fullBounds: 	(488@523) corner: (928@690)
		color: 	Color white
		extension: 	a MorphExtension (360185856) [locked]  [other:  (kmDispatcher -> a K...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(610795520)
		scroller: 	a TransformMorph(508559360)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(526123008)
		textMorph: 	a TextMorphForEditView(381419520)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 10)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


TextMorphForEditView(TextMorph)>>handleEdit:
	Receiver: a TextMorphForEditView(381419520)
	Arguments and temporary variables: 
		editBlock: 	[ result := editBlock value ]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@18)
		owner: 	a TransformMorph(508559360)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@18)
		color: 	Color black
		extension: 	a MorphExtension (436207616) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'LOGame new'
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(570949632)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


PluggableTextMorph>>handleEdit:
	Receiver: a PluggableTextMorph(570949632)
	Arguments and temporary variables: 
		result: 	nil
		editBlock: 	[ textMorph editor evaluateSelectionAndDo: [ :result | result inspec...etc...
	Receiver's instance variables: 
		bounds: 	(488.0@523.0) corner: (928.0@690.0)
		owner: 	a SystemWindow(481034240)
		submorphs: 	an Array(a TransformMorph(508559360))
		fullBounds: 	(488@523) corner: (928@690)
		color: 	Color white
		extension: 	a MorphExtension (360185856) [locked]  [other:  (kmDispatcher -> a K...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(610795520)
		scroller: 	a TransformMorph(508559360)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(526123008)
		textMorph: 	a TextMorphForEditView(381419520)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 10)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


PluggableTextMorph>>inspectIt
	Receiver: a PluggableTextMorph(570949632)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(488.0@523.0) corner: (928.0@690.0)
		owner: 	a SystemWindow(481034240)
		submorphs: 	an Array(a TransformMorph(508559360))
		fullBounds: 	(488@523) corner: (928@690)
		color: 	Color white
		extension: 	a MorphExtension (360185856) [locked]  [other:  (kmDispatcher -> a K...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(610795520)
		scroller: 	a TransformMorph(508559360)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(526123008)
		textMorph: 	a TextMorphForEditView(381419520)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 10)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


[ :morph | morph inspectIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
	Receiver: SmalltalkEditor
	Arguments and temporary variables: 
		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a PluggableTextMorph(570949632)
	Receiver's instance variables: 
		superclass: 	TextEditor
		methodDict: 	a MethodDictionary(#argAdvance:->SmalltalkEditor>>#argAdvance: #bro...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SmalltalkEditor
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Text-Edition'
		traitComposition: 	{}
		localSelectors: 	nil
		cmdActions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop...etc...
		shiftCmdActions: 	#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #m...etc...


BlockClosure>>cull:
	Receiver: [ :morph | morph inspectIt ]
	Arguments and temporary variables: 
		anArg: 	a PluggableTextMorph(570949632)
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	182
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :morph | morph inspectIt ]
	Arguments and temporary variables: 
		firstArg: 	a PluggableTextMorph(570949632)
		secondArg: 	a PluggableTextMorph(570949632)
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	182
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :morph | morph inspectIt ]
	Arguments and temporary variables: 
		firstArg: 	a PluggableTextMorph(570949632)
		secondArg: 	a PluggableTextMorph(570949632)
		thirdArg: 	[keystroke '<Cmd-i>']
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	182
		numArgs: 	1


KMCategoryBinding>>completeMatch:buffer:
	Receiver: aKMCategoryTarget(#SmalltalkEditor)
	Arguments and temporary variables: 
		aKeymap: 	#inspectIt on Cmd + I do [ :morph | morph inspectIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
	Receiver's instance variables: 
		target: 	a PluggableTextMorph(570949632)
		category: 	a KMCategory
		morph: 	a PluggableTextMorph(570949632)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #inspectIt on Cmd + I do [ :morph | morph inspectIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		l: 	aKMCategoryTarget(#SmalltalkEditor)
	Receiver's instance variables: 
		action: 	[ :morph | morph inspectIt ]
		name: 	#inspectIt
		shortcut: 	Cmd + I
		defaultShortcut: 	Cmd + I
		description: 	''


Array(SequenceableCollection)>>do:
	Receiver: an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #inspectIt on Cmd + I do [ :morph | morph inspectIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ :morph | morph inspectIt ]
		name: 	#inspectIt
		shortcut: 	Cmd + I
		defaultShortcut: 	Cmd + I
		description: 	''


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: #inspectIt on Cmd + I do [ :morph | morph inspectIt ]

	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		action: 	[ :morph | morph inspectIt ]
		name: 	#inspectIt
		shortcut: 	Cmd + I
		defaultShortcut: 	Cmd + I
		description: 	''


[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#inspectIt on Cmd + I do [ :morph | morph inspectIt ]

	Receiver's instance variables: 
		name: 	#SmalltalkEditor
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


Set>>do:
	Receiver: a Set(#printIt on Cmd + P do [ :morph | morph printIt ]
 #previousSelection on Cmd + Shift...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	13
		each: 	#inspectIt on Cmd + I do [ :morph | morph inspectIt ]

	Receiver's instance variables: 
		tally: 	14
		array: 	an Array(#printIt on Cmd + P do [ :morph | morph printIt ]
 #previousSel...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
	Receiver's instance variables: 
		name: 	#SmalltalkEditor
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: aKMCategoryTarget(#SmalltalkEditor)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		target: 	a PluggableTextMorph(570949632)
		category: 	a KMCategory
		morph: 	a PluggableTextMorph(570949632)


[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#SmalltalkEditor)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#SmalltalkEditor) aKMCategoryTarget(#TextMorph...etc...
		morph: 	a PluggableTextMorph(570949632)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#SmalltalkEditor) aKMCategor...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	2
	Receiver's instance variables: 
		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#SmalltalkEditor) aKMC...etc...
		firstIndex: 	1
		lastIndex: 	7


KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
		association: 	nil
		match: 	nil
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#SmalltalkEditor) aKMCategoryTarget(#TextMorph...etc...
		morph: 	a PluggableTextMorph(570949632)
		directKeymaps: 	a KMCategory


KMTarget>>dispatch:
	Receiver: a KMTarget
	Arguments and temporary variables: 
		buffer: 	an OrderedCollection([keystroke '<Cmd-i>'])
	Receiver's instance variables: 
		realTarget: 	nil
		morph: 	a PluggableTextMorph(570949632)
		targetSelector: 	#yourself
		directKeymaps: 	nil
		perInstanceCategories: 	nil


[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Cmd-i>']
		targetToDispatch: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>do:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Cmd-i>']
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatcher>>dispatchKeystroke:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		aKeyEvent: 	[keystroke '<Cmd-i>']
		chain: 	a KMDispatchChain
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#MorphFocusCtrlN...etc...
		morph: 	a TextMorphForEditView(381419520)
		directKeymaps: 	a KMCategory


TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
	Receiver: a TextMorphForEditView(381419520)
	Arguments and temporary variables: 
		evt: 	[keystroke '<Cmd-i>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@18)
		owner: 	a TransformMorph(508559360)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@18)
		color: 	Color black
		extension: 	a MorphExtension (436207616) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'LOGame new'
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(570949632)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(TextMorph)>>handleKeystroke:
	Receiver: a TextMorphForEditView(381419520)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-i>']
		pasteUp: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@18)
		owner: 	a TransformMorph(508559360)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@18)
		color: 	Color black
		extension: 	a MorphExtension (436207616) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'LOGame new'
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(570949632)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


KeyboardEvent>>sentTo:
	Receiver: [keystroke '<Cmd-i>']
	Arguments and temporary variables: 
		anObject: 	a TextMorphForEditView(381419520)
	Receiver's instance variables: 
		timeStamp: 	835342
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#keystroke
		buttons: 	64
		position: 	(142.0@5.0)
		handler: 	nil
		wasHandled: 	true
		keyValue: 	105
		charCode: 	105
		scanCode: 	34


TextMorphForEditView(Morph)>>handleEvent:
	Receiver: a TextMorphForEditView(381419520)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-i>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@18)
		owner: 	a TransformMorph(508559360)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@18)
		color: 	Color black
		extension: 	a MorphExtension (436207616) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'LOGame new'
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(570949632)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(Morph)>>handleFocusEvent:
	Receiver: a TextMorphForEditView(381419520)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-i>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@18)
		owner: 	a TransformMorph(508559360)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@18)
		color: 	Color black
		extension: 	a MorphExtension (436207616) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'LOGame new'
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(570949632)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil



--- The full stack ---
LOGame(Object)>>doesNotUnderstand: #cellsPerSide
Message>>sentTo:
LOGame(Object)>>doesNotUnderstand: #cellsPerSide
LOGame>>initialize
LOGame class(Behavior)>>new
UndefinedObject>>DoIt
OpalCompiler>>evaluate
SmalltalkEditor>>evaluateSelectionAndDo:
[ textMorph editor evaluateSelectionAndDo: [ :result | result inspect ] ] in PluggableTextMorph>>inspectIt
[ result := editBlock value ] in PluggableTextMorph>>handleEdit:
TextMorphForEditView(TextMorph)>>handleEdit:
PluggableTextMorph>>handleEdit:
PluggableTextMorph>>inspectIt
[ :morph | morph inspectIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
TextMorphForEditView(TextMorph)>>handleKeystroke:
KeyboardEvent>>sentTo:
TextMorphForEditView(Morph)>>handleEvent:
TextMorphForEditView(Morph)>>handleFocusEvent:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: LOGame>>cellsPerSide
16 October 2014 4:12:50.232425 pm

VM: Mac OS - intel - 1090 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30858]

LOGame(Object)>>doesNotUnderstand: #cellsPerSide
	Receiver: a LOGame(60817408)
	Arguments and temporary variables: 
		aMessage: 	cellsPerSide
		exception: 	MessageNotUnderstood: LOGame>>cellsPerSide
		resumeValue: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (50@40)
		owner: 	nil
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	nil
		borderWidth: 	2
		borderColor: 	Color black
		cells: 	nil


LOGame>>initialize
	Receiver: a LOGame(60817408)
	Arguments and temporary variables: 
		sampleCell: 	nil
		width: 	nil
		height: 	nil
		n: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (50@40)
		owner: 	nil
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	nil
		borderWidth: 	2
		borderColor: 	Color black
		cells: 	nil


LOGame class(Behavior)>>new
	Receiver: LOGame
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	BorderedMorph
		methodDict: 	a MethodDictionary(#initialize->LOGame>>#initialize )
		format: 	148
		layout: 	a FixedLayout
		instanceVariables: 	#(#cells)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#LOGame
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'PBE-LightsOut'
		traitComposition: 	{}
		localSelectors: 	nil
		announcer: 	nil


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'LOGame new'
		itsSelection: 	a Text for 'LOGame new'
		itsSelectionString: 	'LOGame new'
	Receiver's instance variables: 
		ast: 	DoIt
	^ LOGame new
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


SmalltalkEditor>>evaluateSelectionAndDo:
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(381419520)
		selectionShowing: 	true
		model: 	a Workspace
		editingState: 	a SmalltalkEditingState


SmalltalkEditor>>evaluateSelection
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(381419520)
		selectionShowing: 	true
		model: 	a Workspace
		editingState: 	a SmalltalkEditingState


[ textMorph editor evaluateSelection ] in PluggableTextMorph>>doIt
	Receiver: a PluggableTextMorph(570949632)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(488.0@523.0) corner: (928.0@690.0)
		owner: 	a SystemWindow(481034240)
		submorphs: 	an Array(a TransformMorph(508559360))
		fullBounds: 	(488@523) corner: (928@690)
		color: 	Color white
		extension: 	a MorphExtension (360185856) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(610795520)
		scroller: 	a TransformMorph(508559360)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(526123008)
		textMorph: 	a TextMorphForEditView(381419520)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 10)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


[ result := editBlock value ] in PluggableTextMorph>>handleEdit:
	Receiver: a PluggableTextMorph(570949632)
	Arguments and temporary variables: 
		editBlock: 	[ textMorph editor evaluateSelection ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(488.0@523.0) corner: (928.0@690.0)
		owner: 	a SystemWindow(481034240)
		submorphs: 	an Array(a TransformMorph(508559360))
		fullBounds: 	(488@523) corner: (928@690)
		color: 	Color white
		extension: 	a MorphExtension (360185856) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(610795520)
		scroller: 	a TransformMorph(508559360)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(526123008)
		textMorph: 	a TextMorphForEditView(381419520)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 10)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


TextMorphForEditView(TextMorph)>>handleEdit:
	Receiver: a TextMorphForEditView(381419520)
	Arguments and temporary variables: 
		editBlock: 	[ result := editBlock value ]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@18)
		owner: 	a TransformMorph(508559360)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@18)
		color: 	Color black
		extension: 	a MorphExtension (436207616) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'LOGame new'
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(570949632)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


PluggableTextMorph>>handleEdit:
	Receiver: a PluggableTextMorph(570949632)
	Arguments and temporary variables: 
		result: 	nil
		editBlock: 	[ textMorph editor evaluateSelection ]
	Receiver's instance variables: 
		bounds: 	(488.0@523.0) corner: (928.0@690.0)
		owner: 	a SystemWindow(481034240)
		submorphs: 	an Array(a TransformMorph(508559360))
		fullBounds: 	(488@523) corner: (928@690)
		color: 	Color white
		extension: 	a MorphExtension (360185856) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(610795520)
		scroller: 	a TransformMorph(508559360)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(526123008)
		textMorph: 	a TextMorphForEditView(381419520)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 10)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


PluggableTextMorph>>doIt
	Receiver: a PluggableTextMorph(570949632)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(488.0@523.0) corner: (928.0@690.0)
		owner: 	a SystemWindow(481034240)
		submorphs: 	an Array(a TransformMorph(508559360))
		fullBounds: 	(488@523) corner: (928@690)
		color: 	Color white
		extension: 	a MorphExtension (360185856) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(610795520)
		scroller: 	a TransformMorph(508559360)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(526123008)
		textMorph: 	a TextMorphForEditView(381419520)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 10)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


[ :morph | morph doIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
	Receiver: SmalltalkEditor
	Arguments and temporary variables: 
		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a PluggableTextMorph(570949632)
	Receiver's instance variables: 
		superclass: 	TextEditor
		methodDict: 	a MethodDictionary(#argAdvance:->SmalltalkEditor>>#argAdvance: #bro...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SmalltalkEditor
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Text-Edition'
		traitComposition: 	{}
		localSelectors: 	nil
		cmdActions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop...etc...
		shiftCmdActions: 	#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #m...etc...


BlockClosure>>cull:
	Receiver: [ :morph | morph doIt ]
	Arguments and temporary variables: 
		anArg: 	a PluggableTextMorph(570949632)
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	157
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :morph | morph doIt ]
	Arguments and temporary variables: 
		firstArg: 	a PluggableTextMorph(570949632)
		secondArg: 	a PluggableTextMorph(570949632)
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	157
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :morph | morph doIt ]
	Arguments and temporary variables: 
		firstArg: 	a PluggableTextMorph(570949632)
		secondArg: 	a PluggableTextMorph(570949632)
		thirdArg: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	157
		numArgs: 	1


KMCategoryBinding>>completeMatch:buffer:
	Receiver: aKMCategoryTarget(#SmalltalkEditor)
	Arguments and temporary variables: 
		aKeymap: 	#doIt on Cmd + D do [ :morph | morph doIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
	Receiver's instance variables: 
		target: 	a PluggableTextMorph(570949632)
		category: 	a KMCategory
		morph: 	a PluggableTextMorph(570949632)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #doIt on Cmd + D do [ :morph | morph doIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		l: 	aKMCategoryTarget(#SmalltalkEditor)
	Receiver's instance variables: 
		action: 	[ :morph | morph doIt ]
		name: 	#doIt
		shortcut: 	Cmd + D
		defaultShortcut: 	Cmd + D
		description: 	''


Array(SequenceableCollection)>>do:
	Receiver: an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #doIt on Cmd + D do [ :morph | morph doIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ :morph | morph doIt ]
		name: 	#doIt
		shortcut: 	Cmd + D
		defaultShortcut: 	Cmd + D
		description: 	''


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: #doIt on Cmd + D do [ :morph | morph doIt ]

	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		action: 	[ :morph | morph doIt ]
		name: 	#doIt
		shortcut: 	Cmd + D
		defaultShortcut: 	Cmd + D
		description: 	''


[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#doIt on Cmd + D do [ :morph | morph doIt ]

	Receiver's instance variables: 
		name: 	#SmalltalkEditor
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


Set>>do:
	Receiver: a Set(#printIt on Cmd + P do [ :morph | morph printIt ]
 #previousSelection on Cmd + Shift...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	9
		each: 	#doIt on Cmd + D do [ :morph | morph doIt ]

	Receiver's instance variables: 
		tally: 	14
		array: 	an Array(#printIt on Cmd + P do [ :morph | morph printIt ]
 #previousSel...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
	Receiver's instance variables: 
		name: 	#SmalltalkEditor
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: aKMCategoryTarget(#SmalltalkEditor)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		target: 	a PluggableTextMorph(570949632)
		category: 	a KMCategory
		morph: 	a PluggableTextMorph(570949632)


[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#SmalltalkEditor)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#SmalltalkEditor) aKMCategoryTarget(#TextMorph...etc...
		morph: 	a PluggableTextMorph(570949632)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#SmalltalkEditor) aKMCategor...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	2
	Receiver's instance variables: 
		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#SmalltalkEditor) aKMC...etc...
		firstIndex: 	1
		lastIndex: 	7


KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		association: 	nil
		match: 	nil
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#SmalltalkEditor) aKMCategoryTarget(#TextMorph...etc...
		morph: 	a PluggableTextMorph(570949632)
		directKeymaps: 	a KMCategory


KMTarget>>dispatch:
	Receiver: a KMTarget
	Arguments and temporary variables: 
		buffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
	Receiver's instance variables: 
		realTarget: 	nil
		morph: 	a PluggableTextMorph(570949632)
		targetSelector: 	#yourself
		directKeymaps: 	nil
		perInstanceCategories: 	nil


[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Cmd-d>']
		targetToDispatch: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>do:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatcher>>dispatchKeystroke:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		aKeyEvent: 	[keystroke '<Cmd-d>']
		chain: 	a KMDispatchChain
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#MorphFocusCtrlN...etc...
		morph: 	a TextMorphForEditView(381419520)
		directKeymaps: 	a KMCategory


TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
	Receiver: a TextMorphForEditView(381419520)
	Arguments and temporary variables: 
		evt: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@18)
		owner: 	a TransformMorph(508559360)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@18)
		color: 	Color black
		extension: 	a MorphExtension (436207616) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'LOGame new'
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(570949632)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(TextMorph)>>handleKeystroke:
	Receiver: a TextMorphForEditView(381419520)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-d>']
		pasteUp: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@18)
		owner: 	a TransformMorph(508559360)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@18)
		color: 	Color black
		extension: 	a MorphExtension (436207616) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'LOGame new'
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(570949632)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


KeyboardEvent>>sentTo:
	Receiver: [keystroke '<Cmd-d>']
	Arguments and temporary variables: 
		anObject: 	a TextMorphForEditView(381419520)
	Receiver's instance variables: 
		timeStamp: 	838417
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#keystroke
		buttons: 	64
		position: 	(38.0@36.0)
		handler: 	nil
		wasHandled: 	true
		keyValue: 	100
		charCode: 	100
		scanCode: 	2


TextMorphForEditView(Morph)>>handleEvent:
	Receiver: a TextMorphForEditView(381419520)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@18)
		owner: 	a TransformMorph(508559360)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@18)
		color: 	Color black
		extension: 	a MorphExtension (436207616) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'LOGame new'
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(570949632)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(Morph)>>handleFocusEvent:
	Receiver: a TextMorphForEditView(381419520)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@18)
		owner: 	a TransformMorph(508559360)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@18)
		color: 	Color black
		extension: 	a MorphExtension (436207616) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'LOGame new'
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(570949632)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-d>']
		focusHolder: 	a TextMorphForEditView(381419520)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(522@551.0) corner: (538@567.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a TextMorphForEditView(381419520)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(522@551) mouseOver nil nil]
		targetOffset: 	(9.0@11.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	Form(16x16x8)
		temporaryCursorOffset: 	(-8@ -9)
		hardwareCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r...etc...
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 837719 522 551 0 0 0 1)
		lastKeyScanCode: 	2
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0



--- The full stack ---
LOGame(Object)>>doesNotUnderstand: #cellsPerSide
LOGame>>initialize
LOGame class(Behavior)>>new
UndefinedObject>>DoIt
OpalCompiler>>evaluate
SmalltalkEditor>>evaluateSelectionAndDo:
SmalltalkEditor>>evaluateSelection
[ textMorph editor evaluateSelection ] in PluggableTextMorph>>doIt
[ result := editBlock value ] in PluggableTextMorph>>handleEdit:
TextMorphForEditView(TextMorph)>>handleEdit:
PluggableTextMorph>>handleEdit:
PluggableTextMorph>>doIt
[ :morph | morph doIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
TextMorphForEditView(TextMorph)>>handleKeystroke:
KeyboardEvent>>sentTo:
TextMorphForEditView(Morph)>>handleEvent:
TextMorphForEditView(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: LOGame>>cellsPerSide
16 October 2014 4:12:51.804316 pm

VM: Mac OS - intel - 1090 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30858]

LOGame(Object)>>doesNotUnderstand: #cellsPerSide
	Receiver: a LOGame(60817408)
	Arguments and temporary variables: 
		aMessage: 	cellsPerSide
		exception: 	MessageNotUnderstood: LOGame>>cellsPerSide
		resumeValue: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (50@40)
		owner: 	nil
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	nil
		borderWidth: 	2
		borderColor: 	Color black
		cells: 	nil


Message>>sentTo:
	Receiver: cellsPerSide
	Arguments and temporary variables: 
		receiver: 	a LOGame(60817408)
	Receiver's instance variables: 
		selector: 	#cellsPerSide
		args: 	#()
		lookupClass: 	LOGame


LOGame(Object)>>doesNotUnderstand: #cellsPerSide
	Receiver: a LOGame(60817408)
	Arguments and temporary variables: 
		aMessage: 	cellsPerSide
		exception: 	MessageNotUnderstood: LOGame>>cellsPerSide
		resumeValue: 	MessageNotUnderstood: LOGame>>cellsPerSide
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (50@40)
		owner: 	nil
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	nil
		borderWidth: 	2
		borderColor: 	Color black
		cells: 	nil


LOGame>>initialize
	Receiver: a LOGame(60817408)
	Arguments and temporary variables: 
		sampleCell: 	nil
		width: 	nil
		height: 	nil
		n: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (50@40)
		owner: 	nil
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	nil
		borderWidth: 	2
		borderColor: 	Color black
		cells: 	nil


LOGame class(Behavior)>>new
	Receiver: LOGame
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	BorderedMorph
		methodDict: 	a MethodDictionary(#initialize->LOGame>>#initialize )
		format: 	148
		layout: 	a FixedLayout
		instanceVariables: 	#(#cells)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#LOGame
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'PBE-LightsOut'
		traitComposition: 	{}
		localSelectors: 	nil
		announcer: 	nil


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'LOGame new'
		itsSelection: 	a Text for 'LOGame new'
		itsSelectionString: 	'LOGame new'
	Receiver's instance variables: 
		ast: 	DoIt
	^ LOGame new
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


SmalltalkEditor>>evaluateSelectionAndDo:
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(381419520)
		selectionShowing: 	true
		model: 	a Workspace
		editingState: 	a SmalltalkEditingState


SmalltalkEditor>>evaluateSelection
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(381419520)
		selectionShowing: 	true
		model: 	a Workspace
		editingState: 	a SmalltalkEditingState


[ textMorph editor evaluateSelection ] in PluggableTextMorph>>doIt
	Receiver: a PluggableTextMorph(570949632)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(488.0@523.0) corner: (928.0@690.0)
		owner: 	a SystemWindow(481034240)
		submorphs: 	an Array(a TransformMorph(508559360))
		fullBounds: 	(488@523) corner: (928@690)
		color: 	Color white
		extension: 	a MorphExtension (360185856) [locked]  [other:  (kmDispatcher -> a K...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(610795520)
		scroller: 	a TransformMorph(508559360)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(526123008)
		textMorph: 	a TextMorphForEditView(381419520)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 10)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


[ result := editBlock value ] in PluggableTextMorph>>handleEdit:
	Receiver: a PluggableTextMorph(570949632)
	Arguments and temporary variables: 
		editBlock: 	[ textMorph editor evaluateSelection ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(488.0@523.0) corner: (928.0@690.0)
		owner: 	a SystemWindow(481034240)
		submorphs: 	an Array(a TransformMorph(508559360))
		fullBounds: 	(488@523) corner: (928@690)
		color: 	Color white
		extension: 	a MorphExtension (360185856) [locked]  [other:  (kmDispatcher -> a K...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(610795520)
		scroller: 	a TransformMorph(508559360)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(526123008)
		textMorph: 	a TextMorphForEditView(381419520)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 10)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


TextMorphForEditView(TextMorph)>>handleEdit:
	Receiver: a TextMorphForEditView(381419520)
	Arguments and temporary variables: 
		editBlock: 	[ result := editBlock value ]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@18)
		owner: 	a TransformMorph(508559360)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@18)
		color: 	Color black
		extension: 	a MorphExtension (436207616) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'LOGame new'
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(570949632)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


PluggableTextMorph>>handleEdit:
	Receiver: a PluggableTextMorph(570949632)
	Arguments and temporary variables: 
		result: 	nil
		editBlock: 	[ textMorph editor evaluateSelection ]
	Receiver's instance variables: 
		bounds: 	(488.0@523.0) corner: (928.0@690.0)
		owner: 	a SystemWindow(481034240)
		submorphs: 	an Array(a TransformMorph(508559360))
		fullBounds: 	(488@523) corner: (928@690)
		color: 	Color white
		extension: 	a MorphExtension (360185856) [locked]  [other:  (kmDispatcher -> a K...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(610795520)
		scroller: 	a TransformMorph(508559360)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(526123008)
		textMorph: 	a TextMorphForEditView(381419520)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 10)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


PluggableTextMorph>>doIt
	Receiver: a PluggableTextMorph(570949632)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(488.0@523.0) corner: (928.0@690.0)
		owner: 	a SystemWindow(481034240)
		submorphs: 	an Array(a TransformMorph(508559360))
		fullBounds: 	(488@523) corner: (928@690)
		color: 	Color white
		extension: 	a MorphExtension (360185856) [locked]  [other:  (kmDispatcher -> a K...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(610795520)
		scroller: 	a TransformMorph(508559360)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(526123008)
		textMorph: 	a TextMorphForEditView(381419520)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 10)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


[ :morph | morph doIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
	Receiver: SmalltalkEditor
	Arguments and temporary variables: 
		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a PluggableTextMorph(570949632)
	Receiver's instance variables: 
		superclass: 	TextEditor
		methodDict: 	a MethodDictionary(#argAdvance:->SmalltalkEditor>>#argAdvance: #bro...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SmalltalkEditor
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Text-Edition'
		traitComposition: 	{}
		localSelectors: 	nil
		cmdActions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop...etc...
		shiftCmdActions: 	#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #m...etc...


BlockClosure>>cull:
	Receiver: [ :morph | morph doIt ]
	Arguments and temporary variables: 
		anArg: 	a PluggableTextMorph(570949632)
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	157
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :morph | morph doIt ]
	Arguments and temporary variables: 
		firstArg: 	a PluggableTextMorph(570949632)
		secondArg: 	a PluggableTextMorph(570949632)
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	157
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :morph | morph doIt ]
	Arguments and temporary variables: 
		firstArg: 	a PluggableTextMorph(570949632)
		secondArg: 	a PluggableTextMorph(570949632)
		thirdArg: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	157
		numArgs: 	1


KMCategoryBinding>>completeMatch:buffer:
	Receiver: aKMCategoryTarget(#SmalltalkEditor)
	Arguments and temporary variables: 
		aKeymap: 	#doIt on Cmd + D do [ :morph | morph doIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
	Receiver's instance variables: 
		target: 	a PluggableTextMorph(570949632)
		category: 	a KMCategory
		morph: 	a PluggableTextMorph(570949632)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #doIt on Cmd + D do [ :morph | morph doIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		l: 	aKMCategoryTarget(#SmalltalkEditor)
	Receiver's instance variables: 
		action: 	[ :morph | morph doIt ]
		name: 	#doIt
		shortcut: 	Cmd + D
		defaultShortcut: 	Cmd + D
		description: 	''


Array(SequenceableCollection)>>do:
	Receiver: an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #doIt on Cmd + D do [ :morph | morph doIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ :morph | morph doIt ]
		name: 	#doIt
		shortcut: 	Cmd + D
		defaultShortcut: 	Cmd + D
		description: 	''


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: #doIt on Cmd + D do [ :morph | morph doIt ]

	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		action: 	[ :morph | morph doIt ]
		name: 	#doIt
		shortcut: 	Cmd + D
		defaultShortcut: 	Cmd + D
		description: 	''


[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#doIt on Cmd + D do [ :morph | morph doIt ]

	Receiver's instance variables: 
		name: 	#SmalltalkEditor
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


Set>>do:
	Receiver: a Set(#printIt on Cmd + P do [ :morph | morph printIt ]
 #previousSelection on Cmd + Shift...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	9
		each: 	#doIt on Cmd + D do [ :morph | morph doIt ]

	Receiver's instance variables: 
		tally: 	14
		array: 	an Array(#printIt on Cmd + P do [ :morph | morph printIt ]
 #previousSel...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
	Receiver's instance variables: 
		name: 	#SmalltalkEditor
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: aKMCategoryTarget(#SmalltalkEditor)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		target: 	a PluggableTextMorph(570949632)
		category: 	a KMCategory
		morph: 	a PluggableTextMorph(570949632)


[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#SmalltalkEditor)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#SmalltalkEditor) aKMCategoryTarget(#TextMorph...etc...
		morph: 	a PluggableTextMorph(570949632)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#SmalltalkEditor) aKMCategor...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	2
	Receiver's instance variables: 
		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#SmalltalkEditor) aKMC...etc...
		firstIndex: 	1
		lastIndex: 	7


KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		association: 	nil
		match: 	nil
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#SmalltalkEditor) aKMCategoryTarget(#TextMorph...etc...
		morph: 	a PluggableTextMorph(570949632)
		directKeymaps: 	a KMCategory


KMTarget>>dispatch:
	Receiver: a KMTarget
	Arguments and temporary variables: 
		buffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
	Receiver's instance variables: 
		realTarget: 	nil
		morph: 	a PluggableTextMorph(570949632)
		targetSelector: 	#yourself
		directKeymaps: 	nil
		perInstanceCategories: 	nil


[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Cmd-d>']
		targetToDispatch: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>do:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatcher>>dispatchKeystroke:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		aKeyEvent: 	[keystroke '<Cmd-d>']
		chain: 	a KMDispatchChain
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#MorphFocusCtrlN...etc...
		morph: 	a TextMorphForEditView(381419520)
		directKeymaps: 	a KMCategory


TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
	Receiver: a TextMorphForEditView(381419520)
	Arguments and temporary variables: 
		evt: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@18)
		owner: 	a TransformMorph(508559360)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@18)
		color: 	Color black
		extension: 	a MorphExtension (436207616) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'LOGame new'
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(570949632)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(TextMorph)>>handleKeystroke:
	Receiver: a TextMorphForEditView(381419520)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-d>']
		pasteUp: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@18)
		owner: 	a TransformMorph(508559360)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@18)
		color: 	Color black
		extension: 	a MorphExtension (436207616) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'LOGame new'
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(570949632)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


KeyboardEvent>>sentTo:
	Receiver: [keystroke '<Cmd-d>']
	Arguments and temporary variables: 
		anObject: 	a TextMorphForEditView(381419520)
	Receiver's instance variables: 
		timeStamp: 	838417
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#keystroke
		buttons: 	64
		position: 	(38.0@36.0)
		handler: 	nil
		wasHandled: 	true
		keyValue: 	100
		charCode: 	100
		scanCode: 	2


TextMorphForEditView(Morph)>>handleEvent:
	Receiver: a TextMorphForEditView(381419520)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@18)
		owner: 	a TransformMorph(508559360)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@18)
		color: 	Color black
		extension: 	a MorphExtension (436207616) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'LOGame new'
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(570949632)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil



--- The full stack ---
LOGame(Object)>>doesNotUnderstand: #cellsPerSide
Message>>sentTo:
LOGame(Object)>>doesNotUnderstand: #cellsPerSide
LOGame>>initialize
LOGame class(Behavior)>>new
UndefinedObject>>DoIt
OpalCompiler>>evaluate
SmalltalkEditor>>evaluateSelectionAndDo:
SmalltalkEditor>>evaluateSelection
[ textMorph editor evaluateSelection ] in PluggableTextMorph>>doIt
[ result := editBlock value ] in PluggableTextMorph>>handleEdit:
TextMorphForEditView(TextMorph)>>handleEdit:
PluggableTextMorph>>handleEdit:
PluggableTextMorph>>doIt
[ :morph | morph doIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
TextMorphForEditView(TextMorph)>>handleKeystroke:
KeyboardEvent>>sentTo:
TextMorphForEditView(Morph)>>handleEvent:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
TextMorphForEditView(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: receiver of "generateWithSource" is nil
16 October 2014 4:48:02.513837 pm

VM: Mac OS - intel - 1090 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30858]

UndefinedObject(Object)>>doesNotUnderstand: #generateWithSource
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	generateWithSource
		exception: 	MessageNotUnderstood: receiver of "generateWithSource" is nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	nil
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


PackageTreeNautilusUI(AbstractTool)>>compileANewClassFrom:notifying:startingFrom:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
		aString: 	'cellsPerSide
	^10'
		aController: 	a PluggableTextMorphWithLimits(722731008)
		aClass: 	LOGame class
		oldClass: 	BorderedMorph class
		class: 	nil
		newClassName: 	'cellsPerSide'
		defTokens: 	an OrderedCollection('cellsPerSide' '^10')
		keywdIx: 	0
		envt: 	a SystemDictionary(lots of globals)
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(37748736)
		hierarchyClass: 	nil
		cachedHierarchy: 	a SortHierarchically
		sourceTextArea: 	a PluggableTextMorphWithLimits(722731008)
		groupsSelection: 	a Dictionary()
		packagesSelection: 	a Dictionary(a PackageTreePackageSelection->true a RPackage(...etc...
		classesSelection: 	a Dictionary(LOGame->true )
		list: 	a MorphTreeMorph(270008320)
		list2: 	a PluggableIconListMorph(488636416)
		sourceCodePanel: 	a PanelMorph(542900224)
		commentTextArea: 	nil
		currentDisplayChoice: 	#SourceCode
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(625213440)
		list2Elements: 	{LOCell. LOGame}
		listElements: 	nil
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(722731008)...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(338690048)
		contentSelection: 	nil
		acceptor: 	a ClassDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		packagePattern: 	nil
		searchWidget: 	a SearchMorph(13893632)


PackageTreeNautilusUI(AbstractNautilusUI)>>compileAClassFrom:notifying:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
		aString: 	'cellsPerSide
	^10'
		aController: 	a PluggableTextMorphWithLimits(722731008)
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(37748736)
		hierarchyClass: 	nil
		cachedHierarchy: 	a SortHierarchically
		sourceTextArea: 	a PluggableTextMorphWithLimits(722731008)
		groupsSelection: 	a Dictionary()
		packagesSelection: 	a Dictionary(a PackageTreePackageSelection->true a RPackage(...etc...
		classesSelection: 	a Dictionary(LOGame->true )
		list: 	a MorphTreeMorph(270008320)
		list2: 	a PluggableIconListMorph(488636416)
		sourceCodePanel: 	a PanelMorph(542900224)
		commentTextArea: 	nil
		currentDisplayChoice: 	#SourceCode
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(625213440)
		list2Elements: 	{LOCell. LOGame}
		listElements: 	nil
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(722731008)...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(338690048)
		contentSelection: 	nil
		acceptor: 	a ClassDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		packagePattern: 	nil
		searchWidget: 	a SearchMorph(13893632)


ClassDefinitionAcceptor>>accept:notifying:
	Receiver: a ClassDefinitionAcceptor
	Arguments and temporary variables: 
		aText: 	'cellsPerSide
	^10'
		aController: 	a PluggableTextMorphWithLimits(722731008)
	Receiver's instance variables: 
		model: 	a PackageTreeNautilusUI


PackageTreeNautilusUI(NautilusUI)>>compileSource:notifying:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
		aText: 	a Text for 'cellsPerSide
	^10'
		aController: 	a PluggableTextMorphWithLimits(722731008)
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(37748736)
		hierarchyClass: 	nil
		cachedHierarchy: 	a SortHierarchically
		sourceTextArea: 	a PluggableTextMorphWithLimits(722731008)
		groupsSelection: 	a Dictionary()
		packagesSelection: 	a Dictionary(a PackageTreePackageSelection->true a RPackage(...etc...
		classesSelection: 	a Dictionary(LOGame->true )
		list: 	a MorphTreeMorph(270008320)
		list2: 	a PluggableIconListMorph(488636416)
		sourceCodePanel: 	a PanelMorph(542900224)
		commentTextArea: 	nil
		currentDisplayChoice: 	#SourceCode
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(625213440)
		list2Elements: 	{LOCell. LOGame}
		listElements: 	nil
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(722731008)...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(338690048)
		contentSelection: 	nil
		acceptor: 	a ClassDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		packagePattern: 	nil
		searchWidget: 	a SearchMorph(13893632)


[ 
^ setTextSelector isNil
	or: [ 
		setTextSelector numArgs = 2
			ifTrue: [ model perform: setTextSelector with: acceptedText with: self ]
			ifFalse: [ model perform: setTextSelector with: acceptedText ] ] ] in PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptTextInModel
	Receiver: a PluggableTextMorphWithLimits(722731008)
	Arguments and temporary variables: 
		acceptedText: 	a Text for 'cellsPerSide
	^10'
	Receiver's instance variables: 
		bounds: 	(85.0@354.0) corner: (901.0@631.0)
		owner: 	a MultipleMethodsEditor(338690048)
		submorphs: 	an Array(an AlphaImageMorph(528744448) a TransformMorph(173015040))
		fullBounds: 	(85@354) corner: (901@631)
		color: 	Color white
		extension: 	a MorphExtension (408944640) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(770441216)
		scroller: 	a TransformMorph(173015040)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(479985664)
		textMorph: 	a TextMorphForEditView(442236928)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 17)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	-1
		method: 	nil
		lockIcon: 	an AlphaImageMorph(528744448)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


BlockClosure>>ensure:
	Receiver: [ 
^ setTextSelector isNil
	or: [ 
		setTextSelector numArgs = 2
			ifTrue: [ model perfor...etc...
	Arguments and temporary variables: 
		aBlock: 	[ unstyledAcceptText := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptTextInMod...etc...
		startpc: 	65
		numArgs: 	0


PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptTextInModel
	Receiver: a PluggableTextMorphWithLimits(722731008)
	Arguments and temporary variables: 
		acceptedText: 	a Text for 'cellsPerSide
	^10'
	Receiver's instance variables: 
		bounds: 	(85.0@354.0) corner: (901.0@631.0)
		owner: 	a MultipleMethodsEditor(338690048)
		submorphs: 	an Array(an AlphaImageMorph(528744448) a TransformMorph(173015040))
		fullBounds: 	(85@354) corner: (901@631)
		color: 	Color white
		extension: 	a MorphExtension (408944640) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(770441216)
		scroller: 	a TransformMorph(173015040)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(479985664)
		textMorph: 	a TextMorphForEditView(442236928)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 17)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	-1
		method: 	nil
		lockIcon: 	an AlphaImageMorph(528744448)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptBasic
	Receiver: a PluggableTextMorphWithLimits(722731008)
	Arguments and temporary variables: 
		ok: 	nil
		saveSelection: 	(1 to: 17)
		saveScrollerOffset: 	(-3@0)
	Receiver's instance variables: 
		bounds: 	(85.0@354.0) corner: (901.0@631.0)
		owner: 	a MultipleMethodsEditor(338690048)
		submorphs: 	an Array(an AlphaImageMorph(528744448) a TransformMorph(173015040))
		fullBounds: 	(85@354) corner: (901@631)
		color: 	Color white
		extension: 	a MorphExtension (408944640) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(770441216)
		scroller: 	a TransformMorph(173015040)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(479985664)
		textMorph: 	a TextMorphForEditView(442236928)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 17)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	-1
		method: 	nil
		lockIcon: 	an AlphaImageMorph(528744448)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


PluggableTextMorphWithLimits>>acceptBasic
	Receiver: a PluggableTextMorphWithLimits(722731008)
	Arguments and temporary variables: 
		saveSelection: 	nil
		saveScrollerOffset: 	nil
	Receiver's instance variables: 
		bounds: 	(85.0@354.0) corner: (901.0@631.0)
		owner: 	a MultipleMethodsEditor(338690048)
		submorphs: 	an Array(an AlphaImageMorph(528744448) a TransformMorph(173015040))
		fullBounds: 	(85@354) corner: (901@631)
		color: 	Color white
		extension: 	a MorphExtension (408944640) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(770441216)
		scroller: 	a TransformMorph(173015040)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(479985664)
		textMorph: 	a TextMorphForEditView(442236928)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 17)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	-1
		method: 	nil
		lockIcon: 	an AlphaImageMorph(528744448)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


PluggableTextMorphWithLimits(PluggableTextMorph)>>accept
	Receiver: a PluggableTextMorphWithLimits(722731008)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(85.0@354.0) corner: (901.0@631.0)
		owner: 	a MultipleMethodsEditor(338690048)
		submorphs: 	an Array(an AlphaImageMorph(528744448) a TransformMorph(173015040))
		fullBounds: 	(85@354) corner: (901@631)
		color: 	Color white
		extension: 	a MorphExtension (408944640) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(770441216)
		scroller: 	a TransformMorph(173015040)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(479985664)
		textMorph: 	a TextMorphForEditView(442236928)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 17)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	-1
		method: 	nil
		lockIcon: 	an AlphaImageMorph(528744448)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


TextMorphForEditView>>acceptContents
	Receiver: a TextMorphForEditView(442236928)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (808@34)
		owner: 	a TransformMorph(173015040)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (808@34)
		color: 	Color black
		extension: 	a MorphExtension (497025024) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'cellsPerSide
	 End of statement list encountered ->^10'
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorphWithLimits(722731008)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


[ :morph | morph acceptContents ] in TextMorph class>>buildTextEditorKeymapsOn:
	Receiver: TextMorph
	Arguments and temporary variables: 
		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a TextMorphForEditView(442236928)
	Receiver's instance variables: 
		superclass: 	BorderedMorph
		methodDict: 	a MethodDictionary(size 204)
		format: 	168
		layout: 	a FixedLayout
		instanceVariables: 	#(#textStyle #text #wrapFlag #paragraph #editor #container #...etc...
		organization: 	a ClassOrganization
		subclasses: 	{StringMorphEditor. TextMorphForEditView. GrowlMorph}
		name: 	#TextMorph
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Base-Basic'
		traitComposition: 	TAbleToRotate
		localSelectors: 	a Set(#editorClass #setTextStyle: #setFirstCharacter: #margins:...etc...
		announcer: 	nil


BlockClosure>>cull:
	Receiver: [ :morph | morph acceptContents ]
	Arguments and temporary variables: 
		anArg: 	a TextMorphForEditView(442236928)
	Receiver's instance variables: 
		outerContext: 	TextMorph class>>buildTextEditorKeymapsOn:
		startpc: 	80
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :morph | morph acceptContents ]
	Arguments and temporary variables: 
		firstArg: 	a TextMorphForEditView(442236928)
		secondArg: 	a TextMorphForEditView(442236928)
	Receiver's instance variables: 
		outerContext: 	TextMorph class>>buildTextEditorKeymapsOn:
		startpc: 	80
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :morph | morph acceptContents ]
	Arguments and temporary variables: 
		firstArg: 	a TextMorphForEditView(442236928)
		secondArg: 	a TextMorphForEditView(442236928)
		thirdArg: 	[keystroke '<Cmd-s>']
	Receiver's instance variables: 
		outerContext: 	TextMorph class>>buildTextEditorKeymapsOn:
		startpc: 	80
		numArgs: 	1


KMCategoryBinding>>completeMatch:buffer:
	Receiver: aKMCategoryTarget(#TextMorph)
	Arguments and temporary variables: 
		aKeymap: 	#accept on Cmd + S do [ :morph | morph acceptContents ]

		aBuffer: 	an OrderedCollection([keystroke '<Cmd-s>'])
	Receiver's instance variables: 
		target: 	a TextMorphForEditView(442236928)
		category: 	a KMCategory
		morph: 	a TextMorphForEditView(442236928)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #accept on Cmd + S do [ :morph | morph acceptContents ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Cmd-s>'])
		listeners: 	an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
		l: 	aKMCategoryTarget(#TextMorph)
	Receiver's instance variables: 
		action: 	[ :morph | morph acceptContents ]
		name: 	#accept
		shortcut: 	Cmd + S
		defaultShortcut: 	Cmd + S
		description: 	''


Array(SequenceableCollection)>>do:
	Receiver: an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #accept on Cmd + S do [ :morph | morph acceptContents ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Cmd-s>'])
		listeners: 	an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ :morph | morph acceptContents ]
		name: 	#accept
		shortcut: 	Cmd + S
		defaultShortcut: 	Cmd + S
		description: 	''


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: #accept on Cmd + S do [ :morph | morph acceptContents ]

	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-s>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		action: 	[ :morph | morph acceptContents ]
		name: 	#accept
		shortcut: 	Cmd + S
		defaultShortcut: 	Cmd + S
		description: 	''


[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-s>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#accept on Cmd + S do [ :morph | morph acceptContents ]

	Receiver's instance variables: 
		name: 	#TextMorph
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


Set>>do:
	Receiver: a Set(#accept on Cmd + S do [ :morph | morph acceptContents ]
)
	Arguments and temporary variables: 
		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	4
		each: 	#accept on Cmd + S do [ :morph | morph acceptContents ]

	Receiver's instance variables: 
		tally: 	1
		array: 	an Array(nil nil nil #accept on Cmd + S do [ :morph | morph acceptConten...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-s>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
		aBlock: 	[ ^ self ]
	Receiver's instance variables: 
		name: 	#TextMorph
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: aKMCategoryTarget(#TextMorph)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-s>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		target: 	a TextMorphForEditView(442236928)
		category: 	a KMCategory
		morph: 	a TextMorphForEditView(442236928)


[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-s>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#TextMorph)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...
		morph: 	a TextMorphForEditView(442236928)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#MorphFocusCtrlNavigation) a...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	3
	Receiver's instance variables: 
		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#MorphFocusCtrlNavigat...etc...
		firstIndex: 	1
		lastIndex: 	3


KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-s>'])
		association: 	nil
		match: 	nil
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...
		morph: 	a TextMorphForEditView(442236928)
		directKeymaps: 	a KMCategory


KMTarget>>dispatch:
	Receiver: a KMTarget
	Arguments and temporary variables: 
		buffer: 	an OrderedCollection([keystroke '<Cmd-s>'])
	Receiver's instance variables: 
		realTarget: 	nil
		morph: 	a TextMorphForEditView(442236928)
		targetSelector: 	#yourself
		directKeymaps: 	nil
		perInstanceCategories: 	nil


[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Cmd-s>']
		targetToDispatch: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>do:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Cmd-s>']
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatcher>>dispatchKeystroke:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		aKeyEvent: 	[keystroke '<Cmd-s>']
		chain: 	a KMDispatchChain
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...
		morph: 	a TextMorphForEditView(442236928)
		directKeymaps: 	a KMCategory


TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
	Receiver: a TextMorphForEditView(442236928)
	Arguments and temporary variables: 
		evt: 	[keystroke '<Cmd-s>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (808@34)
		owner: 	a TransformMorph(173015040)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (808@34)
		color: 	Color black
		extension: 	a MorphExtension (497025024) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'cellsPerSide
	 End of statement list encountered ->^10'
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorphWithLimits(722731008)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(TextMorph)>>handleKeystroke:
	Receiver: a TextMorphForEditView(442236928)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-s>']
		pasteUp: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (808@34)
		owner: 	a TransformMorph(173015040)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (808@34)
		color: 	Color black
		extension: 	a MorphExtension (497025024) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'cellsPerSide
	 End of statement list encountered ->^10'
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorphWithLimits(722731008)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


KeyboardEvent>>sentTo:
	Receiver: [keystroke '<Cmd-s>']
	Arguments and temporary variables: 
		anObject: 	a TextMorphForEditView(442236928)
	Receiver's instance variables: 
		timeStamp: 	2950666
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#keystroke
		buttons: 	64
		position: 	(-38@ -6.0)
		handler: 	nil
		wasHandled: 	true
		keyValue: 	115
		charCode: 	115
		scanCode: 	1


TextMorphForEditView(Morph)>>handleEvent:
	Receiver: a TextMorphForEditView(442236928)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-s>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (808@34)
		owner: 	a TransformMorph(173015040)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (808@34)
		color: 	Color black
		extension: 	a MorphExtension (497025024) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'cellsPerSide
	 End of statement list encountered ->^10'
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorphWithLimits(722731008)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(Morph)>>handleFocusEvent:
	Receiver: a TextMorphForEditView(442236928)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-s>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (808@34)
		owner: 	a TransformMorph(173015040)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (808@34)
		color: 	Color black
		extension: 	a MorphExtension (497025024) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'cellsPerSide
	 End of statement list encountered ->^10'
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorphWithLimits(722731008)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #generateWithSource
OpalCompiler>>evaluate
PackageTreeNautilusUI(AbstractTool)>>compileANewClassFrom:notifying:startingFrom:
PackageTreeNautilusUI(AbstractNautilusUI)>>compileAClassFrom:notifying:
ClassDefinitionAcceptor>>accept:notifying:
PackageTreeNautilusUI(NautilusUI)>>compileSource:notifying:
[ 
^ setTextSelector isNil
	or: [ 
		setTextSelector numArgs = 2
			ifTrue: [ model perform: setTextSelector with: acceptedText with: self ]
			ifFalse: [ model perform: setTextSelector with: acceptedText ] ] ] in PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptTextInModel
BlockClosure>>ensure:
PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptTextInModel
PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptBasic
PluggableTextMorphWithLimits>>acceptBasic
PluggableTextMorphWithLimits(PluggableTextMorph)>>accept
TextMorphForEditView>>acceptContents
[ :morph | morph acceptContents ] in TextMorph class>>buildTextEditorKeymapsOn:
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
TextMorphForEditView(TextMorph)>>handleKeystroke:
KeyboardEvent>>sentTo:
TextMorphForEditView(Morph)>>handleEvent:
TextMorphForEditView(Morph)>>handleFocusEvent:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: LOGame>>toggleState
16 October 2014 5:03:04.607212 pm

VM: Mac OS - intel - 1090 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30858]

LOGame(Object)>>doesNotUnderstand: #toggleState
	Receiver: a LOGame(425984000)
	Arguments and temporary variables: 
		aMessage: 	toggleState
		exception: 	MessageNotUnderstood: LOGame>>toggleState
		resumeValue: 	nil
	Receiver's instance variables: 
		bounds: 	(5.0@5.0) corner: (169.0@169.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	an Array(a LOCell(839647232) a LOCell(532676608) a LOCell(306184192)...etc...
		fullBounds: 	(5@5) corner: (169@169)
		color: 	Color blue
		extension: 	a MorphExtension (633602048)
		borderWidth: 	2
		borderColor: 	Color black
		cells: 	a Matrix(a LOGame(425984000) a LOGame(425984000) a LOGame(425984000) a L...etc...


LOGame>>toggleNeighboursOfCellAt:at:
	Receiver: a LOGame(425984000)
	Arguments and temporary variables: 
		i: 	5
		j: 	3
	Receiver's instance variables: 
		bounds: 	(5.0@5.0) corner: (169.0@169.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	an Array(a LOCell(839647232) a LOCell(532676608) a LOCell(306184192)...etc...
		fullBounds: 	(5@5) corner: (169@169)
		color: 	Color blue
		extension: 	a MorphExtension (633602048)
		borderWidth: 	2
		borderColor: 	Color black
		cells: 	a Matrix(a LOGame(425984000) a LOGame(425984000) a LOGame(425984000) a L...etc...


[ self toggleNeighboursOfCellAt: i at: j ] in LOGame>>newCellAt:at:
	Receiver: a LOGame(425984000)
	Arguments and temporary variables: 
		i: 	5
		j: 	3
		c: 	nil
		origin: 	nil
	Receiver's instance variables: 
		bounds: 	(5.0@5.0) corner: (169.0@169.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	an Array(a LOCell(839647232) a LOCell(532676608) a LOCell(306184192)...etc...
		fullBounds: 	(5@5) corner: (169@169)
		color: 	Color blue
		extension: 	a MorphExtension (633602048)
		borderWidth: 	2
		borderColor: 	Color black
		cells: 	a Matrix(a LOGame(425984000) a LOGame(425984000) a LOGame(425984000) a L...etc...


LOCell>>mouseUp:
	Receiver: a LOCell(1031274496)
	Arguments and temporary variables: 
		anEvent: 	[(79@48) mouseUp 240631 nil]
	Receiver's instance variables: 
		bounds: 	(71.0@39.0) corner: (87.0@55.0)
		owner: 	a LOGame(425984000)
		submorphs: 	an Array(a StringMorph(703070208)'')
		fullBounds: 	(71.0@39.0) corner: (87.0@56.0)
		color: 	Color paleYellow
		extension: 	a MorphExtension (13369344)
		borderWidth: 	2
		borderColor: 	#raised
		target: 	nil
		actionSelector: 	#flash
		arguments: 	#()
		actWhen: 	#buttonUp
		oldColor: 	Color paleYellow
		mouseDownTime: 	nil
		label: 	a StringMorph(703070208)''
		helpText: 	nil
		onColor: 	(Color r: 0.8 g: 0.897 b: 0.915 alpha: 1.0)
		offColor: 	Color paleYellow
		mouseAction: 	[ self toggleNeighboursOfCellAt: i at: j ]


LOCell(Morph)>>handleMouseUp:
	Receiver: a LOCell(1031274496)
	Arguments and temporary variables: 
		anEvent: 	[(79@48) mouseUp 240631 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(71.0@39.0) corner: (87.0@55.0)
		owner: 	a LOGame(425984000)
		submorphs: 	an Array(a StringMorph(703070208)'')
		fullBounds: 	(71.0@39.0) corner: (87.0@56.0)
		color: 	Color paleYellow
		extension: 	a MorphExtension (13369344)
		borderWidth: 	2
		borderColor: 	#raised
		target: 	nil
		actionSelector: 	#flash
		arguments: 	#()
		actWhen: 	#buttonUp
		oldColor: 	Color paleYellow
		mouseDownTime: 	nil
		label: 	a StringMorph(703070208)''
		helpText: 	nil
		onColor: 	(Color r: 0.8 g: 0.897 b: 0.915 alpha: 1.0)
		offColor: 	Color paleYellow
		mouseAction: 	[ self toggleNeighboursOfCellAt: i at: j ]


MouseButtonEvent>>sentTo:
	Receiver: [(79@48) mouseUp 240631 nil]
	Arguments and temporary variables: 
		anObject: 	a LOCell(1031274496)
	Receiver's instance variables: 
		timeStamp: 	240631
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(79@48)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


LOCell(Morph)>>handleEvent:
	Receiver: a LOCell(1031274496)
	Arguments and temporary variables: 
		anEvent: 	[(79@48) mouseUp 240631 nil]
	Receiver's instance variables: 
		bounds: 	(71.0@39.0) corner: (87.0@55.0)
		owner: 	a LOGame(425984000)
		submorphs: 	an Array(a StringMorph(703070208)'')
		fullBounds: 	(71.0@39.0) corner: (87.0@56.0)
		color: 	Color paleYellow
		extension: 	a MorphExtension (13369344)
		borderWidth: 	2
		borderColor: 	#raised
		target: 	nil
		actionSelector: 	#flash
		arguments: 	#()
		actWhen: 	#buttonUp
		oldColor: 	Color paleYellow
		mouseDownTime: 	nil
		label: 	a StringMorph(703070208)''
		helpText: 	nil
		onColor: 	(Color r: 0.8 g: 0.897 b: 0.915 alpha: 1.0)
		offColor: 	Color paleYellow
		mouseAction: 	[ self toggleNeighboursOfCellAt: i at: j ]


LOCell(Morph)>>handleFocusEvent:
	Receiver: a LOCell(1031274496)
	Arguments and temporary variables: 
		anEvent: 	[(79@48) mouseUp 240631 nil]
	Receiver's instance variables: 
		bounds: 	(71.0@39.0) corner: (87.0@55.0)
		owner: 	a LOGame(425984000)
		submorphs: 	an Array(a StringMorph(703070208)'')
		fullBounds: 	(71.0@39.0) corner: (87.0@56.0)
		color: 	Color paleYellow
		extension: 	a MorphExtension (13369344)
		borderWidth: 	2
		borderColor: 	#raised
		target: 	nil
		actionSelector: 	#flash
		arguments: 	#()
		actWhen: 	#buttonUp
		oldColor: 	Color paleYellow
		mouseDownTime: 	nil
		label: 	a StringMorph(703070208)''
		helpText: 	nil
		onColor: 	(Color r: 0.8 g: 0.897 b: 0.915 alpha: 1.0)
		offColor: 	Color paleYellow
		mouseAction: 	[ self toggleNeighboursOfCellAt: i at: j ]


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(79@48) mouseUp 240631 nil]
		focusHolder: 	a LOCell(1031274496)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(79@48.0) corner: (95@64.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(79@48.0) corner: (95@64.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a TextMorphForEditView(676069376)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(79@48) mouseOver nil nil]
		targetOffset: 	(8.0@9.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 240631 79 48 0 0 0 1)
		lastKeyScanCode: 	2
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	[(79@48) mouseOver red nil nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1208@742)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a LOGame(425984000) a SystemWindo...etc...
		fullBounds: 	(0@0) corner: (1208@742)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(79@48) mouseUp 240631 nil]
		focusHolder: 	a LOCell(1031274496)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		bounds: 	(79@48.0) corner: (95@64.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(79@48.0) corner: (95@64.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a TextMorphForEditView(676069376)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(79@48) mouseOver nil nil]
		targetOffset: 	(8.0@9.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 240631 79 48 0 0 0 1)
		lastKeyScanCode: 	2
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(79@48) mouseUp 240631 nil]
		focusHolder: 	a LOCell(1031274496)
		aBlock: 	[ self mouseFocus: nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(79@48.0) corner: (95@64.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(79@48.0) corner: (95@64.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a TextMorphForEditView(676069376)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(79@48) mouseOver nil nil]
		targetOffset: 	(8.0@9.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 240631 79 48 0 0 0 1)
		lastKeyScanCode: 	2
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(79@48) mouseUp 240631 nil]
	Receiver's instance variables: 
		bounds: 	(79@48.0) corner: (95@64.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(79@48.0) corner: (95@64.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a TextMorphForEditView(676069376)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(79@48) mouseOver nil nil]
		targetOffset: 	(8.0@9.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 240631 79 48 0 0 0 1)
		lastKeyScanCode: 	2
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>handleEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(79@48) mouseUp 240631 nil]
		evt: 	[(79@48) mouseUp 240631 nil]
	Receiver's instance variables: 
		bounds: 	(79@48.0) corner: (95@64.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(79@48.0) corner: (95@64.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a TextMorphForEditView(676069376)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(79@48) mouseOver nil nil]
		targetOffset: 	(8.0@9.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 240631 79 48 0 0 0 1)
		lastKeyScanCode: 	2
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>processEvents
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		evt: 	[(79@48) mouseUp 240631 nil]
		evtBuf: 	#(1 240631 79 48 0 0 0 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	(79@48.0) corner: (95@64.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(79@48.0) corner: (95@64.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a TextMorphForEditView(676069376)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(79@48) mouseOver nil nil]
		targetOffset: 	(8.0@9.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 240631 79 48 0 0 0 1)
		lastKeyScanCode: 	2
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		h: 	a HandMorph(760479744)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1208@742)
		canvas: 	a FormCanvas on: DisplayScreen(1208x742x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(13893632))(a SearchMorph...etc...
		lastStepTime: 	240685
		lastStepMessage: 	nil
		lastCycleTime: 	240682
		alarms: 	a Heap()
		lastAlarmTime: 	240685
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(760479744))
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(760479744))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1208@742)
		canvas: 	a FormCanvas on: DisplayScreen(1208x742x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(13893632))(a SearchMorph...etc...
		lastStepTime: 	240685
		lastStepMessage: 	nil
		lastCycleTime: 	240682
		alarms: 	a Heap()
		lastAlarmTime: 	240685
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1208@742)
		canvas: 	a FormCanvas on: DisplayScreen(1208x742x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(13893632))(a SearchMorph...etc...
		lastStepTime: 	240685
		lastStepMessage: 	nil
		lastCycleTime: 	240682
		alarms: 	a Heap()
		lastAlarmTime: 	240685
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1208@742)
		canvas: 	a FormCanvas on: DisplayScreen(1208x742x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(13893632))(a SearchMorph...etc...
		lastStepTime: 	240685
		lastStepMessage: 	nil
		lastCycleTime: 	240682
		alarms: 	a Heap()
		lastAlarmTime: 	240685
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1208@742)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a LOGame(425984000) a SystemWindo...etc...
		fullBounds: 	(0@0) corner: (1208@742)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
World doOneCycle.
Processor yield.
false ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
LOGame(Object)>>doesNotUnderstand: #toggleState
LOGame>>toggleNeighboursOfCellAt:at:
[ self toggleNeighboursOfCellAt: i at: j ] in LOGame>>newCellAt:at:
LOCell>>mouseUp:
LOCell(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
LOCell(Morph)>>handleEvent:
LOCell(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: LOGame>>toggleState
16 October 2014 5:06:30.333437 pm

VM: Mac OS - intel - 1090 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30858]

LOGame(Object)>>doesNotUnderstand: #toggleState
	Receiver: a LOGame(425984000)
	Arguments and temporary variables: 
		aMessage: 	toggleState
		exception: 	MessageNotUnderstood: LOGame>>toggleState
		resumeValue: 	nil
	Receiver's instance variables: 
		bounds: 	(5.0@5.0) corner: (169.0@169.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	an Array(a LOCell(839647232) a LOCell(532676608) a LOCell(306184192)...etc...
		fullBounds: 	(5@5) corner: (169@169)
		color: 	Color blue
		extension: 	a MorphExtension (633602048)
		borderWidth: 	2
		borderColor: 	Color black
		cells: 	a Matrix(a LOGame(425984000) a LOGame(425984000) a LOGame(425984000) a L...etc...


LOGame>>toggleNeighboursOfCellAt:at:
	Receiver: a LOGame(425984000)
	Arguments and temporary variables: 
		i: 	6
		j: 	7
	Receiver's instance variables: 
		bounds: 	(5.0@5.0) corner: (169.0@169.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	an Array(a LOCell(839647232) a LOCell(532676608) a LOCell(306184192)...etc...
		fullBounds: 	(5@5) corner: (169@169)
		color: 	Color blue
		extension: 	a MorphExtension (633602048)
		borderWidth: 	2
		borderColor: 	Color black
		cells: 	a Matrix(a LOGame(425984000) a LOGame(425984000) a LOGame(425984000) a L...etc...


[ self toggleNeighboursOfCellAt: i at: j ] in LOGame>>newCellAt:at:
	Receiver: a LOGame(425984000)
	Arguments and temporary variables: 
		i: 	6
		j: 	7
		c: 	nil
		origin: 	nil
	Receiver's instance variables: 
		bounds: 	(5.0@5.0) corner: (169.0@169.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	an Array(a LOCell(839647232) a LOCell(532676608) a LOCell(306184192)...etc...
		fullBounds: 	(5@5) corner: (169@169)
		color: 	Color blue
		extension: 	a MorphExtension (633602048)
		borderWidth: 	2
		borderColor: 	Color black
		cells: 	a Matrix(a LOGame(425984000) a LOGame(425984000) a LOGame(425984000) a L...etc...


LOCell>>mouseUp:
	Receiver: a LOCell(844890112)
	Arguments and temporary variables: 
		anEvent: 	[(101@106) mouseUp 446370 nil]
	Receiver's instance variables: 
		bounds: 	(87.0@103.0) corner: (103.0@119.0)
		owner: 	a LOGame(425984000)
		submorphs: 	an Array(a StringMorph(516685824)'')
		fullBounds: 	(87.0@103.0) corner: (103.0@120.0)
		color: 	Color paleYellow
		extension: 	a MorphExtension (900726784)
		borderWidth: 	2
		borderColor: 	#raised
		target: 	nil
		actionSelector: 	#flash
		arguments: 	#()
		actWhen: 	#buttonUp
		oldColor: 	Color paleYellow
		mouseDownTime: 	nil
		label: 	a StringMorph(516685824)''
		helpText: 	nil
		onColor: 	(Color r: 0.8 g: 0.897 b: 0.915 alpha: 1.0)
		offColor: 	Color paleYellow
		mouseAction: 	[ self toggleNeighboursOfCellAt: i at: j ]


LOCell(Morph)>>handleMouseUp:
	Receiver: a LOCell(844890112)
	Arguments and temporary variables: 
		anEvent: 	[(101@106) mouseUp 446370 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(87.0@103.0) corner: (103.0@119.0)
		owner: 	a LOGame(425984000)
		submorphs: 	an Array(a StringMorph(516685824)'')
		fullBounds: 	(87.0@103.0) corner: (103.0@120.0)
		color: 	Color paleYellow
		extension: 	a MorphExtension (900726784)
		borderWidth: 	2
		borderColor: 	#raised
		target: 	nil
		actionSelector: 	#flash
		arguments: 	#()
		actWhen: 	#buttonUp
		oldColor: 	Color paleYellow
		mouseDownTime: 	nil
		label: 	a StringMorph(516685824)''
		helpText: 	nil
		onColor: 	(Color r: 0.8 g: 0.897 b: 0.915 alpha: 1.0)
		offColor: 	Color paleYellow
		mouseAction: 	[ self toggleNeighboursOfCellAt: i at: j ]


MouseButtonEvent>>sentTo:
	Receiver: [(101@106) mouseUp 446370 nil]
	Arguments and temporary variables: 
		anObject: 	a LOCell(844890112)
	Receiver's instance variables: 
		timeStamp: 	446370
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(101@106)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


LOCell(Morph)>>handleEvent:
	Receiver: a LOCell(844890112)
	Arguments and temporary variables: 
		anEvent: 	[(101@106) mouseUp 446370 nil]
	Receiver's instance variables: 
		bounds: 	(87.0@103.0) corner: (103.0@119.0)
		owner: 	a LOGame(425984000)
		submorphs: 	an Array(a StringMorph(516685824)'')
		fullBounds: 	(87.0@103.0) corner: (103.0@120.0)
		color: 	Color paleYellow
		extension: 	a MorphExtension (900726784)
		borderWidth: 	2
		borderColor: 	#raised
		target: 	nil
		actionSelector: 	#flash
		arguments: 	#()
		actWhen: 	#buttonUp
		oldColor: 	Color paleYellow
		mouseDownTime: 	nil
		label: 	a StringMorph(516685824)''
		helpText: 	nil
		onColor: 	(Color r: 0.8 g: 0.897 b: 0.915 alpha: 1.0)
		offColor: 	Color paleYellow
		mouseAction: 	[ self toggleNeighboursOfCellAt: i at: j ]


LOCell(Morph)>>handleFocusEvent:
	Receiver: a LOCell(844890112)
	Arguments and temporary variables: 
		anEvent: 	[(101@106) mouseUp 446370 nil]
	Receiver's instance variables: 
		bounds: 	(87.0@103.0) corner: (103.0@119.0)
		owner: 	a LOGame(425984000)
		submorphs: 	an Array(a StringMorph(516685824)'')
		fullBounds: 	(87.0@103.0) corner: (103.0@120.0)
		color: 	Color paleYellow
		extension: 	a MorphExtension (900726784)
		borderWidth: 	2
		borderColor: 	#raised
		target: 	nil
		actionSelector: 	#flash
		arguments: 	#()
		actWhen: 	#buttonUp
		oldColor: 	Color paleYellow
		mouseDownTime: 	nil
		label: 	a StringMorph(516685824)''
		helpText: 	nil
		onColor: 	(Color r: 0.8 g: 0.897 b: 0.915 alpha: 1.0)
		offColor: 	Color paleYellow
		mouseAction: 	[ self toggleNeighboursOfCellAt: i at: j ]


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(101@106) mouseUp 446370 nil]
		focusHolder: 	a LOCell(844890112)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(101@106.0) corner: (117@122.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(101@106.0) corner: (117@122.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableIconListMorph(385875968)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(101@106) mouseUp 446370 nil]
		targetOffset: 	(14.0@3.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 446370 101 106 0 0 0 1)
		lastKeyScanCode: 	1
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	[(101@106) mouseOver red nil nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1208@742)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a NautilusWindow(37748736) a Syst...etc...
		fullBounds: 	(0@0) corner: (1208@742)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(101@106) mouseUp 446370 nil]
		focusHolder: 	a LOCell(844890112)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		bounds: 	(101@106.0) corner: (117@122.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(101@106.0) corner: (117@122.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableIconListMorph(385875968)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(101@106) mouseUp 446370 nil]
		targetOffset: 	(14.0@3.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 446370 101 106 0 0 0 1)
		lastKeyScanCode: 	1
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(101@106) mouseUp 446370 nil]
		focusHolder: 	a LOCell(844890112)
		aBlock: 	[ self mouseFocus: nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(101@106.0) corner: (117@122.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(101@106.0) corner: (117@122.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableIconListMorph(385875968)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(101@106) mouseUp 446370 nil]
		targetOffset: 	(14.0@3.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 446370 101 106 0 0 0 1)
		lastKeyScanCode: 	1
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(101@106) mouseUp 446370 nil]
	Receiver's instance variables: 
		bounds: 	(101@106.0) corner: (117@122.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(101@106.0) corner: (117@122.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableIconListMorph(385875968)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(101@106) mouseUp 446370 nil]
		targetOffset: 	(14.0@3.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 446370 101 106 0 0 0 1)
		lastKeyScanCode: 	1
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>handleEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(101@106) mouseUp 446370 nil]
		evt: 	[(101@106) mouseUp 446370 nil]
	Receiver's instance variables: 
		bounds: 	(101@106.0) corner: (117@122.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(101@106.0) corner: (117@122.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableIconListMorph(385875968)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(101@106) mouseUp 446370 nil]
		targetOffset: 	(14.0@3.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 446370 101 106 0 0 0 1)
		lastKeyScanCode: 	1
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>processEvents
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		evt: 	[(101@106) mouseUp 446370 nil]
		evtBuf: 	#(1 446370 101 106 0 0 0 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	(101@106.0) corner: (117@122.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(101@106.0) corner: (117@122.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableIconListMorph(385875968)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(101@106) mouseUp 446370 nil]
		targetOffset: 	(14.0@3.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 446370 101 106 0 0 0 1)
		lastKeyScanCode: 	1
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		h: 	a HandMorph(760479744)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1208@742)
		canvas: 	a FormCanvas on: DisplayScreen(1208x742x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(13893632))(a SearchMorph...etc...
		lastStepTime: 	446357
		lastStepMessage: 	nil
		lastCycleTime: 	446379
		alarms: 	a Heap()
		lastAlarmTime: 	446357
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(760479744))
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(760479744))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1208@742)
		canvas: 	a FormCanvas on: DisplayScreen(1208x742x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(13893632))(a SearchMorph...etc...
		lastStepTime: 	446357
		lastStepMessage: 	nil
		lastCycleTime: 	446379
		alarms: 	a Heap()
		lastAlarmTime: 	446357
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1208@742)
		canvas: 	a FormCanvas on: DisplayScreen(1208x742x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(13893632))(a SearchMorph...etc...
		lastStepTime: 	446357
		lastStepMessage: 	nil
		lastCycleTime: 	446379
		alarms: 	a Heap()
		lastAlarmTime: 	446357
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1208@742)
		canvas: 	a FormCanvas on: DisplayScreen(1208x742x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(13893632))(a SearchMorph...etc...
		lastStepTime: 	446357
		lastStepMessage: 	nil
		lastCycleTime: 	446379
		alarms: 	a Heap()
		lastAlarmTime: 	446357
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1208@742)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a NautilusWindow(37748736) a Syst...etc...
		fullBounds: 	(0@0) corner: (1208@742)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
World doOneCycle.
Processor yield.
false ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
LOGame(Object)>>doesNotUnderstand: #toggleState
LOGame>>toggleNeighboursOfCellAt:at:
[ self toggleNeighboursOfCellAt: i at: j ] in LOGame>>newCellAt:at:
LOCell>>mouseUp:
LOCell(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
LOCell(Morph)>>handleEvent:
LOCell(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: receiver of "super" is nil
17 October 2014 2:06:40.244207 pm

VM: Mac OS - intel - 1090 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30858]

UndefinedObject(Object)>>doesNotUnderstand: #super
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	super
		exception: 	MessageNotUnderstood: receiver of "super" is nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

AssignmentTemp class>>DoIt
	Receiver: AssignmentTemp
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	BorderedMorph
		methodDict: 	a MethodDictionary()
		format: 	146
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#AssignmentTemp
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#Assignment
		traitComposition: 	{}
		localSelectors: 	nil
		announcer: 	nil
		initialize: 	nil
		bounds: 	nil


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'initialize
	super initialize.
	self label: ''''.
	self borderW...etc...
		itsSelection: 	a Text for 'initialize
	super initialize.
	self label: ''''.
	sel...etc...
		itsSelectionString: 	'initialize
	super initialize.
	self label: ''''.
	self bor...etc...
	Receiver's instance variables: 
		ast: 	DoIt
	initialize super initialize.
	self label: ''.
	self borderWidth: 2.
...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	AssignmentTemp
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


SmalltalkEditor>>evaluateSelectionAndDo:
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | result ]
		result: 	nil
		rcvr: 	AssignmentTemp
		ctxt: 	nil
	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(442236928)
		selectionShowing: 	true
		model: 	a PackageTreeNautilusUI
		editingState: 	a SmalltalkEditingState


SmalltalkEditor>>evaluateSelection
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(442236928)
		selectionShowing: 	true
		model: 	a PackageTreeNautilusUI
		editingState: 	a SmalltalkEditingState


[ textMorph editor evaluateSelection ] in PluggableTextMorphWithLimits(PluggableTextMorph)>>doIt
	Receiver: a PluggableTextMorphWithLimits(722731008)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(252.0@349.0) corner: (1068.0@626.0)
		owner: 	a MultipleMethodsEditor(338690048)
		submorphs: 	an Array(an AlphaImageMorph(528744448) a TransformMorph(173015040))
		fullBounds: 	(252@349) corner: (1068@626)
		color: 	Color white
		extension: 	a MorphExtension (408944640) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(770441216)
		scroller: 	a TransformMorph(173015040)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(479985664)
		textMorph: 	a TextMorphForEditView(442236928)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 122)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	350
		method: 	nil
		lockIcon: 	an AlphaImageMorph(528744448)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


[ result := editBlock value ] in PluggableTextMorphWithLimits(PluggableTextMorph)>>handleEdit:
	Receiver: a PluggableTextMorphWithLimits(722731008)
	Arguments and temporary variables: 
		editBlock: 	[ textMorph editor evaluateSelection ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(252.0@349.0) corner: (1068.0@626.0)
		owner: 	a MultipleMethodsEditor(338690048)
		submorphs: 	an Array(an AlphaImageMorph(528744448) a TransformMorph(173015040))
		fullBounds: 	(252@349) corner: (1068@626)
		color: 	Color white
		extension: 	a MorphExtension (408944640) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(770441216)
		scroller: 	a TransformMorph(173015040)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(479985664)
		textMorph: 	a TextMorphForEditView(442236928)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 122)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	350
		method: 	nil
		lockIcon: 	an AlphaImageMorph(528744448)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


TextMorphForEditView(TextMorph)>>handleEdit:
	Receiver: a TextMorphForEditView(442236928)
	Arguments and temporary variables: 
		editBlock: 	[ result := editBlock value ]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (808@98)
		owner: 	a TransformMorph(173015040)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (808@98)
		color: 	Color black
		extension: 	a MorphExtension (497025024) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'initialize
	super initialize.
	self label: ''''.
	self border...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorphWithLimits(722731008)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


PluggableTextMorphWithLimits(PluggableTextMorph)>>handleEdit:
	Receiver: a PluggableTextMorphWithLimits(722731008)
	Arguments and temporary variables: 
		result: 	nil
		editBlock: 	[ textMorph editor evaluateSelection ]
	Receiver's instance variables: 
		bounds: 	(252.0@349.0) corner: (1068.0@626.0)
		owner: 	a MultipleMethodsEditor(338690048)
		submorphs: 	an Array(an AlphaImageMorph(528744448) a TransformMorph(173015040))
		fullBounds: 	(252@349) corner: (1068@626)
		color: 	Color white
		extension: 	a MorphExtension (408944640) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(770441216)
		scroller: 	a TransformMorph(173015040)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(479985664)
		textMorph: 	a TextMorphForEditView(442236928)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 122)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	350
		method: 	nil
		lockIcon: 	an AlphaImageMorph(528744448)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


PluggableTextMorphWithLimits(PluggableTextMorph)>>doIt
	Receiver: a PluggableTextMorphWithLimits(722731008)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(252.0@349.0) corner: (1068.0@626.0)
		owner: 	a MultipleMethodsEditor(338690048)
		submorphs: 	an Array(an AlphaImageMorph(528744448) a TransformMorph(173015040))
		fullBounds: 	(252@349) corner: (1068@626)
		color: 	Color white
		extension: 	a MorphExtension (408944640) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(770441216)
		scroller: 	a TransformMorph(173015040)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(479985664)
		textMorph: 	a TextMorphForEditView(442236928)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 122)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	350
		method: 	nil
		lockIcon: 	an AlphaImageMorph(528744448)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


[ :target | target sourceTextArea doIt ] in AbstractNautilusUI class>>buildEditorKeymappingsOn:
	Receiver: AbstractNautilusUI
	Arguments and temporary variables: 
		aBuilder: 	a PragmaMenuAndShortcutRegistration
		target: 	a PackageTreeNautilusUI
	Receiver's instance variables: 
		superclass: 	AbstractTool
		methodDict: 	a MethodDictionary(size 430)
		format: 	180
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #window #hierarchyClass #cachedHierarchy #sourceTex...etc...
		organization: 	a ClassOrganization
		subclasses: 	{NautilusUI}
		name: 	#AbstractNautilusUI
		classPool: 	a Dictionary(#ClassesIconsCache->a WeakIdentityKeyDictionary(AnObsol...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#Nautilus
		traitComposition: 	{}
		localSelectors: 	nil


BlockClosure>>cull:
	Receiver: [ :target | target sourceTextArea doIt ]
	Arguments and temporary variables: 
		anArg: 	a PackageTreeNautilusUI
	Receiver's instance variables: 
		outerContext: 	AbstractNautilusUI class>>buildEditorKeymappingsOn:
		startpc: 	468
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :target | target sourceTextArea doIt ]
	Arguments and temporary variables: 
		firstArg: 	a PackageTreeNautilusUI
		secondArg: 	a PluggableTextMorphWithLimits(722731008)
	Receiver's instance variables: 
		outerContext: 	AbstractNautilusUI class>>buildEditorKeymappingsOn:
		startpc: 	468
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :target | target sourceTextArea doIt ]
	Arguments and temporary variables: 
		firstArg: 	a PackageTreeNautilusUI
		secondArg: 	a PluggableTextMorphWithLimits(722731008)
		thirdArg: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		outerContext: 	AbstractNautilusUI class>>buildEditorKeymappingsOn:
		startpc: 	468
		numArgs: 	1


KMCategoryBinding>>completeMatch:buffer:
	Receiver: aKMCategoryTarget(#NautilusSourceCodeShortcuts)
	Arguments and temporary variables: 
		aKeymap: 	#doIt on Cmd + D do [ :target | target sourceTextArea doIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
	Receiver's instance variables: 
		target: 	a PackageTreeNautilusUI
		category: 	a KMCategory
		morph: 	a PluggableTextMorphWithLimits(722731008)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #doIt on Cmd + D do [ :target | target sourceTextArea doIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#NautilusSourceCodeShortcuts) a KMDispatc...etc...
		aBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		listeners: 	an Array(aKMCategoryTarget(#NautilusSourceCodeShortcuts) a KMDispatc...etc...
		l: 	aKMCategoryTarget(#NautilusSourceCodeShortcuts)
	Receiver's instance variables: 
		action: 	[ :target | target sourceTextArea doIt ]
		name: 	#doIt
		shortcut: 	Cmd + D
		defaultShortcut: 	Cmd + D
		description: 	''


Array(SequenceableCollection)>>do:
	Receiver: an Array(aKMCategoryTarget(#NautilusSourceCodeShortcuts) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(aKMCategoryTarget(#NautilusSourceCodeShortcuts) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #doIt on Cmd + D do [ :target | target sourceTextArea doIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#NautilusSourceCodeShortcuts) a KMDispatc...etc...
		aBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		listeners: 	an Array(aKMCategoryTarget(#NautilusSourceCodeShortcuts) a KMDispatc...etc...
	Receiver's instance variables: 
		action: 	[ :target | target sourceTextArea doIt ]
		name: 	#doIt
		shortcut: 	Cmd + D
		defaultShortcut: 	Cmd + D
		description: 	''


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: #doIt on Cmd + D do [ :target | target sourceTextArea doIt ]

	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#NautilusSourceCodeShortcuts) a KMDi...etc...
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		action: 	[ :target | target sourceTextArea doIt ]
		name: 	#doIt
		shortcut: 	Cmd + D
		defaultShortcut: 	Cmd + D
		description: 	''


[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#NautilusSourceCodeShortcuts) a KMDi...etc...
		aBlock: 	[ ^ self ]
		entry: 	#doIt on Cmd + D do [ :target | target sourceTextArea doIt ]

	Receiver's instance variables: 
		name: 	#NautilusSourceCodeShortcuts
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(#cut on Cmd + X do [ :target | target sourceTextArea cut ]
 #cancel on Cmd + L do [ ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	15
		each: 	#doIt on Cmd + D do [ :target | target sourceTextArea doIt ]

	Receiver's instance variables: 
		tally: 	23
		array: 	an Array(nil nil #cut on Cmd + X do [ :target | target sourceTextArea cu...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#NautilusSourceCodeShortcuts) a KMDi...etc...
		aBlock: 	[ ^ self ]
	Receiver's instance variables: 
		name: 	#NautilusSourceCodeShortcuts
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: aKMCategoryTarget(#NautilusSourceCodeShortcuts)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		target: 	a PackageTreeNautilusUI
		category: 	a KMCategory
		morph: 	a PluggableTextMorphWithLimits(722731008)


[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#NautilusSourceCodeShortcuts)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#NautilusSourceC...etc...
		morph: 	a PluggableTextMorphWithLimits(722731008)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#TextMorph) aKMCategoryTarge...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	3
	Receiver's instance variables: 
		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#TextMorph) aKMCategor...etc...
		firstIndex: 	1
		lastIndex: 	8


KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		association: 	nil
		match: 	nil
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#NautilusSourceC...etc...
		morph: 	a PluggableTextMorphWithLimits(722731008)
		directKeymaps: 	a KMCategory


KMTarget>>dispatch:
	Receiver: a KMTarget
	Arguments and temporary variables: 
		buffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
	Receiver's instance variables: 
		realTarget: 	nil
		morph: 	a PluggableTextMorphWithLimits(722731008)
		targetSelector: 	#yourself
		directKeymaps: 	nil
		perInstanceCategories: 	nil


[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Cmd-d>']
		targetToDispatch: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>do:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatcher>>dispatchKeystroke:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		aKeyEvent: 	[keystroke '<Cmd-d>']
		chain: 	a KMDispatchChain
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...
		morph: 	a TextMorphForEditView(442236928)
		directKeymaps: 	a KMCategory


TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
	Receiver: a TextMorphForEditView(442236928)
	Arguments and temporary variables: 
		evt: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (808@98)
		owner: 	a TransformMorph(173015040)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (808@98)
		color: 	Color black
		extension: 	a MorphExtension (497025024) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'initialize
	super initialize.
	self label: ''''.
	self border...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorphWithLimits(722731008)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(TextMorph)>>handleKeystroke:
	Receiver: a TextMorphForEditView(442236928)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-d>']
		pasteUp: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (808@98)
		owner: 	a TransformMorph(173015040)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (808@98)
		color: 	Color black
		extension: 	a MorphExtension (497025024) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'initialize
	super initialize.
	self label: ''''.
	self border...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorphWithLimits(722731008)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


KeyboardEvent>>sentTo:
	Receiver: [keystroke '<Cmd-d>']
	Arguments and temporary variables: 
		anObject: 	a TextMorphForEditView(442236928)
	Receiver's instance variables: 
		timeStamp: 	682495
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#keystroke
		buttons: 	64
		position: 	(227@120.0)
		handler: 	nil
		wasHandled: 	true
		keyValue: 	100
		charCode: 	100
		scanCode: 	2


TextMorphForEditView(Morph)>>handleEvent:
	Receiver: a TextMorphForEditView(442236928)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (808@98)
		owner: 	a TransformMorph(173015040)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (808@98)
		color: 	Color black
		extension: 	a MorphExtension (497025024) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'initialize
	super initialize.
	self label: ''''.
	self border...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorphWithLimits(722731008)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(Morph)>>handleFocusEvent:
	Receiver: a TextMorphForEditView(442236928)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (808@98)
		owner: 	a TransformMorph(173015040)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (808@98)
		color: 	Color black
		extension: 	a MorphExtension (497025024) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'initialize
	super initialize.
	self label: ''''.
	self border...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorphWithLimits(722731008)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-d>']
		focusHolder: 	a TextMorphForEditView(442236928)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(441@502.0) corner: (457@518.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a TextMorphForEditView(442236928)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(425@484) mouseOver nil nil]
		targetOffset: 	(186.0@7.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	Form(16x16x8)
		temporaryCursorOffset: 	(-8@ -9)
		hardwareCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r...etc...
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 693299 425 484 0 0 0 1)
		lastKeyScanCode: 	2
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1208@742)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a NautilusWindow(37748736) an Ima...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #super
AssignmentTemp class>>DoIt
OpalCompiler>>evaluate
SmalltalkEditor>>evaluateSelectionAndDo:
SmalltalkEditor>>evaluateSelection
[ textMorph editor evaluateSelection ] in PluggableTextMorphWithLimits(PluggableTextMorph)>>doIt
[ result := editBlock value ] in PluggableTextMorphWithLimits(PluggableTextMorph)>>handleEdit:
TextMorphForEditView(TextMorph)>>handleEdit:
PluggableTextMorphWithLimits(PluggableTextMorph)>>handleEdit:
PluggableTextMorphWithLimits(PluggableTextMorph)>>doIt
[ :target | target sourceTextArea doIt ] in AbstractNautilusUI class>>buildEditorKeymappingsOn:
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
TextMorphForEditView(TextMorph)>>handleKeystroke:
KeyboardEvent>>sentTo:
TextMorphForEditView(Morph)>>handleEvent:
TextMorphForEditView(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: receiver of "super" is nil
17 October 2014 2:06:44.487006 pm

VM: Mac OS - intel - 1090 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30858]

UndefinedObject(Object)>>doesNotUnderstand: #super
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	super
		exception: 	MessageNotUnderstood: receiver of "super" is nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

Message>>sentTo:
	Receiver: super
	Arguments and temporary variables: 
		receiver: 	nil
	Receiver's instance variables: 
		selector: 	#super
		args: 	#()
		lookupClass: 	UndefinedObject


UndefinedObject(Object)>>doesNotUnderstand: #super
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	super
		exception: 	MessageNotUnderstood: receiver of "super" is nil
		resumeValue: 	MessageNotUnderstood: receiver of "super" is nil
	Receiver's instance variables: 
nil

AssignmentTemp class>>DoIt
	Receiver: AssignmentTemp
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	BorderedMorph
		methodDict: 	a MethodDictionary()
		format: 	146
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#AssignmentTemp
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#Assignment
		traitComposition: 	{}
		localSelectors: 	nil
		announcer: 	nil
		initialize: 	nil
		bounds: 	nil


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'initialize
	super initialize.
	self label: ''''.
	self borderW...etc...
		itsSelection: 	a Text for 'initialize
	super initialize.
	self label: ''''.
	sel...etc...
		itsSelectionString: 	'initialize
	super initialize.
	self label: ''''.
	self bor...etc...
	Receiver's instance variables: 
		ast: 	DoIt
	initialize super initialize.
	self label: ''.
	self borderWidth: 2.
...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	AssignmentTemp
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


SmalltalkEditor>>evaluateSelectionAndDo:
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | result ]
		result: 	nil
		rcvr: 	AssignmentTemp
		ctxt: 	nil
	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(442236928)
		selectionShowing: 	true
		model: 	a PackageTreeNautilusUI
		editingState: 	a SmalltalkEditingState


SmalltalkEditor>>evaluateSelection
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(442236928)
		selectionShowing: 	true
		model: 	a PackageTreeNautilusUI
		editingState: 	a SmalltalkEditingState


[ textMorph editor evaluateSelection ] in PluggableTextMorphWithLimits(PluggableTextMorph)>>doIt
	Receiver: a PluggableTextMorphWithLimits(722731008)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(252.0@349.0) corner: (1068.0@626.0)
		owner: 	a MultipleMethodsEditor(338690048)
		submorphs: 	an Array(an AlphaImageMorph(528744448) a TransformMorph(173015040))
		fullBounds: 	(252@349) corner: (1068@626)
		color: 	Color white
		extension: 	a MorphExtension (408944640) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(770441216)
		scroller: 	a TransformMorph(173015040)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(479985664)
		textMorph: 	a TextMorphForEditView(442236928)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 122)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	350
		method: 	nil
		lockIcon: 	an AlphaImageMorph(528744448)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


[ result := editBlock value ] in PluggableTextMorphWithLimits(PluggableTextMorph)>>handleEdit:
	Receiver: a PluggableTextMorphWithLimits(722731008)
	Arguments and temporary variables: 
		editBlock: 	[ textMorph editor evaluateSelection ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(252.0@349.0) corner: (1068.0@626.0)
		owner: 	a MultipleMethodsEditor(338690048)
		submorphs: 	an Array(an AlphaImageMorph(528744448) a TransformMorph(173015040))
		fullBounds: 	(252@349) corner: (1068@626)
		color: 	Color white
		extension: 	a MorphExtension (408944640) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(770441216)
		scroller: 	a TransformMorph(173015040)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(479985664)
		textMorph: 	a TextMorphForEditView(442236928)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 122)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	350
		method: 	nil
		lockIcon: 	an AlphaImageMorph(528744448)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


TextMorphForEditView(TextMorph)>>handleEdit:
	Receiver: a TextMorphForEditView(442236928)
	Arguments and temporary variables: 
		editBlock: 	[ result := editBlock value ]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (808@98)
		owner: 	a TransformMorph(173015040)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (808@98)
		color: 	Color black
		extension: 	a MorphExtension (497025024) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'initialize
	super initialize.
	self label: ''''.
	self border...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorphWithLimits(722731008)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


PluggableTextMorphWithLimits(PluggableTextMorph)>>handleEdit:
	Receiver: a PluggableTextMorphWithLimits(722731008)
	Arguments and temporary variables: 
		result: 	nil
		editBlock: 	[ textMorph editor evaluateSelection ]
	Receiver's instance variables: 
		bounds: 	(252.0@349.0) corner: (1068.0@626.0)
		owner: 	a MultipleMethodsEditor(338690048)
		submorphs: 	an Array(an AlphaImageMorph(528744448) a TransformMorph(173015040))
		fullBounds: 	(252@349) corner: (1068@626)
		color: 	Color white
		extension: 	a MorphExtension (408944640) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(770441216)
		scroller: 	a TransformMorph(173015040)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(479985664)
		textMorph: 	a TextMorphForEditView(442236928)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 122)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	350
		method: 	nil
		lockIcon: 	an AlphaImageMorph(528744448)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


PluggableTextMorphWithLimits(PluggableTextMorph)>>doIt
	Receiver: a PluggableTextMorphWithLimits(722731008)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(252.0@349.0) corner: (1068.0@626.0)
		owner: 	a MultipleMethodsEditor(338690048)
		submorphs: 	an Array(an AlphaImageMorph(528744448) a TransformMorph(173015040))
		fullBounds: 	(252@349) corner: (1068@626)
		color: 	Color white
		extension: 	a MorphExtension (408944640) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(770441216)
		scroller: 	a TransformMorph(173015040)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(479985664)
		textMorph: 	a TextMorphForEditView(442236928)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 122)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	350
		method: 	nil
		lockIcon: 	an AlphaImageMorph(528744448)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


[ :target | target sourceTextArea doIt ] in AbstractNautilusUI class>>buildEditorKeymappingsOn:
	Receiver: AbstractNautilusUI
	Arguments and temporary variables: 
		aBuilder: 	a PragmaMenuAndShortcutRegistration
		target: 	a PackageTreeNautilusUI
	Receiver's instance variables: 
		superclass: 	AbstractTool
		methodDict: 	a MethodDictionary(size 430)
		format: 	180
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #window #hierarchyClass #cachedHierarchy #sourceTex...etc...
		organization: 	a ClassOrganization
		subclasses: 	{NautilusUI}
		name: 	#AbstractNautilusUI
		classPool: 	a Dictionary(#ClassesIconsCache->a WeakIdentityKeyDictionary(AnObsol...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#Nautilus
		traitComposition: 	{}
		localSelectors: 	nil


BlockClosure>>cull:
	Receiver: [ :target | target sourceTextArea doIt ]
	Arguments and temporary variables: 
		anArg: 	a PackageTreeNautilusUI
	Receiver's instance variables: 
		outerContext: 	AbstractNautilusUI class>>buildEditorKeymappingsOn:
		startpc: 	468
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :target | target sourceTextArea doIt ]
	Arguments and temporary variables: 
		firstArg: 	a PackageTreeNautilusUI
		secondArg: 	a PluggableTextMorphWithLimits(722731008)
	Receiver's instance variables: 
		outerContext: 	AbstractNautilusUI class>>buildEditorKeymappingsOn:
		startpc: 	468
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :target | target sourceTextArea doIt ]
	Arguments and temporary variables: 
		firstArg: 	a PackageTreeNautilusUI
		secondArg: 	a PluggableTextMorphWithLimits(722731008)
		thirdArg: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		outerContext: 	AbstractNautilusUI class>>buildEditorKeymappingsOn:
		startpc: 	468
		numArgs: 	1


KMCategoryBinding>>completeMatch:buffer:
	Receiver: aKMCategoryTarget(#NautilusSourceCodeShortcuts)
	Arguments and temporary variables: 
		aKeymap: 	#doIt on Cmd + D do [ :target | target sourceTextArea doIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
	Receiver's instance variables: 
		target: 	a PackageTreeNautilusUI
		category: 	a KMCategory
		morph: 	a PluggableTextMorphWithLimits(722731008)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #doIt on Cmd + D do [ :target | target sourceTextArea doIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#NautilusSourceCodeShortcuts) a KMDispatc...etc...
		aBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		listeners: 	an Array(aKMCategoryTarget(#NautilusSourceCodeShortcuts) a KMDispatc...etc...
		l: 	aKMCategoryTarget(#NautilusSourceCodeShortcuts)
	Receiver's instance variables: 
		action: 	[ :target | target sourceTextArea doIt ]
		name: 	#doIt
		shortcut: 	Cmd + D
		defaultShortcut: 	Cmd + D
		description: 	''


Array(SequenceableCollection)>>do:
	Receiver: an Array(aKMCategoryTarget(#NautilusSourceCodeShortcuts) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(aKMCategoryTarget(#NautilusSourceCodeShortcuts) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #doIt on Cmd + D do [ :target | target sourceTextArea doIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#NautilusSourceCodeShortcuts) a KMDispatc...etc...
		aBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		listeners: 	an Array(aKMCategoryTarget(#NautilusSourceCodeShortcuts) a KMDispatc...etc...
	Receiver's instance variables: 
		action: 	[ :target | target sourceTextArea doIt ]
		name: 	#doIt
		shortcut: 	Cmd + D
		defaultShortcut: 	Cmd + D
		description: 	''


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: #doIt on Cmd + D do [ :target | target sourceTextArea doIt ]

	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#NautilusSourceCodeShortcuts) a KMDi...etc...
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		action: 	[ :target | target sourceTextArea doIt ]
		name: 	#doIt
		shortcut: 	Cmd + D
		defaultShortcut: 	Cmd + D
		description: 	''


[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#NautilusSourceCodeShortcuts) a KMDi...etc...
		aBlock: 	[ ^ self ]
		entry: 	#doIt on Cmd + D do [ :target | target sourceTextArea doIt ]

	Receiver's instance variables: 
		name: 	#NautilusSourceCodeShortcuts
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(#cut on Cmd + X do [ :target | target sourceTextArea cut ]
 #cancel on Cmd + L do [ ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	15
		each: 	#doIt on Cmd + D do [ :target | target sourceTextArea doIt ]

	Receiver's instance variables: 
		tally: 	23
		array: 	an Array(nil nil #cut on Cmd + X do [ :target | target sourceTextArea cu...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#NautilusSourceCodeShortcuts) a KMDi...etc...
		aBlock: 	[ ^ self ]
	Receiver's instance variables: 
		name: 	#NautilusSourceCodeShortcuts
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: aKMCategoryTarget(#NautilusSourceCodeShortcuts)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		target: 	a PackageTreeNautilusUI
		category: 	a KMCategory
		morph: 	a PluggableTextMorphWithLimits(722731008)


[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#NautilusSourceCodeShortcuts)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#NautilusSourceC...etc...
		morph: 	a PluggableTextMorphWithLimits(722731008)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#TextMorph) aKMCategoryTarge...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	3
	Receiver's instance variables: 
		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#TextMorph) aKMCategor...etc...
		firstIndex: 	1
		lastIndex: 	8


KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		association: 	nil
		match: 	nil
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#NautilusSourceC...etc...
		morph: 	a PluggableTextMorphWithLimits(722731008)
		directKeymaps: 	a KMCategory


KMTarget>>dispatch:
	Receiver: a KMTarget
	Arguments and temporary variables: 
		buffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
	Receiver's instance variables: 
		realTarget: 	nil
		morph: 	a PluggableTextMorphWithLimits(722731008)
		targetSelector: 	#yourself
		directKeymaps: 	nil
		perInstanceCategories: 	nil


[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Cmd-d>']
		targetToDispatch: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>do:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatcher>>dispatchKeystroke:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		aKeyEvent: 	[keystroke '<Cmd-d>']
		chain: 	a KMDispatchChain
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...
		morph: 	a TextMorphForEditView(442236928)
		directKeymaps: 	a KMCategory


TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
	Receiver: a TextMorphForEditView(442236928)
	Arguments and temporary variables: 
		evt: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (808@98)
		owner: 	a TransformMorph(173015040)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (808@98)
		color: 	Color black
		extension: 	a MorphExtension (497025024) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'initialize
	super initialize.
	self label: ''''.
	self border...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorphWithLimits(722731008)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(TextMorph)>>handleKeystroke:
	Receiver: a TextMorphForEditView(442236928)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-d>']
		pasteUp: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (808@98)
		owner: 	a TransformMorph(173015040)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (808@98)
		color: 	Color black
		extension: 	a MorphExtension (497025024) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'initialize
	super initialize.
	self label: ''''.
	self border...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorphWithLimits(722731008)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


KeyboardEvent>>sentTo:
	Receiver: [keystroke '<Cmd-d>']
	Arguments and temporary variables: 
		anObject: 	a TextMorphForEditView(442236928)
	Receiver's instance variables: 
		timeStamp: 	682495
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#keystroke
		buttons: 	64
		position: 	(227@120.0)
		handler: 	nil
		wasHandled: 	true
		keyValue: 	100
		charCode: 	100
		scanCode: 	2


TextMorphForEditView(Morph)>>handleEvent:
	Receiver: a TextMorphForEditView(442236928)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (808@98)
		owner: 	a TransformMorph(173015040)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (808@98)
		color: 	Color black
		extension: 	a MorphExtension (497025024) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'initialize
	super initialize.
	self label: ''''.
	self border...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorphWithLimits(722731008)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(Morph)>>handleFocusEvent:
	Receiver: a TextMorphForEditView(442236928)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (808@98)
		owner: 	a TransformMorph(173015040)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (808@98)
		color: 	Color black
		extension: 	a MorphExtension (497025024) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'initialize
	super initialize.
	self label: ''''.
	self border...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorphWithLimits(722731008)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-d>']
		focusHolder: 	a TextMorphForEditView(442236928)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(395@87.0) corner: (411@103.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(395@87.0) corner: (411@103.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(834404352)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(395@87) mouseUp 697845 nil]
		targetOffset: 	(123.0@8.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 697845 395 87 0 0 0 1)
		lastKeyScanCode: 	2
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #super
Message>>sentTo:
UndefinedObject(Object)>>doesNotUnderstand: #super
AssignmentTemp class>>DoIt
OpalCompiler>>evaluate
SmalltalkEditor>>evaluateSelectionAndDo:
SmalltalkEditor>>evaluateSelection
[ textMorph editor evaluateSelection ] in PluggableTextMorphWithLimits(PluggableTextMorph)>>doIt
[ result := editBlock value ] in PluggableTextMorphWithLimits(PluggableTextMorph)>>handleEdit:
TextMorphForEditView(TextMorph)>>handleEdit:
PluggableTextMorphWithLimits(PluggableTextMorph)>>handleEdit:
PluggableTextMorphWithLimits(PluggableTextMorph)>>doIt
[ :target | target sourceTextArea doIt ] in AbstractNautilusUI class>>buildEditorKeymappingsOn:
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
TextMorphForEditView(TextMorph)>>handleKeystroke:
KeyboardEvent>>sentTo:
TextMorphForEditView(Morph)>>handleEvent:
TextMorphForEditView(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: receiver of "super" is nil
17 October 2014 2:06:45.87933 pm

VM: Mac OS - intel - 1090 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30858]

UndefinedObject(Object)>>doesNotUnderstand: #super
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	super
		exception: 	MessageNotUnderstood: receiver of "super" is nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

Message>>sentTo:
	Receiver: super
	Arguments and temporary variables: 
		receiver: 	nil
	Receiver's instance variables: 
		selector: 	#super
		args: 	#()
		lookupClass: 	UndefinedObject


UndefinedObject(Object)>>doesNotUnderstand: #super
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	super
		exception: 	MessageNotUnderstood: receiver of "super" is nil
		resumeValue: 	MessageNotUnderstood: receiver of "super" is nil
	Receiver's instance variables: 
nil

Message>>sentTo:
	Receiver: super
	Arguments and temporary variables: 
		receiver: 	nil
	Receiver's instance variables: 
		selector: 	#super
		args: 	#()
		lookupClass: 	UndefinedObject


UndefinedObject(Object)>>doesNotUnderstand: #super
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	super
		exception: 	MessageNotUnderstood: receiver of "super" is nil
		resumeValue: 	MessageNotUnderstood: receiver of "super" is nil
	Receiver's instance variables: 
nil

AssignmentTemp class>>DoIt
	Receiver: AssignmentTemp
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	BorderedMorph
		methodDict: 	a MethodDictionary()
		format: 	146
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#AssignmentTemp
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#Assignment
		traitComposition: 	{}
		localSelectors: 	nil
		announcer: 	nil
		initialize: 	nil
		bounds: 	nil


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'initialize
	super initialize.
	self label: ''''.
	self borderW...etc...
		itsSelection: 	a Text for 'initialize
	super initialize.
	self label: ''''.
	sel...etc...
		itsSelectionString: 	'initialize
	super initialize.
	self label: ''''.
	self bor...etc...
	Receiver's instance variables: 
		ast: 	DoIt
	initialize super initialize.
	self label: ''.
	self borderWidth: 2.
...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	AssignmentTemp
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


SmalltalkEditor>>evaluateSelectionAndDo:
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | result ]
		result: 	nil
		rcvr: 	AssignmentTemp
		ctxt: 	nil
	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(442236928)
		selectionShowing: 	true
		model: 	a PackageTreeNautilusUI
		editingState: 	a SmalltalkEditingState


SmalltalkEditor>>evaluateSelection
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(442236928)
		selectionShowing: 	true
		model: 	a PackageTreeNautilusUI
		editingState: 	a SmalltalkEditingState


[ textMorph editor evaluateSelection ] in PluggableTextMorphWithLimits(PluggableTextMorph)>>doIt
	Receiver: a PluggableTextMorphWithLimits(722731008)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(252.0@349.0) corner: (1068.0@626.0)
		owner: 	a MultipleMethodsEditor(338690048)
		submorphs: 	an Array(an AlphaImageMorph(528744448) a TransformMorph(173015040))
		fullBounds: 	(252@349) corner: (1068@626)
		color: 	Color white
		extension: 	a MorphExtension (408944640) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(770441216)
		scroller: 	a TransformMorph(173015040)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(479985664)
		textMorph: 	a TextMorphForEditView(442236928)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 122)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	350
		method: 	nil
		lockIcon: 	an AlphaImageMorph(528744448)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


[ result := editBlock value ] in PluggableTextMorphWithLimits(PluggableTextMorph)>>handleEdit:
	Receiver: a PluggableTextMorphWithLimits(722731008)
	Arguments and temporary variables: 
		editBlock: 	[ textMorph editor evaluateSelection ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(252.0@349.0) corner: (1068.0@626.0)
		owner: 	a MultipleMethodsEditor(338690048)
		submorphs: 	an Array(an AlphaImageMorph(528744448) a TransformMorph(173015040))
		fullBounds: 	(252@349) corner: (1068@626)
		color: 	Color white
		extension: 	a MorphExtension (408944640) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(770441216)
		scroller: 	a TransformMorph(173015040)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(479985664)
		textMorph: 	a TextMorphForEditView(442236928)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 122)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	350
		method: 	nil
		lockIcon: 	an AlphaImageMorph(528744448)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


TextMorphForEditView(TextMorph)>>handleEdit:
	Receiver: a TextMorphForEditView(442236928)
	Arguments and temporary variables: 
		editBlock: 	[ result := editBlock value ]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (808@98)
		owner: 	a TransformMorph(173015040)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (808@98)
		color: 	Color black
		extension: 	a MorphExtension (497025024) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'initialize
	super initialize.
	self label: ''''.
	self border...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorphWithLimits(722731008)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


PluggableTextMorphWithLimits(PluggableTextMorph)>>handleEdit:
	Receiver: a PluggableTextMorphWithLimits(722731008)
	Arguments and temporary variables: 
		result: 	nil
		editBlock: 	[ textMorph editor evaluateSelection ]
	Receiver's instance variables: 
		bounds: 	(252.0@349.0) corner: (1068.0@626.0)
		owner: 	a MultipleMethodsEditor(338690048)
		submorphs: 	an Array(an AlphaImageMorph(528744448) a TransformMorph(173015040))
		fullBounds: 	(252@349) corner: (1068@626)
		color: 	Color white
		extension: 	a MorphExtension (408944640) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(770441216)
		scroller: 	a TransformMorph(173015040)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(479985664)
		textMorph: 	a TextMorphForEditView(442236928)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 122)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	350
		method: 	nil
		lockIcon: 	an AlphaImageMorph(528744448)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


PluggableTextMorphWithLimits(PluggableTextMorph)>>doIt
	Receiver: a PluggableTextMorphWithLimits(722731008)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(252.0@349.0) corner: (1068.0@626.0)
		owner: 	a MultipleMethodsEditor(338690048)
		submorphs: 	an Array(an AlphaImageMorph(528744448) a TransformMorph(173015040))
		fullBounds: 	(252@349) corner: (1068@626)
		color: 	Color white
		extension: 	a MorphExtension (408944640) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(770441216)
		scroller: 	a TransformMorph(173015040)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(479985664)
		textMorph: 	a TextMorphForEditView(442236928)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 122)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	350
		method: 	nil
		lockIcon: 	an AlphaImageMorph(528744448)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


[ :target | target sourceTextArea doIt ] in AbstractNautilusUI class>>buildEditorKeymappingsOn:
	Receiver: AbstractNautilusUI
	Arguments and temporary variables: 
		aBuilder: 	a PragmaMenuAndShortcutRegistration
		target: 	a PackageTreeNautilusUI
	Receiver's instance variables: 
		superclass: 	AbstractTool
		methodDict: 	a MethodDictionary(size 430)
		format: 	180
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #window #hierarchyClass #cachedHierarchy #sourceTex...etc...
		organization: 	a ClassOrganization
		subclasses: 	{NautilusUI}
		name: 	#AbstractNautilusUI
		classPool: 	a Dictionary(#ClassesIconsCache->a WeakIdentityKeyDictionary(AnObsol...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#Nautilus
		traitComposition: 	{}
		localSelectors: 	nil


BlockClosure>>cull:
	Receiver: [ :target | target sourceTextArea doIt ]
	Arguments and temporary variables: 
		anArg: 	a PackageTreeNautilusUI
	Receiver's instance variables: 
		outerContext: 	AbstractNautilusUI class>>buildEditorKeymappingsOn:
		startpc: 	468
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :target | target sourceTextArea doIt ]
	Arguments and temporary variables: 
		firstArg: 	a PackageTreeNautilusUI
		secondArg: 	a PluggableTextMorphWithLimits(722731008)
	Receiver's instance variables: 
		outerContext: 	AbstractNautilusUI class>>buildEditorKeymappingsOn:
		startpc: 	468
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :target | target sourceTextArea doIt ]
	Arguments and temporary variables: 
		firstArg: 	a PackageTreeNautilusUI
		secondArg: 	a PluggableTextMorphWithLimits(722731008)
		thirdArg: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		outerContext: 	AbstractNautilusUI class>>buildEditorKeymappingsOn:
		startpc: 	468
		numArgs: 	1


KMCategoryBinding>>completeMatch:buffer:
	Receiver: aKMCategoryTarget(#NautilusSourceCodeShortcuts)
	Arguments and temporary variables: 
		aKeymap: 	#doIt on Cmd + D do [ :target | target sourceTextArea doIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
	Receiver's instance variables: 
		target: 	a PackageTreeNautilusUI
		category: 	a KMCategory
		morph: 	a PluggableTextMorphWithLimits(722731008)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #doIt on Cmd + D do [ :target | target sourceTextArea doIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#NautilusSourceCodeShortcuts) a KMDispatc...etc...
		aBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		listeners: 	an Array(aKMCategoryTarget(#NautilusSourceCodeShortcuts) a KMDispatc...etc...
		l: 	aKMCategoryTarget(#NautilusSourceCodeShortcuts)
	Receiver's instance variables: 
		action: 	[ :target | target sourceTextArea doIt ]
		name: 	#doIt
		shortcut: 	Cmd + D
		defaultShortcut: 	Cmd + D
		description: 	''


Array(SequenceableCollection)>>do:
	Receiver: an Array(aKMCategoryTarget(#NautilusSourceCodeShortcuts) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(aKMCategoryTarget(#NautilusSourceCodeShortcuts) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #doIt on Cmd + D do [ :target | target sourceTextArea doIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#NautilusSourceCodeShortcuts) a KMDispatc...etc...
		aBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		listeners: 	an Array(aKMCategoryTarget(#NautilusSourceCodeShortcuts) a KMDispatc...etc...
	Receiver's instance variables: 
		action: 	[ :target | target sourceTextArea doIt ]
		name: 	#doIt
		shortcut: 	Cmd + D
		defaultShortcut: 	Cmd + D
		description: 	''


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: #doIt on Cmd + D do [ :target | target sourceTextArea doIt ]

	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#NautilusSourceCodeShortcuts) a KMDi...etc...
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		action: 	[ :target | target sourceTextArea doIt ]
		name: 	#doIt
		shortcut: 	Cmd + D
		defaultShortcut: 	Cmd + D
		description: 	''


[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#NautilusSourceCodeShortcuts) a KMDi...etc...
		aBlock: 	[ ^ self ]
		entry: 	#doIt on Cmd + D do [ :target | target sourceTextArea doIt ]

	Receiver's instance variables: 
		name: 	#NautilusSourceCodeShortcuts
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(#cut on Cmd + X do [ :target | target sourceTextArea cut ]
 #cancel on Cmd + L do [ ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	15
		each: 	#doIt on Cmd + D do [ :target | target sourceTextArea doIt ]

	Receiver's instance variables: 
		tally: 	23
		array: 	an Array(nil nil #cut on Cmd + X do [ :target | target sourceTextArea cu...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#NautilusSourceCodeShortcuts) a KMDi...etc...
		aBlock: 	[ ^ self ]
	Receiver's instance variables: 
		name: 	#NautilusSourceCodeShortcuts
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: aKMCategoryTarget(#NautilusSourceCodeShortcuts)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		target: 	a PackageTreeNautilusUI
		category: 	a KMCategory
		morph: 	a PluggableTextMorphWithLimits(722731008)


[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#NautilusSourceCodeShortcuts)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#NautilusSourceC...etc...
		morph: 	a PluggableTextMorphWithLimits(722731008)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#TextMorph) aKMCategoryTarge...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	3
	Receiver's instance variables: 
		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#TextMorph) aKMCategor...etc...
		firstIndex: 	1
		lastIndex: 	8


KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		association: 	nil
		match: 	nil
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#NautilusSourceC...etc...
		morph: 	a PluggableTextMorphWithLimits(722731008)
		directKeymaps: 	a KMCategory


KMTarget>>dispatch:
	Receiver: a KMTarget
	Arguments and temporary variables: 
		buffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
	Receiver's instance variables: 
		realTarget: 	nil
		morph: 	a PluggableTextMorphWithLimits(722731008)
		targetSelector: 	#yourself
		directKeymaps: 	nil
		perInstanceCategories: 	nil


[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Cmd-d>']
		targetToDispatch: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>do:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatcher>>dispatchKeystroke:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		aKeyEvent: 	[keystroke '<Cmd-d>']
		chain: 	a KMDispatchChain
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...
		morph: 	a TextMorphForEditView(442236928)
		directKeymaps: 	a KMCategory


TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
	Receiver: a TextMorphForEditView(442236928)
	Arguments and temporary variables: 
		evt: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (808@98)
		owner: 	a TransformMorph(173015040)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (808@98)
		color: 	Color black
		extension: 	a MorphExtension (497025024) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'initialize
	super initialize.
	self label: ''''.
	self border...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorphWithLimits(722731008)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(TextMorph)>>handleKeystroke:
	Receiver: a TextMorphForEditView(442236928)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-d>']
		pasteUp: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (808@98)
		owner: 	a TransformMorph(173015040)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (808@98)
		color: 	Color black
		extension: 	a MorphExtension (497025024) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'initialize
	super initialize.
	self label: ''''.
	self border...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorphWithLimits(722731008)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


KeyboardEvent>>sentTo:
	Receiver: [keystroke '<Cmd-d>']
	Arguments and temporary variables: 
		anObject: 	a TextMorphForEditView(442236928)
	Receiver's instance variables: 
		timeStamp: 	682495
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#keystroke
		buttons: 	64
		position: 	(227@120.0)
		handler: 	nil
		wasHandled: 	true
		keyValue: 	100
		charCode: 	100
		scanCode: 	2


TextMorphForEditView(Morph)>>handleEvent:
	Receiver: a TextMorphForEditView(442236928)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (808@98)
		owner: 	a TransformMorph(173015040)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (808@98)
		color: 	Color black
		extension: 	a MorphExtension (497025024) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'initialize
	super initialize.
	self label: ''''.
	self border...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorphWithLimits(722731008)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #super
Message>>sentTo:
UndefinedObject(Object)>>doesNotUnderstand: #super
Message>>sentTo:
UndefinedObject(Object)>>doesNotUnderstand: #super
AssignmentTemp class>>DoIt
OpalCompiler>>evaluate
SmalltalkEditor>>evaluateSelectionAndDo:
SmalltalkEditor>>evaluateSelection
[ textMorph editor evaluateSelection ] in PluggableTextMorphWithLimits(PluggableTextMorph)>>doIt
[ result := editBlock value ] in PluggableTextMorphWithLimits(PluggableTextMorph)>>handleEdit:
TextMorphForEditView(TextMorph)>>handleEdit:
PluggableTextMorphWithLimits(PluggableTextMorph)>>handleEdit:
PluggableTextMorphWithLimits(PluggableTextMorph)>>doIt
[ :target | target sourceTextArea doIt ] in AbstractNautilusUI class>>buildEditorKeymappingsOn:
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
TextMorphForEditView(TextMorph)>>handleKeystroke:
KeyboardEvent>>sentTo:
TextMorphForEditView(Morph)>>handleEvent:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
TextMorphForEditView(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: receiver of "super" is nil
17 October 2014 2:06:58.095636 pm

VM: Mac OS - intel - 1090 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30858]

UndefinedObject(Object)>>doesNotUnderstand: #super
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	super
		exception: 	MessageNotUnderstood: receiver of "super" is nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

AssignmentTemp class>>DoIt
	Receiver: AssignmentTemp
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	BorderedMorph
		methodDict: 	a MethodDictionary()
		format: 	146
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#AssignmentTemp
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#Assignment
		traitComposition: 	{}
		localSelectors: 	nil
		announcer: 	nil
		initialize: 	nil
		bounds: 	nil


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'initialize
	super initialize.
	self label: ''''.
	self borderW...etc...
		itsSelection: 	a Text for 'initialize
	super initialize.
	self label: ''''.
	sel...etc...
		itsSelectionString: 	'initialize
	super initialize.
	self label: ''''.
	self bor...etc...
	Receiver's instance variables: 
		ast: 	DoIt
	initialize super initialize.
	self label: ''.
	self borderWidth: 2.
...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	AssignmentTemp
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


SmalltalkEditor>>evaluateSelectionAndDo:
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | result ]
		result: 	nil
		rcvr: 	AssignmentTemp
		ctxt: 	nil
	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(442236928)
		selectionShowing: 	true
		model: 	a PackageTreeNautilusUI
		editingState: 	a SmalltalkEditingState


SmalltalkEditor>>evaluateSelection
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(442236928)
		selectionShowing: 	true
		model: 	a PackageTreeNautilusUI
		editingState: 	a SmalltalkEditingState


[ textMorph editor evaluateSelection ] in PluggableTextMorphWithLimits(PluggableTextMorph)>>doIt
	Receiver: a PluggableTextMorphWithLimits(722731008)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(252.0@349.0) corner: (1068.0@626.0)
		owner: 	a MultipleMethodsEditor(338690048)
		submorphs: 	an Array(an AlphaImageMorph(528744448) a TransformMorph(173015040))
		fullBounds: 	(252@349) corner: (1068@626)
		color: 	Color white
		extension: 	a MorphExtension (408944640) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(770441216)
		scroller: 	a TransformMorph(173015040)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(479985664)
		textMorph: 	a TextMorphForEditView(442236928)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 122)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	350
		method: 	nil
		lockIcon: 	an AlphaImageMorph(528744448)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


[ result := editBlock value ] in PluggableTextMorphWithLimits(PluggableTextMorph)>>handleEdit:
	Receiver: a PluggableTextMorphWithLimits(722731008)
	Arguments and temporary variables: 
		editBlock: 	[ textMorph editor evaluateSelection ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(252.0@349.0) corner: (1068.0@626.0)
		owner: 	a MultipleMethodsEditor(338690048)
		submorphs: 	an Array(an AlphaImageMorph(528744448) a TransformMorph(173015040))
		fullBounds: 	(252@349) corner: (1068@626)
		color: 	Color white
		extension: 	a MorphExtension (408944640) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(770441216)
		scroller: 	a TransformMorph(173015040)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(479985664)
		textMorph: 	a TextMorphForEditView(442236928)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 122)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	350
		method: 	nil
		lockIcon: 	an AlphaImageMorph(528744448)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


TextMorphForEditView(TextMorph)>>handleEdit:
	Receiver: a TextMorphForEditView(442236928)
	Arguments and temporary variables: 
		editBlock: 	[ result := editBlock value ]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (808@98)
		owner: 	a TransformMorph(173015040)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (808@98)
		color: 	Color black
		extension: 	a MorphExtension (497025024) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'initialize
	super initialize.
	self label: ''''.
	self border...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorphWithLimits(722731008)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


PluggableTextMorphWithLimits(PluggableTextMorph)>>handleEdit:
	Receiver: a PluggableTextMorphWithLimits(722731008)
	Arguments and temporary variables: 
		result: 	nil
		editBlock: 	[ textMorph editor evaluateSelection ]
	Receiver's instance variables: 
		bounds: 	(252.0@349.0) corner: (1068.0@626.0)
		owner: 	a MultipleMethodsEditor(338690048)
		submorphs: 	an Array(an AlphaImageMorph(528744448) a TransformMorph(173015040))
		fullBounds: 	(252@349) corner: (1068@626)
		color: 	Color white
		extension: 	a MorphExtension (408944640) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(770441216)
		scroller: 	a TransformMorph(173015040)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(479985664)
		textMorph: 	a TextMorphForEditView(442236928)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 122)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	350
		method: 	nil
		lockIcon: 	an AlphaImageMorph(528744448)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


PluggableTextMorphWithLimits(PluggableTextMorph)>>doIt
	Receiver: a PluggableTextMorphWithLimits(722731008)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(252.0@349.0) corner: (1068.0@626.0)
		owner: 	a MultipleMethodsEditor(338690048)
		submorphs: 	an Array(an AlphaImageMorph(528744448) a TransformMorph(173015040))
		fullBounds: 	(252@349) corner: (1068@626)
		color: 	Color white
		extension: 	a MorphExtension (408944640) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(770441216)
		scroller: 	a TransformMorph(173015040)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(479985664)
		textMorph: 	a TextMorphForEditView(442236928)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 122)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	350
		method: 	nil
		lockIcon: 	an AlphaImageMorph(528744448)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


[ :target | target sourceTextArea doIt ] in AbstractNautilusUI class>>buildEditorKeymappingsOn:
	Receiver: AbstractNautilusUI
	Arguments and temporary variables: 
		aBuilder: 	a PragmaMenuAndShortcutRegistration
		target: 	a PackageTreeNautilusUI
	Receiver's instance variables: 
		superclass: 	AbstractTool
		methodDict: 	a MethodDictionary(size 430)
		format: 	180
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #window #hierarchyClass #cachedHierarchy #sourceTex...etc...
		organization: 	a ClassOrganization
		subclasses: 	{NautilusUI}
		name: 	#AbstractNautilusUI
		classPool: 	a Dictionary(#ClassesIconsCache->a WeakIdentityKeyDictionary(AnObsol...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#Nautilus
		traitComposition: 	{}
		localSelectors: 	nil


BlockClosure>>cull:
	Receiver: [ :target | target sourceTextArea doIt ]
	Arguments and temporary variables: 
		anArg: 	a PackageTreeNautilusUI
	Receiver's instance variables: 
		outerContext: 	AbstractNautilusUI class>>buildEditorKeymappingsOn:
		startpc: 	468
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :target | target sourceTextArea doIt ]
	Arguments and temporary variables: 
		firstArg: 	a PackageTreeNautilusUI
		secondArg: 	a PluggableTextMorphWithLimits(722731008)
	Receiver's instance variables: 
		outerContext: 	AbstractNautilusUI class>>buildEditorKeymappingsOn:
		startpc: 	468
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :target | target sourceTextArea doIt ]
	Arguments and temporary variables: 
		firstArg: 	a PackageTreeNautilusUI
		secondArg: 	a PluggableTextMorphWithLimits(722731008)
		thirdArg: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		outerContext: 	AbstractNautilusUI class>>buildEditorKeymappingsOn:
		startpc: 	468
		numArgs: 	1


KMCategoryBinding>>completeMatch:buffer:
	Receiver: aKMCategoryTarget(#NautilusSourceCodeShortcuts)
	Arguments and temporary variables: 
		aKeymap: 	#doIt on Cmd + D do [ :target | target sourceTextArea doIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
	Receiver's instance variables: 
		target: 	a PackageTreeNautilusUI
		category: 	a KMCategory
		morph: 	a PluggableTextMorphWithLimits(722731008)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #doIt on Cmd + D do [ :target | target sourceTextArea doIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#NautilusSourceCodeShortcuts) a KMDispatc...etc...
		aBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		listeners: 	an Array(aKMCategoryTarget(#NautilusSourceCodeShortcuts) a KMDispatc...etc...
		l: 	aKMCategoryTarget(#NautilusSourceCodeShortcuts)
	Receiver's instance variables: 
		action: 	[ :target | target sourceTextArea doIt ]
		name: 	#doIt
		shortcut: 	Cmd + D
		defaultShortcut: 	Cmd + D
		description: 	''


Array(SequenceableCollection)>>do:
	Receiver: an Array(aKMCategoryTarget(#NautilusSourceCodeShortcuts) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(aKMCategoryTarget(#NautilusSourceCodeShortcuts) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #doIt on Cmd + D do [ :target | target sourceTextArea doIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#NautilusSourceCodeShortcuts) a KMDispatc...etc...
		aBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		listeners: 	an Array(aKMCategoryTarget(#NautilusSourceCodeShortcuts) a KMDispatc...etc...
	Receiver's instance variables: 
		action: 	[ :target | target sourceTextArea doIt ]
		name: 	#doIt
		shortcut: 	Cmd + D
		defaultShortcut: 	Cmd + D
		description: 	''


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: #doIt on Cmd + D do [ :target | target sourceTextArea doIt ]

	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#NautilusSourceCodeShortcuts) a KMDi...etc...
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		action: 	[ :target | target sourceTextArea doIt ]
		name: 	#doIt
		shortcut: 	Cmd + D
		defaultShortcut: 	Cmd + D
		description: 	''


[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#NautilusSourceCodeShortcuts) a KMDi...etc...
		aBlock: 	[ ^ self ]
		entry: 	#doIt on Cmd + D do [ :target | target sourceTextArea doIt ]

	Receiver's instance variables: 
		name: 	#NautilusSourceCodeShortcuts
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(#cut on Cmd + X do [ :target | target sourceTextArea cut ]
 #cancel on Cmd + L do [ ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	15
		each: 	#doIt on Cmd + D do [ :target | target sourceTextArea doIt ]

	Receiver's instance variables: 
		tally: 	23
		array: 	an Array(nil nil #cut on Cmd + X do [ :target | target sourceTextArea cu...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#NautilusSourceCodeShortcuts) a KMDi...etc...
		aBlock: 	[ ^ self ]
	Receiver's instance variables: 
		name: 	#NautilusSourceCodeShortcuts
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: aKMCategoryTarget(#NautilusSourceCodeShortcuts)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		target: 	a PackageTreeNautilusUI
		category: 	a KMCategory
		morph: 	a PluggableTextMorphWithLimits(722731008)


[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#NautilusSourceCodeShortcuts)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#NautilusSourceC...etc...
		morph: 	a PluggableTextMorphWithLimits(722731008)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#TextMorph) aKMCategoryTarge...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	3
	Receiver's instance variables: 
		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#TextMorph) aKMCategor...etc...
		firstIndex: 	1
		lastIndex: 	8


KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		association: 	nil
		match: 	nil
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#NautilusSourceC...etc...
		morph: 	a PluggableTextMorphWithLimits(722731008)
		directKeymaps: 	a KMCategory


KMTarget>>dispatch:
	Receiver: a KMTarget
	Arguments and temporary variables: 
		buffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
	Receiver's instance variables: 
		realTarget: 	nil
		morph: 	a PluggableTextMorphWithLimits(722731008)
		targetSelector: 	#yourself
		directKeymaps: 	nil
		perInstanceCategories: 	nil


[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Cmd-d>']
		targetToDispatch: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>do:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatcher>>dispatchKeystroke:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		aKeyEvent: 	[keystroke '<Cmd-d>']
		chain: 	a KMDispatchChain
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...
		morph: 	a TextMorphForEditView(442236928)
		directKeymaps: 	a KMCategory


TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
	Receiver: a TextMorphForEditView(442236928)
	Arguments and temporary variables: 
		evt: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (808@98)
		owner: 	a TransformMorph(173015040)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (808@98)
		color: 	Color black
		extension: 	a MorphExtension (497025024) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'initialize
	super initialize.
	self label: ''''.
	self border...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorphWithLimits(722731008)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(TextMorph)>>handleKeystroke:
	Receiver: a TextMorphForEditView(442236928)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-d>']
		pasteUp: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (808@98)
		owner: 	a TransformMorph(173015040)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (808@98)
		color: 	Color black
		extension: 	a MorphExtension (497025024) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'initialize
	super initialize.
	self label: ''''.
	self border...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorphWithLimits(722731008)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


KeyboardEvent>>sentTo:
	Receiver: [keystroke '<Cmd-d>']
	Arguments and temporary variables: 
		anObject: 	a TextMorphForEditView(442236928)
	Receiver's instance variables: 
		timeStamp: 	711448
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#keystroke
		buttons: 	64
		position: 	(330@130.0)
		handler: 	nil
		wasHandled: 	true
		keyValue: 	100
		charCode: 	100
		scanCode: 	2


TextMorphForEditView(Morph)>>handleEvent:
	Receiver: a TextMorphForEditView(442236928)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (808@98)
		owner: 	a TransformMorph(173015040)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (808@98)
		color: 	Color black
		extension: 	a MorphExtension (497025024) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'initialize
	super initialize.
	self label: ''''.
	self border...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorphWithLimits(722731008)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(Morph)>>handleFocusEvent:
	Receiver: a TextMorphForEditView(442236928)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (808@98)
		owner: 	a TransformMorph(173015040)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (808@98)
		color: 	Color black
		extension: 	a MorphExtension (497025024) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'initialize
	super initialize.
	self label: ''''.
	self border...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorphWithLimits(722731008)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-d>']
		focusHolder: 	a TextMorphForEditView(442236928)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(586@480.0) corner: (602@496.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a TextMorphForEditView(442236928)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(586@480) mouseOver nil nil]
		targetOffset: 	(335.0@130.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 709517 586 480 0 0 0 1)
		lastKeyScanCode: 	2
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1208@742)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a NautilusWindow(37748736) an Ima...etc...
		fullBounds: 	(0@0) corner: (1208@742)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #super
AssignmentTemp class>>DoIt
OpalCompiler>>evaluate
SmalltalkEditor>>evaluateSelectionAndDo:
SmalltalkEditor>>evaluateSelection
[ textMorph editor evaluateSelection ] in PluggableTextMorphWithLimits(PluggableTextMorph)>>doIt
[ result := editBlock value ] in PluggableTextMorphWithLimits(PluggableTextMorph)>>handleEdit:
TextMorphForEditView(TextMorph)>>handleEdit:
PluggableTextMorphWithLimits(PluggableTextMorph)>>handleEdit:
PluggableTextMorphWithLimits(PluggableTextMorph)>>doIt
[ :target | target sourceTextArea doIt ] in AbstractNautilusUI class>>buildEditorKeymappingsOn:
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
TextMorphForEditView(TextMorph)>>handleKeystroke:
KeyboardEvent>>sentTo:
TextMorphForEditView(Morph)>>handleEvent:
TextMorphForEditView(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: receiver of "super" is nil
17 October 2014 2:07:14.789343 pm

VM: Mac OS - intel - 1090 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30858]

UndefinedObject(Object)>>doesNotUnderstand: #super
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	super
		exception: 	MessageNotUnderstood: receiver of "super" is nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

AssignmentTemp class>>DoIt
	Receiver: AssignmentTemp
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	BorderedMorph
		methodDict: 	a MethodDictionary()
		format: 	146
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#AssignmentTemp
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#Assignment
		traitComposition: 	{}
		localSelectors: 	nil
		announcer: 	nil
		initialize: 	nil
		bounds: 	nil


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'initialize
	super initialize.
	self label: ''''.
	self borderW...etc...
		itsSelection: 	a Text for 'initialize
	super initialize.
	self label: ''''.
	sel...etc...
		itsSelectionString: 	'initialize
	super initialize.
	self label: ''''.
	self bor...etc...
	Receiver's instance variables: 
		ast: 	DoIt
	initialize super initialize.
	self label: ''.
	self borderWidth: 2.
...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	AssignmentTemp
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


SmalltalkEditor>>evaluateSelectionAndDo:
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | result ]
		result: 	nil
		rcvr: 	AssignmentTemp
		ctxt: 	nil
	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(442236928)
		selectionShowing: 	true
		model: 	a PackageTreeNautilusUI
		editingState: 	a SmalltalkEditingState


SmalltalkEditor>>evaluateSelection
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(442236928)
		selectionShowing: 	true
		model: 	a PackageTreeNautilusUI
		editingState: 	a SmalltalkEditingState


[ textMorph editor evaluateSelection ] in PluggableTextMorphWithLimits(PluggableTextMorph)>>doIt
	Receiver: a PluggableTextMorphWithLimits(722731008)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(252.0@349.0) corner: (1068.0@626.0)
		owner: 	a MultipleMethodsEditor(338690048)
		submorphs: 	an Array(an AlphaImageMorph(528744448) a TransformMorph(173015040))
		fullBounds: 	(252@349) corner: (1068@626)
		color: 	Color white
		extension: 	a MorphExtension (408944640) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(770441216)
		scroller: 	a TransformMorph(173015040)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(479985664)
		textMorph: 	a TextMorphForEditView(442236928)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 98)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	350
		method: 	nil
		lockIcon: 	an AlphaImageMorph(528744448)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


[ result := editBlock value ] in PluggableTextMorphWithLimits(PluggableTextMorph)>>handleEdit:
	Receiver: a PluggableTextMorphWithLimits(722731008)
	Arguments and temporary variables: 
		editBlock: 	[ textMorph editor evaluateSelection ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(252.0@349.0) corner: (1068.0@626.0)
		owner: 	a MultipleMethodsEditor(338690048)
		submorphs: 	an Array(an AlphaImageMorph(528744448) a TransformMorph(173015040))
		fullBounds: 	(252@349) corner: (1068@626)
		color: 	Color white
		extension: 	a MorphExtension (408944640) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(770441216)
		scroller: 	a TransformMorph(173015040)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(479985664)
		textMorph: 	a TextMorphForEditView(442236928)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 98)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	350
		method: 	nil
		lockIcon: 	an AlphaImageMorph(528744448)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


TextMorphForEditView(TextMorph)>>handleEdit:
	Receiver: a TextMorphForEditView(442236928)
	Arguments and temporary variables: 
		editBlock: 	[ result := editBlock value ]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (808@82)
		owner: 	a TransformMorph(173015040)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (808@82)
		color: 	Color black
		extension: 	a MorphExtension (497025024) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'initialize
	super initialize.
	self label: ''''.
	self border...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorphWithLimits(722731008)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


PluggableTextMorphWithLimits(PluggableTextMorph)>>handleEdit:
	Receiver: a PluggableTextMorphWithLimits(722731008)
	Arguments and temporary variables: 
		result: 	nil
		editBlock: 	[ textMorph editor evaluateSelection ]
	Receiver's instance variables: 
		bounds: 	(252.0@349.0) corner: (1068.0@626.0)
		owner: 	a MultipleMethodsEditor(338690048)
		submorphs: 	an Array(an AlphaImageMorph(528744448) a TransformMorph(173015040))
		fullBounds: 	(252@349) corner: (1068@626)
		color: 	Color white
		extension: 	a MorphExtension (408944640) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(770441216)
		scroller: 	a TransformMorph(173015040)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(479985664)
		textMorph: 	a TextMorphForEditView(442236928)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 98)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	350
		method: 	nil
		lockIcon: 	an AlphaImageMorph(528744448)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


PluggableTextMorphWithLimits(PluggableTextMorph)>>doIt
	Receiver: a PluggableTextMorphWithLimits(722731008)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(252.0@349.0) corner: (1068.0@626.0)
		owner: 	a MultipleMethodsEditor(338690048)
		submorphs: 	an Array(an AlphaImageMorph(528744448) a TransformMorph(173015040))
		fullBounds: 	(252@349) corner: (1068@626)
		color: 	Color white
		extension: 	a MorphExtension (408944640) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(770441216)
		scroller: 	a TransformMorph(173015040)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(479985664)
		textMorph: 	a TextMorphForEditView(442236928)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 98)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	350
		method: 	nil
		lockIcon: 	an AlphaImageMorph(528744448)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


[ :target | target sourceTextArea doIt ] in AbstractNautilusUI class>>buildEditorKeymappingsOn:
	Receiver: AbstractNautilusUI
	Arguments and temporary variables: 
		aBuilder: 	a PragmaMenuAndShortcutRegistration
		target: 	a PackageTreeNautilusUI
	Receiver's instance variables: 
		superclass: 	AbstractTool
		methodDict: 	a MethodDictionary(size 430)
		format: 	180
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #window #hierarchyClass #cachedHierarchy #sourceTex...etc...
		organization: 	a ClassOrganization
		subclasses: 	{NautilusUI}
		name: 	#AbstractNautilusUI
		classPool: 	a Dictionary(#ClassesIconsCache->a WeakIdentityKeyDictionary(AnObsol...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#Nautilus
		traitComposition: 	{}
		localSelectors: 	nil


BlockClosure>>cull:
	Receiver: [ :target | target sourceTextArea doIt ]
	Arguments and temporary variables: 
		anArg: 	a PackageTreeNautilusUI
	Receiver's instance variables: 
		outerContext: 	AbstractNautilusUI class>>buildEditorKeymappingsOn:
		startpc: 	468
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :target | target sourceTextArea doIt ]
	Arguments and temporary variables: 
		firstArg: 	a PackageTreeNautilusUI
		secondArg: 	a PluggableTextMorphWithLimits(722731008)
	Receiver's instance variables: 
		outerContext: 	AbstractNautilusUI class>>buildEditorKeymappingsOn:
		startpc: 	468
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :target | target sourceTextArea doIt ]
	Arguments and temporary variables: 
		firstArg: 	a PackageTreeNautilusUI
		secondArg: 	a PluggableTextMorphWithLimits(722731008)
		thirdArg: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		outerContext: 	AbstractNautilusUI class>>buildEditorKeymappingsOn:
		startpc: 	468
		numArgs: 	1


KMCategoryBinding>>completeMatch:buffer:
	Receiver: aKMCategoryTarget(#NautilusSourceCodeShortcuts)
	Arguments and temporary variables: 
		aKeymap: 	#doIt on Cmd + D do [ :target | target sourceTextArea doIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
	Receiver's instance variables: 
		target: 	a PackageTreeNautilusUI
		category: 	a KMCategory
		morph: 	a PluggableTextMorphWithLimits(722731008)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #doIt on Cmd + D do [ :target | target sourceTextArea doIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#NautilusSourceCodeShortcuts) a KMDispatc...etc...
		aBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		listeners: 	an Array(aKMCategoryTarget(#NautilusSourceCodeShortcuts) a KMDispatc...etc...
		l: 	aKMCategoryTarget(#NautilusSourceCodeShortcuts)
	Receiver's instance variables: 
		action: 	[ :target | target sourceTextArea doIt ]
		name: 	#doIt
		shortcut: 	Cmd + D
		defaultShortcut: 	Cmd + D
		description: 	''


Array(SequenceableCollection)>>do:
	Receiver: an Array(aKMCategoryTarget(#NautilusSourceCodeShortcuts) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(aKMCategoryTarget(#NautilusSourceCodeShortcuts) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #doIt on Cmd + D do [ :target | target sourceTextArea doIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#NautilusSourceCodeShortcuts) a KMDispatc...etc...
		aBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		listeners: 	an Array(aKMCategoryTarget(#NautilusSourceCodeShortcuts) a KMDispatc...etc...
	Receiver's instance variables: 
		action: 	[ :target | target sourceTextArea doIt ]
		name: 	#doIt
		shortcut: 	Cmd + D
		defaultShortcut: 	Cmd + D
		description: 	''


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: #doIt on Cmd + D do [ :target | target sourceTextArea doIt ]

	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#NautilusSourceCodeShortcuts) a KMDi...etc...
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		action: 	[ :target | target sourceTextArea doIt ]
		name: 	#doIt
		shortcut: 	Cmd + D
		defaultShortcut: 	Cmd + D
		description: 	''


[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#NautilusSourceCodeShortcuts) a KMDi...etc...
		aBlock: 	[ ^ self ]
		entry: 	#doIt on Cmd + D do [ :target | target sourceTextArea doIt ]

	Receiver's instance variables: 
		name: 	#NautilusSourceCodeShortcuts
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(#cut on Cmd + X do [ :target | target sourceTextArea cut ]
 #cancel on Cmd + L do [ ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	15
		each: 	#doIt on Cmd + D do [ :target | target sourceTextArea doIt ]

	Receiver's instance variables: 
		tally: 	23
		array: 	an Array(nil nil #cut on Cmd + X do [ :target | target sourceTextArea cu...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#NautilusSourceCodeShortcuts) a KMDi...etc...
		aBlock: 	[ ^ self ]
	Receiver's instance variables: 
		name: 	#NautilusSourceCodeShortcuts
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: aKMCategoryTarget(#NautilusSourceCodeShortcuts)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		target: 	a PackageTreeNautilusUI
		category: 	a KMCategory
		morph: 	a PluggableTextMorphWithLimits(722731008)


[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#NautilusSourceCodeShortcuts)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#NautilusSourceC...etc...
		morph: 	a PluggableTextMorphWithLimits(722731008)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#TextMorph) aKMCategoryTarge...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	3
	Receiver's instance variables: 
		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#TextMorph) aKMCategor...etc...
		firstIndex: 	1
		lastIndex: 	8


KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		association: 	nil
		match: 	nil
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#NautilusSourceC...etc...
		morph: 	a PluggableTextMorphWithLimits(722731008)
		directKeymaps: 	a KMCategory


KMTarget>>dispatch:
	Receiver: a KMTarget
	Arguments and temporary variables: 
		buffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
	Receiver's instance variables: 
		realTarget: 	nil
		morph: 	a PluggableTextMorphWithLimits(722731008)
		targetSelector: 	#yourself
		directKeymaps: 	nil
		perInstanceCategories: 	nil


[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Cmd-d>']
		targetToDispatch: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>do:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatcher>>dispatchKeystroke:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		aKeyEvent: 	[keystroke '<Cmd-d>']
		chain: 	a KMDispatchChain
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...
		morph: 	a TextMorphForEditView(442236928)
		directKeymaps: 	a KMCategory


TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
	Receiver: a TextMorphForEditView(442236928)
	Arguments and temporary variables: 
		evt: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (808@82)
		owner: 	a TransformMorph(173015040)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (808@82)
		color: 	Color black
		extension: 	a MorphExtension (497025024) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'initialize
	super initialize.
	self label: ''''.
	self border...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorphWithLimits(722731008)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(TextMorph)>>handleKeystroke:
	Receiver: a TextMorphForEditView(442236928)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-d>']
		pasteUp: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (808@82)
		owner: 	a TransformMorph(173015040)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (808@82)
		color: 	Color black
		extension: 	a MorphExtension (497025024) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'initialize
	super initialize.
	self label: ''''.
	self border...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorphWithLimits(722731008)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


KeyboardEvent>>sentTo:
	Receiver: [keystroke '<Cmd-d>']
	Arguments and temporary variables: 
		anObject: 	a TextMorphForEditView(442236928)
	Receiver's instance variables: 
		timeStamp: 	728143
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#keystroke
		buttons: 	64
		position: 	(240@73.0)
		handler: 	nil
		wasHandled: 	true
		keyValue: 	100
		charCode: 	100
		scanCode: 	2


TextMorphForEditView(Morph)>>handleEvent:
	Receiver: a TextMorphForEditView(442236928)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (808@82)
		owner: 	a TransformMorph(173015040)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (808@82)
		color: 	Color black
		extension: 	a MorphExtension (497025024) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'initialize
	super initialize.
	self label: ''''.
	self border...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorphWithLimits(722731008)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(Morph)>>handleFocusEvent:
	Receiver: a TextMorphForEditView(442236928)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (808@82)
		owner: 	a TransformMorph(173015040)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (808@82)
		color: 	Color black
		extension: 	a MorphExtension (497025024) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'initialize
	super initialize.
	self label: ''''.
	self border...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorphWithLimits(722731008)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-d>']
		focusHolder: 	a TextMorphForEditView(442236928)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(488@414.0) corner: (504@430.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(488@414.0) corner: (504@430.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a TextMorphForEditView(442236928)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(496@423) mouseOver SHIFT nil nil]
		targetOffset: 	(240@74)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	Form(16x16x8)
		temporaryCursorOffset: 	(-8@ -9)
		hardwareCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r...etc...
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 726512 496 423 0 1 0 1)
		lastKeyScanCode: 	2
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1208@742)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a NautilusWindow(37748736) an Ima...etc...
		fullBounds: 	(0@0) corner: (1208@742)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #super
AssignmentTemp class>>DoIt
OpalCompiler>>evaluate
SmalltalkEditor>>evaluateSelectionAndDo:
SmalltalkEditor>>evaluateSelection
[ textMorph editor evaluateSelection ] in PluggableTextMorphWithLimits(PluggableTextMorph)>>doIt
[ result := editBlock value ] in PluggableTextMorphWithLimits(PluggableTextMorph)>>handleEdit:
TextMorphForEditView(TextMorph)>>handleEdit:
PluggableTextMorphWithLimits(PluggableTextMorph)>>handleEdit:
PluggableTextMorphWithLimits(PluggableTextMorph)>>doIt
[ :target | target sourceTextArea doIt ] in AbstractNautilusUI class>>buildEditorKeymappingsOn:
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
TextMorphForEditView(TextMorph)>>handleKeystroke:
KeyboardEvent>>sentTo:
TextMorphForEditView(Morph)>>handleEvent:
TextMorphForEditView(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: receiver of "super" is nil
17 October 2014 2:10:30.178991 pm

VM: Mac OS - intel - 1090 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30858]

UndefinedObject(Object)>>doesNotUnderstand: #super
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	super
		exception: 	MessageNotUnderstood: receiver of "super" is nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

AssignmentTemp class>>DoIt
	Receiver: AssignmentTemp
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	BorderedMorph
		methodDict: 	a MethodDictionary()
		format: 	146
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#AssignmentTemp
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#Assignment
		traitComposition: 	{}
		localSelectors: 	nil
		announcer: 	nil
		initialize: 	nil
		bounds: 	nil
		initalize: 	nil


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'initalize
	super initalize.
	self label: ''''.
	self borderWid...etc...
		itsSelection: 	a Text for 'initalize
	super initalize.
	self label: ''''.
	self ...etc...
		itsSelectionString: 	'initalize
	super initalize.
	self label: ''''.
	self borde...etc...
	Receiver's instance variables: 
		ast: 	DoIt
	initalize super initalize.
	self label: ''.
	self borderWidth: 2.
	^...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	AssignmentTemp
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


SmalltalkEditor>>evaluateSelectionAndDo:
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | result ]
		result: 	nil
		rcvr: 	AssignmentTemp
		ctxt: 	nil
	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(442236928)
		selectionShowing: 	true
		model: 	a PackageTreeNautilusUI
		editingState: 	a SmalltalkEditingState


SmalltalkEditor>>evaluateSelection
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(442236928)
		selectionShowing: 	true
		model: 	a PackageTreeNautilusUI
		editingState: 	a SmalltalkEditingState


[ textMorph editor evaluateSelection ] in PluggableTextMorphWithLimits(PluggableTextMorph)>>doIt
	Receiver: a PluggableTextMorphWithLimits(722731008)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(252.0@349.0) corner: (1068.0@626.0)
		owner: 	a MultipleMethodsEditor(338690048)
		submorphs: 	an Array(an AlphaImageMorph(528744448) a TransformMorph(173015040))
		fullBounds: 	(252@349) corner: (1068@626)
		color: 	Color white
		extension: 	a MorphExtension (408944640) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(770441216)
		scroller: 	a TransformMorph(173015040)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(479985664)
		textMorph: 	a TextMorphForEditView(442236928)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 96)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	350
		method: 	nil
		lockIcon: 	an AlphaImageMorph(528744448)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


[ result := editBlock value ] in PluggableTextMorphWithLimits(PluggableTextMorph)>>handleEdit:
	Receiver: a PluggableTextMorphWithLimits(722731008)
	Arguments and temporary variables: 
		editBlock: 	[ textMorph editor evaluateSelection ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(252.0@349.0) corner: (1068.0@626.0)
		owner: 	a MultipleMethodsEditor(338690048)
		submorphs: 	an Array(an AlphaImageMorph(528744448) a TransformMorph(173015040))
		fullBounds: 	(252@349) corner: (1068@626)
		color: 	Color white
		extension: 	a MorphExtension (408944640) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(770441216)
		scroller: 	a TransformMorph(173015040)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(479985664)
		textMorph: 	a TextMorphForEditView(442236928)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 96)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	350
		method: 	nil
		lockIcon: 	an AlphaImageMorph(528744448)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


TextMorphForEditView(TextMorph)>>handleEdit:
	Receiver: a TextMorphForEditView(442236928)
	Arguments and temporary variables: 
		editBlock: 	[ result := editBlock value ]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (808@82)
		owner: 	a TransformMorph(173015040)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (808@82)
		color: 	Color black
		extension: 	a MorphExtension (497025024) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'initalize
	super initalize.
	self label: ''''.
	self borderWi...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorphWithLimits(722731008)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


PluggableTextMorphWithLimits(PluggableTextMorph)>>handleEdit:
	Receiver: a PluggableTextMorphWithLimits(722731008)
	Arguments and temporary variables: 
		result: 	nil
		editBlock: 	[ textMorph editor evaluateSelection ]
	Receiver's instance variables: 
		bounds: 	(252.0@349.0) corner: (1068.0@626.0)
		owner: 	a MultipleMethodsEditor(338690048)
		submorphs: 	an Array(an AlphaImageMorph(528744448) a TransformMorph(173015040))
		fullBounds: 	(252@349) corner: (1068@626)
		color: 	Color white
		extension: 	a MorphExtension (408944640) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(770441216)
		scroller: 	a TransformMorph(173015040)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(479985664)
		textMorph: 	a TextMorphForEditView(442236928)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 96)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	350
		method: 	nil
		lockIcon: 	an AlphaImageMorph(528744448)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


PluggableTextMorphWithLimits(PluggableTextMorph)>>doIt
	Receiver: a PluggableTextMorphWithLimits(722731008)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(252.0@349.0) corner: (1068.0@626.0)
		owner: 	a MultipleMethodsEditor(338690048)
		submorphs: 	an Array(an AlphaImageMorph(528744448) a TransformMorph(173015040))
		fullBounds: 	(252@349) corner: (1068@626)
		color: 	Color white
		extension: 	a MorphExtension (408944640) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(770441216)
		scroller: 	a TransformMorph(173015040)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(479985664)
		textMorph: 	a TextMorphForEditView(442236928)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 96)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	350
		method: 	nil
		lockIcon: 	an AlphaImageMorph(528744448)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


[ :target | target sourceTextArea doIt ] in AbstractNautilusUI class>>buildEditorKeymappingsOn:
	Receiver: AbstractNautilusUI
	Arguments and temporary variables: 
		aBuilder: 	a PragmaMenuAndShortcutRegistration
		target: 	a PackageTreeNautilusUI
	Receiver's instance variables: 
		superclass: 	AbstractTool
		methodDict: 	a MethodDictionary(size 430)
		format: 	180
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #window #hierarchyClass #cachedHierarchy #sourceTex...etc...
		organization: 	a ClassOrganization
		subclasses: 	{NautilusUI}
		name: 	#AbstractNautilusUI
		classPool: 	a Dictionary(#ClassesIconsCache->a WeakIdentityKeyDictionary(AnObsol...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#Nautilus
		traitComposition: 	{}
		localSelectors: 	nil


BlockClosure>>cull:
	Receiver: [ :target | target sourceTextArea doIt ]
	Arguments and temporary variables: 
		anArg: 	a PackageTreeNautilusUI
	Receiver's instance variables: 
		outerContext: 	AbstractNautilusUI class>>buildEditorKeymappingsOn:
		startpc: 	468
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :target | target sourceTextArea doIt ]
	Arguments and temporary variables: 
		firstArg: 	a PackageTreeNautilusUI
		secondArg: 	a PluggableTextMorphWithLimits(722731008)
	Receiver's instance variables: 
		outerContext: 	AbstractNautilusUI class>>buildEditorKeymappingsOn:
		startpc: 	468
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :target | target sourceTextArea doIt ]
	Arguments and temporary variables: 
		firstArg: 	a PackageTreeNautilusUI
		secondArg: 	a PluggableTextMorphWithLimits(722731008)
		thirdArg: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		outerContext: 	AbstractNautilusUI class>>buildEditorKeymappingsOn:
		startpc: 	468
		numArgs: 	1


KMCategoryBinding>>completeMatch:buffer:
	Receiver: aKMCategoryTarget(#NautilusSourceCodeShortcuts)
	Arguments and temporary variables: 
		aKeymap: 	#doIt on Cmd + D do [ :target | target sourceTextArea doIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
	Receiver's instance variables: 
		target: 	a PackageTreeNautilusUI
		category: 	a KMCategory
		morph: 	a PluggableTextMorphWithLimits(722731008)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #doIt on Cmd + D do [ :target | target sourceTextArea doIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#NautilusSourceCodeShortcuts) a KMDispatc...etc...
		aBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		listeners: 	an Array(aKMCategoryTarget(#NautilusSourceCodeShortcuts) a KMDispatc...etc...
		l: 	aKMCategoryTarget(#NautilusSourceCodeShortcuts)
	Receiver's instance variables: 
		action: 	[ :target | target sourceTextArea doIt ]
		name: 	#doIt
		shortcut: 	Cmd + D
		defaultShortcut: 	Cmd + D
		description: 	''


Array(SequenceableCollection)>>do:
	Receiver: an Array(aKMCategoryTarget(#NautilusSourceCodeShortcuts) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(aKMCategoryTarget(#NautilusSourceCodeShortcuts) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #doIt on Cmd + D do [ :target | target sourceTextArea doIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#NautilusSourceCodeShortcuts) a KMDispatc...etc...
		aBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		listeners: 	an Array(aKMCategoryTarget(#NautilusSourceCodeShortcuts) a KMDispatc...etc...
	Receiver's instance variables: 
		action: 	[ :target | target sourceTextArea doIt ]
		name: 	#doIt
		shortcut: 	Cmd + D
		defaultShortcut: 	Cmd + D
		description: 	''


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: #doIt on Cmd + D do [ :target | target sourceTextArea doIt ]

	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#NautilusSourceCodeShortcuts) a KMDi...etc...
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		action: 	[ :target | target sourceTextArea doIt ]
		name: 	#doIt
		shortcut: 	Cmd + D
		defaultShortcut: 	Cmd + D
		description: 	''


[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#NautilusSourceCodeShortcuts) a KMDi...etc...
		aBlock: 	[ ^ self ]
		entry: 	#doIt on Cmd + D do [ :target | target sourceTextArea doIt ]

	Receiver's instance variables: 
		name: 	#NautilusSourceCodeShortcuts
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(#cut on Cmd + X do [ :target | target sourceTextArea cut ]
 #cancel on Cmd + L do [ ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	15
		each: 	#doIt on Cmd + D do [ :target | target sourceTextArea doIt ]

	Receiver's instance variables: 
		tally: 	23
		array: 	an Array(nil nil #cut on Cmd + X do [ :target | target sourceTextArea cu...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#NautilusSourceCodeShortcuts) a KMDi...etc...
		aBlock: 	[ ^ self ]
	Receiver's instance variables: 
		name: 	#NautilusSourceCodeShortcuts
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: aKMCategoryTarget(#NautilusSourceCodeShortcuts)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		target: 	a PackageTreeNautilusUI
		category: 	a KMCategory
		morph: 	a PluggableTextMorphWithLimits(722731008)


[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#NautilusSourceCodeShortcuts)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#NautilusSourceC...etc...
		morph: 	a PluggableTextMorphWithLimits(722731008)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#TextMorph) aKMCategoryTarge...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	3
	Receiver's instance variables: 
		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#TextMorph) aKMCategor...etc...
		firstIndex: 	1
		lastIndex: 	8


KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		association: 	nil
		match: 	nil
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#NautilusSourceC...etc...
		morph: 	a PluggableTextMorphWithLimits(722731008)
		directKeymaps: 	a KMCategory


KMTarget>>dispatch:
	Receiver: a KMTarget
	Arguments and temporary variables: 
		buffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
	Receiver's instance variables: 
		realTarget: 	nil
		morph: 	a PluggableTextMorphWithLimits(722731008)
		targetSelector: 	#yourself
		directKeymaps: 	nil
		perInstanceCategories: 	nil


[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Cmd-d>']
		targetToDispatch: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>do:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatcher>>dispatchKeystroke:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		aKeyEvent: 	[keystroke '<Cmd-d>']
		chain: 	a KMDispatchChain
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...
		morph: 	a TextMorphForEditView(442236928)
		directKeymaps: 	a KMCategory


TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
	Receiver: a TextMorphForEditView(442236928)
	Arguments and temporary variables: 
		evt: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (808@82)
		owner: 	a TransformMorph(173015040)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (808@82)
		color: 	Color black
		extension: 	a MorphExtension (497025024) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'initalize
	super initalize.
	self label: ''''.
	self borderWi...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorphWithLimits(722731008)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(TextMorph)>>handleKeystroke:
	Receiver: a TextMorphForEditView(442236928)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-d>']
		pasteUp: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (808@82)
		owner: 	a TransformMorph(173015040)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (808@82)
		color: 	Color black
		extension: 	a MorphExtension (497025024) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'initalize
	super initalize.
	self label: ''''.
	self borderWi...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorphWithLimits(722731008)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


KeyboardEvent>>sentTo:
	Receiver: [keystroke '<Cmd-d>']
	Arguments and temporary variables: 
		anObject: 	a TextMorphForEditView(442236928)
	Receiver's instance variables: 
		timeStamp: 	919657
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#keystroke
		buttons: 	64
		position: 	(231@74.0)
		handler: 	nil
		wasHandled: 	true
		keyValue: 	100
		charCode: 	100
		scanCode: 	2


TextMorphForEditView(Morph)>>handleEvent:
	Receiver: a TextMorphForEditView(442236928)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (808@82)
		owner: 	a TransformMorph(173015040)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (808@82)
		color: 	Color black
		extension: 	a MorphExtension (497025024) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'initalize
	super initalize.
	self label: ''''.
	self borderWi...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorphWithLimits(722731008)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(Morph)>>handleFocusEvent:
	Receiver: a TextMorphForEditView(442236928)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (808@82)
		owner: 	a TransformMorph(173015040)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (808@82)
		color: 	Color black
		extension: 	a MorphExtension (497025024) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'initalize
	super initalize.
	self label: ''''.
	self borderWi...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorphWithLimits(722731008)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-d>']
		focusHolder: 	a TextMorphForEditView(442236928)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(447@446.0) corner: (463@462.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a TextMorphForEditView(442236928)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(423@419) mouseOver nil nil]
		targetOffset: 	(158.0@9.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	Form(16x16x8)
		temporaryCursorOffset: 	(-8@ -9)
		hardwareCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r...etc...
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 923236 423 419 0 0 0 1)
		lastKeyScanCode: 	2
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1208@742)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a NautilusWindow(37748736) an Ima...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #super
AssignmentTemp class>>DoIt
OpalCompiler>>evaluate
SmalltalkEditor>>evaluateSelectionAndDo:
SmalltalkEditor>>evaluateSelection
[ textMorph editor evaluateSelection ] in PluggableTextMorphWithLimits(PluggableTextMorph)>>doIt
[ result := editBlock value ] in PluggableTextMorphWithLimits(PluggableTextMorph)>>handleEdit:
TextMorphForEditView(TextMorph)>>handleEdit:
PluggableTextMorphWithLimits(PluggableTextMorph)>>handleEdit:
PluggableTextMorphWithLimits(PluggableTextMorph)>>doIt
[ :target | target sourceTextArea doIt ] in AbstractNautilusUI class>>buildEditorKeymappingsOn:
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
TextMorphForEditView(TextMorph)>>handleKeystroke:
KeyboardEvent>>sentTo:
TextMorphForEditView(Morph)>>handleEvent:
TextMorphForEditView(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: receiver of "super" is nil
17 October 2014 2:10:48.790292 pm

VM: Mac OS - intel - 1090 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30858]

UndefinedObject(Object)>>doesNotUnderstand: #super
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	super
		exception: 	MessageNotUnderstood: receiver of "super" is nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

AssignmentTemp class>>DoIt
	Receiver: AssignmentTemp
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	BorderedMorph
		methodDict: 	a MethodDictionary()
		format: 	146
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#AssignmentTemp
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#Assignment
		traitComposition: 	{}
		localSelectors: 	nil
		announcer: 	nil
		initialize: 	nil
		bounds: 	nil
		initalize: 	nil


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'initalize
	super initalize.
	self label: ''''.
	self borderWid...etc...
		itsSelection: 	a Text for 'initalize
	super initalize.
	self label: ''''.
	self ...etc...
		itsSelectionString: 	'initalize
	super initalize.
	self label: ''''.
	self borde...etc...
	Receiver's instance variables: 
		ast: 	DoIt
	initalize super initalize.
	self label: ''.
	self borderWidth: 2.
	^...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	AssignmentTemp
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


SmalltalkEditor>>evaluateSelectionAndDo:
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | result ]
		result: 	nil
		rcvr: 	AssignmentTemp
		ctxt: 	nil
	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(442236928)
		selectionShowing: 	true
		model: 	a PackageTreeNautilusUI
		editingState: 	a SmalltalkEditingState


SmalltalkEditor>>evaluateSelection
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(442236928)
		selectionShowing: 	true
		model: 	a PackageTreeNautilusUI
		editingState: 	a SmalltalkEditingState


[ textMorph editor evaluateSelection ] in PluggableTextMorphWithLimits(PluggableTextMorph)>>doIt
	Receiver: a PluggableTextMorphWithLimits(722731008)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(252.0@349.0) corner: (1068.0@626.0)
		owner: 	a MultipleMethodsEditor(338690048)
		submorphs: 	an Array(an AlphaImageMorph(528744448) a TransformMorph(173015040))
		fullBounds: 	(252@349) corner: (1068@626)
		color: 	Color white
		extension: 	a MorphExtension (408944640) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(770441216)
		scroller: 	a TransformMorph(173015040)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(479985664)
		textMorph: 	a TextMorphForEditView(442236928)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 96)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	350
		method: 	nil
		lockIcon: 	an AlphaImageMorph(528744448)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


[ result := editBlock value ] in PluggableTextMorphWithLimits(PluggableTextMorph)>>handleEdit:
	Receiver: a PluggableTextMorphWithLimits(722731008)
	Arguments and temporary variables: 
		editBlock: 	[ textMorph editor evaluateSelection ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(252.0@349.0) corner: (1068.0@626.0)
		owner: 	a MultipleMethodsEditor(338690048)
		submorphs: 	an Array(an AlphaImageMorph(528744448) a TransformMorph(173015040))
		fullBounds: 	(252@349) corner: (1068@626)
		color: 	Color white
		extension: 	a MorphExtension (408944640) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(770441216)
		scroller: 	a TransformMorph(173015040)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(479985664)
		textMorph: 	a TextMorphForEditView(442236928)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 96)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	350
		method: 	nil
		lockIcon: 	an AlphaImageMorph(528744448)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


TextMorphForEditView(TextMorph)>>handleEdit:
	Receiver: a TextMorphForEditView(442236928)
	Arguments and temporary variables: 
		editBlock: 	[ result := editBlock value ]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (808@98)
		owner: 	a TransformMorph(173015040)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (808@98)
		color: 	Color black
		extension: 	a MorphExtension (497025024) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'initalize
	super initalize.
	self label: ''''.
	self borderWi...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorphWithLimits(722731008)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


PluggableTextMorphWithLimits(PluggableTextMorph)>>handleEdit:
	Receiver: a PluggableTextMorphWithLimits(722731008)
	Arguments and temporary variables: 
		result: 	nil
		editBlock: 	[ textMorph editor evaluateSelection ]
	Receiver's instance variables: 
		bounds: 	(252.0@349.0) corner: (1068.0@626.0)
		owner: 	a MultipleMethodsEditor(338690048)
		submorphs: 	an Array(an AlphaImageMorph(528744448) a TransformMorph(173015040))
		fullBounds: 	(252@349) corner: (1068@626)
		color: 	Color white
		extension: 	a MorphExtension (408944640) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(770441216)
		scroller: 	a TransformMorph(173015040)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(479985664)
		textMorph: 	a TextMorphForEditView(442236928)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 96)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	350
		method: 	nil
		lockIcon: 	an AlphaImageMorph(528744448)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


PluggableTextMorphWithLimits(PluggableTextMorph)>>doIt
	Receiver: a PluggableTextMorphWithLimits(722731008)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(252.0@349.0) corner: (1068.0@626.0)
		owner: 	a MultipleMethodsEditor(338690048)
		submorphs: 	an Array(an AlphaImageMorph(528744448) a TransformMorph(173015040))
		fullBounds: 	(252@349) corner: (1068@626)
		color: 	Color white
		extension: 	a MorphExtension (408944640) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(770441216)
		scroller: 	a TransformMorph(173015040)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(479985664)
		textMorph: 	a TextMorphForEditView(442236928)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 96)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	350
		method: 	nil
		lockIcon: 	an AlphaImageMorph(528744448)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


[ :target | target sourceTextArea doIt ] in AbstractNautilusUI class>>buildEditorKeymappingsOn:
	Receiver: AbstractNautilusUI
	Arguments and temporary variables: 
		aBuilder: 	a PragmaMenuAndShortcutRegistration
		target: 	a PackageTreeNautilusUI
	Receiver's instance variables: 
		superclass: 	AbstractTool
		methodDict: 	a MethodDictionary(size 430)
		format: 	180
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #window #hierarchyClass #cachedHierarchy #sourceTex...etc...
		organization: 	a ClassOrganization
		subclasses: 	{NautilusUI}
		name: 	#AbstractNautilusUI
		classPool: 	a Dictionary(#ClassesIconsCache->a WeakIdentityKeyDictionary(AnObsol...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#Nautilus
		traitComposition: 	{}
		localSelectors: 	nil


BlockClosure>>cull:
	Receiver: [ :target | target sourceTextArea doIt ]
	Arguments and temporary variables: 
		anArg: 	a PackageTreeNautilusUI
	Receiver's instance variables: 
		outerContext: 	AbstractNautilusUI class>>buildEditorKeymappingsOn:
		startpc: 	468
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :target | target sourceTextArea doIt ]
	Arguments and temporary variables: 
		firstArg: 	a PackageTreeNautilusUI
		secondArg: 	a PluggableTextMorphWithLimits(722731008)
	Receiver's instance variables: 
		outerContext: 	AbstractNautilusUI class>>buildEditorKeymappingsOn:
		startpc: 	468
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :target | target sourceTextArea doIt ]
	Arguments and temporary variables: 
		firstArg: 	a PackageTreeNautilusUI
		secondArg: 	a PluggableTextMorphWithLimits(722731008)
		thirdArg: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		outerContext: 	AbstractNautilusUI class>>buildEditorKeymappingsOn:
		startpc: 	468
		numArgs: 	1


KMCategoryBinding>>completeMatch:buffer:
	Receiver: aKMCategoryTarget(#NautilusSourceCodeShortcuts)
	Arguments and temporary variables: 
		aKeymap: 	#doIt on Cmd + D do [ :target | target sourceTextArea doIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
	Receiver's instance variables: 
		target: 	a PackageTreeNautilusUI
		category: 	a KMCategory
		morph: 	a PluggableTextMorphWithLimits(722731008)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #doIt on Cmd + D do [ :target | target sourceTextArea doIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#NautilusSourceCodeShortcuts) a KMDispatc...etc...
		aBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		listeners: 	an Array(aKMCategoryTarget(#NautilusSourceCodeShortcuts) a KMDispatc...etc...
		l: 	aKMCategoryTarget(#NautilusSourceCodeShortcuts)
	Receiver's instance variables: 
		action: 	[ :target | target sourceTextArea doIt ]
		name: 	#doIt
		shortcut: 	Cmd + D
		defaultShortcut: 	Cmd + D
		description: 	''


Array(SequenceableCollection)>>do:
	Receiver: an Array(aKMCategoryTarget(#NautilusSourceCodeShortcuts) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(aKMCategoryTarget(#NautilusSourceCodeShortcuts) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #doIt on Cmd + D do [ :target | target sourceTextArea doIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#NautilusSourceCodeShortcuts) a KMDispatc...etc...
		aBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		listeners: 	an Array(aKMCategoryTarget(#NautilusSourceCodeShortcuts) a KMDispatc...etc...
	Receiver's instance variables: 
		action: 	[ :target | target sourceTextArea doIt ]
		name: 	#doIt
		shortcut: 	Cmd + D
		defaultShortcut: 	Cmd + D
		description: 	''


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: #doIt on Cmd + D do [ :target | target sourceTextArea doIt ]

	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#NautilusSourceCodeShortcuts) a KMDi...etc...
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		action: 	[ :target | target sourceTextArea doIt ]
		name: 	#doIt
		shortcut: 	Cmd + D
		defaultShortcut: 	Cmd + D
		description: 	''


[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#NautilusSourceCodeShortcuts) a KMDi...etc...
		aBlock: 	[ ^ self ]
		entry: 	#doIt on Cmd + D do [ :target | target sourceTextArea doIt ]

	Receiver's instance variables: 
		name: 	#NautilusSourceCodeShortcuts
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(#cut on Cmd + X do [ :target | target sourceTextArea cut ]
 #cancel on Cmd + L do [ ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	15
		each: 	#doIt on Cmd + D do [ :target | target sourceTextArea doIt ]

	Receiver's instance variables: 
		tally: 	23
		array: 	an Array(nil nil #cut on Cmd + X do [ :target | target sourceTextArea cu...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#NautilusSourceCodeShortcuts) a KMDi...etc...
		aBlock: 	[ ^ self ]
	Receiver's instance variables: 
		name: 	#NautilusSourceCodeShortcuts
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: aKMCategoryTarget(#NautilusSourceCodeShortcuts)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		target: 	a PackageTreeNautilusUI
		category: 	a KMCategory
		morph: 	a PluggableTextMorphWithLimits(722731008)


[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#NautilusSourceCodeShortcuts)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#NautilusSourceC...etc...
		morph: 	a PluggableTextMorphWithLimits(722731008)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#TextMorph) aKMCategoryTarge...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	3
	Receiver's instance variables: 
		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#TextMorph) aKMCategor...etc...
		firstIndex: 	1
		lastIndex: 	8


KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		association: 	nil
		match: 	nil
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#NautilusSourceC...etc...
		morph: 	a PluggableTextMorphWithLimits(722731008)
		directKeymaps: 	a KMCategory


KMTarget>>dispatch:
	Receiver: a KMTarget
	Arguments and temporary variables: 
		buffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
	Receiver's instance variables: 
		realTarget: 	nil
		morph: 	a PluggableTextMorphWithLimits(722731008)
		targetSelector: 	#yourself
		directKeymaps: 	nil
		perInstanceCategories: 	nil


[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Cmd-d>']
		targetToDispatch: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>do:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatcher>>dispatchKeystroke:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		aKeyEvent: 	[keystroke '<Cmd-d>']
		chain: 	a KMDispatchChain
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...
		morph: 	a TextMorphForEditView(442236928)
		directKeymaps: 	a KMCategory


TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
	Receiver: a TextMorphForEditView(442236928)
	Arguments and temporary variables: 
		evt: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (808@98)
		owner: 	a TransformMorph(173015040)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (808@98)
		color: 	Color black
		extension: 	a MorphExtension (497025024) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'initalize
	super initalize.
	self label: ''''.
	self borderWi...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorphWithLimits(722731008)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(TextMorph)>>handleKeystroke:
	Receiver: a TextMorphForEditView(442236928)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-d>']
		pasteUp: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (808@98)
		owner: 	a TransformMorph(173015040)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (808@98)
		color: 	Color black
		extension: 	a MorphExtension (497025024) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'initalize
	super initalize.
	self label: ''''.
	self borderWi...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorphWithLimits(722731008)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


KeyboardEvent>>sentTo:
	Receiver: [keystroke '<Cmd-d>']
	Arguments and temporary variables: 
		anObject: 	a TextMorphForEditView(442236928)
	Receiver's instance variables: 
		timeStamp: 	942147
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#keystroke
		buttons: 	64
		position: 	(1@10.0)
		handler: 	nil
		wasHandled: 	true
		keyValue: 	100
		charCode: 	100
		scanCode: 	2


TextMorphForEditView(Morph)>>handleEvent:
	Receiver: a TextMorphForEditView(442236928)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (808@98)
		owner: 	a TransformMorph(173015040)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (808@98)
		color: 	Color black
		extension: 	a MorphExtension (497025024) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'initalize
	super initalize.
	self label: ''''.
	self borderWi...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorphWithLimits(722731008)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(Morph)>>handleFocusEvent:
	Receiver: a TextMorphForEditView(442236928)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (808@98)
		owner: 	a TransformMorph(173015040)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (808@98)
		color: 	Color black
		extension: 	a MorphExtension (497025024) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'initalize
	super initalize.
	self label: ''''.
	self borderWi...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorphWithLimits(722731008)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-d>']
		focusHolder: 	a TextMorphForEditView(442236928)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(249@351.0) corner: (265@367.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(249@351.0) corner: (265@367.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a TextMorphForEditView(442236928)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(257@360) mouseOver SHIFT nil nil]
		targetOffset: 	(1@10)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	Form(16x16x8)
		temporaryCursorOffset: 	(-8@ -9)
		hardwareCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r...etc...
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 941587 257 360 0 1 0 1)
		lastKeyScanCode: 	2
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	8


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1208@742)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a NautilusWindow(37748736) an Ima...etc...
		fullBounds: 	(0@0) corner: (1208@742)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #super
AssignmentTemp class>>DoIt
OpalCompiler>>evaluate
SmalltalkEditor>>evaluateSelectionAndDo:
SmalltalkEditor>>evaluateSelection
[ textMorph editor evaluateSelection ] in PluggableTextMorphWithLimits(PluggableTextMorph)>>doIt
[ result := editBlock value ] in PluggableTextMorphWithLimits(PluggableTextMorph)>>handleEdit:
TextMorphForEditView(TextMorph)>>handleEdit:
PluggableTextMorphWithLimits(PluggableTextMorph)>>handleEdit:
PluggableTextMorphWithLimits(PluggableTextMorph)>>doIt
[ :target | target sourceTextArea doIt ] in AbstractNautilusUI class>>buildEditorKeymappingsOn:
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
TextMorphForEditView(TextMorph)>>handleKeystroke:
KeyboardEvent>>sentTo:
TextMorphForEditView(Morph)>>handleEvent:
TextMorphForEditView(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: receiver of "super" is nil
17 October 2014 2:20:48.133122 pm

VM: Mac OS - intel - 1090 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30858]

UndefinedObject(Object)>>doesNotUnderstand: #super
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	super
		exception: 	MessageNotUnderstood: receiver of "super" is nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

AssignmentTemp class>>DoIt
	Receiver: AssignmentTemp
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	BorderedMorph
		methodDict: 	a MethodDictionary(#initalize->AssignmentTemp>>#initalize )
		format: 	146
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#AssignmentTemp
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#Assignment
		traitComposition: 	{}
		localSelectors: 	nil
		announcer: 	nil
		initialize: 	nil
		bounds: 	nil
		initalize: 	nil


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'initialize
	super initialize.
	self label: ''''.
	self borderW...etc...
		itsSelection: 	a Text for 'initialize
	super initialize.
	self label: ''''.
	sel...etc...
		itsSelectionString: 	'initialize
	super initialize.
	self label: ''''.
	self bor...etc...
	Receiver's instance variables: 
		ast: 	DoIt
	initialize super initialize.
	self label: ''.
	self borderWidth: 2.
...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	AssignmentTemp
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


SmalltalkEditor>>evaluateSelectionAndDo:
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | result ]
		result: 	nil
		rcvr: 	AssignmentTemp
		ctxt: 	nil
	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(442236928)
		selectionShowing: 	true
		model: 	a PackageTreeNautilusUI
		editingState: 	a SmalltalkEditingState


SmalltalkEditor>>evaluateSelection
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(442236928)
		selectionShowing: 	true
		model: 	a PackageTreeNautilusUI
		editingState: 	a SmalltalkEditingState


[ textMorph editor evaluateSelection ] in PluggableTextMorphWithLimits(PluggableTextMorph)>>doIt
	Receiver: a PluggableTextMorphWithLimits(722731008)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(344.0@329.0) corner: (1160.0@606.0)
		owner: 	a MultipleMethodsEditor(338690048)
		submorphs: 	an Array(an AlphaImageMorph(528744448) a TransformMorph(173015040))
		fullBounds: 	(344@329) corner: (1160@606)
		color: 	Color white
		extension: 	a MorphExtension (408944640) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(770441216)
		scroller: 	a TransformMorph(173015040)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(479985664)
		textMorph: 	a TextMorphForEditView(442236928)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 103)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	350
		method: 	nil
		lockIcon: 	an AlphaImageMorph(528744448)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


[ result := editBlock value ] in PluggableTextMorphWithLimits(PluggableTextMorph)>>handleEdit:
	Receiver: a PluggableTextMorphWithLimits(722731008)
	Arguments and temporary variables: 
		editBlock: 	[ textMorph editor evaluateSelection ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(344.0@329.0) corner: (1160.0@606.0)
		owner: 	a MultipleMethodsEditor(338690048)
		submorphs: 	an Array(an AlphaImageMorph(528744448) a TransformMorph(173015040))
		fullBounds: 	(344@329) corner: (1160@606)
		color: 	Color white
		extension: 	a MorphExtension (408944640) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(770441216)
		scroller: 	a TransformMorph(173015040)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(479985664)
		textMorph: 	a TextMorphForEditView(442236928)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 103)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	350
		method: 	nil
		lockIcon: 	an AlphaImageMorph(528744448)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


TextMorphForEditView(TextMorph)>>handleEdit:
	Receiver: a TextMorphForEditView(442236928)
	Arguments and temporary variables: 
		editBlock: 	[ result := editBlock value ]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (808@98)
		owner: 	a TransformMorph(173015040)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (808@98)
		color: 	Color black
		extension: 	a MorphExtension (497025024) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'initialize
	super initialize.
	self label: ''''.
	self border...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorphWithLimits(722731008)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


PluggableTextMorphWithLimits(PluggableTextMorph)>>handleEdit:
	Receiver: a PluggableTextMorphWithLimits(722731008)
	Arguments and temporary variables: 
		result: 	nil
		editBlock: 	[ textMorph editor evaluateSelection ]
	Receiver's instance variables: 
		bounds: 	(344.0@329.0) corner: (1160.0@606.0)
		owner: 	a MultipleMethodsEditor(338690048)
		submorphs: 	an Array(an AlphaImageMorph(528744448) a TransformMorph(173015040))
		fullBounds: 	(344@329) corner: (1160@606)
		color: 	Color white
		extension: 	a MorphExtension (408944640) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(770441216)
		scroller: 	a TransformMorph(173015040)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(479985664)
		textMorph: 	a TextMorphForEditView(442236928)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 103)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	350
		method: 	nil
		lockIcon: 	an AlphaImageMorph(528744448)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


PluggableTextMorphWithLimits(PluggableTextMorph)>>doIt
	Receiver: a PluggableTextMorphWithLimits(722731008)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(344.0@329.0) corner: (1160.0@606.0)
		owner: 	a MultipleMethodsEditor(338690048)
		submorphs: 	an Array(an AlphaImageMorph(528744448) a TransformMorph(173015040))
		fullBounds: 	(344@329) corner: (1160@606)
		color: 	Color white
		extension: 	a MorphExtension (408944640) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(770441216)
		scroller: 	a TransformMorph(173015040)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(479985664)
		textMorph: 	a TextMorphForEditView(442236928)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 103)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	350
		method: 	nil
		lockIcon: 	an AlphaImageMorph(528744448)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


[ :target | target sourceTextArea doIt ] in AbstractNautilusUI class>>buildEditorKeymappingsOn:
	Receiver: AbstractNautilusUI
	Arguments and temporary variables: 
		aBuilder: 	a PragmaMenuAndShortcutRegistration
		target: 	a PackageTreeNautilusUI
	Receiver's instance variables: 
		superclass: 	AbstractTool
		methodDict: 	a MethodDictionary(size 430)
		format: 	180
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #window #hierarchyClass #cachedHierarchy #sourceTex...etc...
		organization: 	a ClassOrganization
		subclasses: 	{NautilusUI}
		name: 	#AbstractNautilusUI
		classPool: 	a Dictionary(#ClassesIconsCache->a WeakIdentityKeyDictionary(AnObsol...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#Nautilus
		traitComposition: 	{}
		localSelectors: 	nil


BlockClosure>>cull:
	Receiver: [ :target | target sourceTextArea doIt ]
	Arguments and temporary variables: 
		anArg: 	a PackageTreeNautilusUI
	Receiver's instance variables: 
		outerContext: 	AbstractNautilusUI class>>buildEditorKeymappingsOn:
		startpc: 	468
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :target | target sourceTextArea doIt ]
	Arguments and temporary variables: 
		firstArg: 	a PackageTreeNautilusUI
		secondArg: 	a PluggableTextMorphWithLimits(722731008)
	Receiver's instance variables: 
		outerContext: 	AbstractNautilusUI class>>buildEditorKeymappingsOn:
		startpc: 	468
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :target | target sourceTextArea doIt ]
	Arguments and temporary variables: 
		firstArg: 	a PackageTreeNautilusUI
		secondArg: 	a PluggableTextMorphWithLimits(722731008)
		thirdArg: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		outerContext: 	AbstractNautilusUI class>>buildEditorKeymappingsOn:
		startpc: 	468
		numArgs: 	1


KMCategoryBinding>>completeMatch:buffer:
	Receiver: aKMCategoryTarget(#NautilusSourceCodeShortcuts)
	Arguments and temporary variables: 
		aKeymap: 	#doIt on Cmd + D do [ :target | target sourceTextArea doIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
	Receiver's instance variables: 
		target: 	a PackageTreeNautilusUI
		category: 	a KMCategory
		morph: 	a PluggableTextMorphWithLimits(722731008)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #doIt on Cmd + D do [ :target | target sourceTextArea doIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#NautilusSourceCodeShortcuts) a KMDispatc...etc...
		aBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		listeners: 	an Array(aKMCategoryTarget(#NautilusSourceCodeShortcuts) a KMDispatc...etc...
		l: 	aKMCategoryTarget(#NautilusSourceCodeShortcuts)
	Receiver's instance variables: 
		action: 	[ :target | target sourceTextArea doIt ]
		name: 	#doIt
		shortcut: 	Cmd + D
		defaultShortcut: 	Cmd + D
		description: 	''


Array(SequenceableCollection)>>do:
	Receiver: an Array(aKMCategoryTarget(#NautilusSourceCodeShortcuts) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(aKMCategoryTarget(#NautilusSourceCodeShortcuts) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #doIt on Cmd + D do [ :target | target sourceTextArea doIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#NautilusSourceCodeShortcuts) a KMDispatc...etc...
		aBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		listeners: 	an Array(aKMCategoryTarget(#NautilusSourceCodeShortcuts) a KMDispatc...etc...
	Receiver's instance variables: 
		action: 	[ :target | target sourceTextArea doIt ]
		name: 	#doIt
		shortcut: 	Cmd + D
		defaultShortcut: 	Cmd + D
		description: 	''


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: #doIt on Cmd + D do [ :target | target sourceTextArea doIt ]

	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#NautilusSourceCodeShortcuts) a KMDi...etc...
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		action: 	[ :target | target sourceTextArea doIt ]
		name: 	#doIt
		shortcut: 	Cmd + D
		defaultShortcut: 	Cmd + D
		description: 	''


[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#NautilusSourceCodeShortcuts) a KMDi...etc...
		aBlock: 	[ ^ self ]
		entry: 	#doIt on Cmd + D do [ :target | target sourceTextArea doIt ]

	Receiver's instance variables: 
		name: 	#NautilusSourceCodeShortcuts
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(#cut on Cmd + X do [ :target | target sourceTextArea cut ]
 #cancel on Cmd + L do [ ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	15
		each: 	#doIt on Cmd + D do [ :target | target sourceTextArea doIt ]

	Receiver's instance variables: 
		tally: 	23
		array: 	an Array(nil nil #cut on Cmd + X do [ :target | target sourceTextArea cu...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#NautilusSourceCodeShortcuts) a KMDi...etc...
		aBlock: 	[ ^ self ]
	Receiver's instance variables: 
		name: 	#NautilusSourceCodeShortcuts
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: aKMCategoryTarget(#NautilusSourceCodeShortcuts)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		target: 	a PackageTreeNautilusUI
		category: 	a KMCategory
		morph: 	a PluggableTextMorphWithLimits(722731008)


[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#NautilusSourceCodeShortcuts)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#NautilusSourceC...etc...
		morph: 	a PluggableTextMorphWithLimits(722731008)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#TextMorph) aKMCategoryTarge...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	3
	Receiver's instance variables: 
		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#TextMorph) aKMCategor...etc...
		firstIndex: 	1
		lastIndex: 	8


KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		association: 	nil
		match: 	nil
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#NautilusSourceC...etc...
		morph: 	a PluggableTextMorphWithLimits(722731008)
		directKeymaps: 	a KMCategory


KMTarget>>dispatch:
	Receiver: a KMTarget
	Arguments and temporary variables: 
		buffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
	Receiver's instance variables: 
		realTarget: 	nil
		morph: 	a PluggableTextMorphWithLimits(722731008)
		targetSelector: 	#yourself
		directKeymaps: 	nil
		perInstanceCategories: 	nil


[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Cmd-d>']
		targetToDispatch: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>do:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatcher>>dispatchKeystroke:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		aKeyEvent: 	[keystroke '<Cmd-d>']
		chain: 	a KMDispatchChain
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...
		morph: 	a TextMorphForEditView(442236928)
		directKeymaps: 	a KMCategory


TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
	Receiver: a TextMorphForEditView(442236928)
	Arguments and temporary variables: 
		evt: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (808@98)
		owner: 	a TransformMorph(173015040)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (808@98)
		color: 	Color black
		extension: 	a MorphExtension (497025024) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'initialize
	super initialize.
	self label: ''''.
	self border...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorphWithLimits(722731008)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(TextMorph)>>handleKeystroke:
	Receiver: a TextMorphForEditView(442236928)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-d>']
		pasteUp: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (808@98)
		owner: 	a TransformMorph(173015040)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (808@98)
		color: 	Color black
		extension: 	a MorphExtension (497025024) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'initialize
	super initialize.
	self label: ''''.
	self border...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorphWithLimits(722731008)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


KeyboardEvent>>sentTo:
	Receiver: [keystroke '<Cmd-d>']
	Arguments and temporary variables: 
		anObject: 	a TextMorphForEditView(442236928)
	Receiver's instance variables: 
		timeStamp: 	1541489
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#keystroke
		buttons: 	64
		position: 	(178.0@39.0)
		handler: 	nil
		wasHandled: 	true
		keyValue: 	100
		charCode: 	100
		scanCode: 	2


TextMorphForEditView(Morph)>>handleEvent:
	Receiver: a TextMorphForEditView(442236928)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (808@98)
		owner: 	a TransformMorph(173015040)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (808@98)
		color: 	Color black
		extension: 	a MorphExtension (497025024) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'initialize
	super initialize.
	self label: ''''.
	self border...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorphWithLimits(722731008)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(Morph)>>handleFocusEvent:
	Receiver: a TextMorphForEditView(442236928)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (808@98)
		owner: 	a TransformMorph(173015040)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (808@98)
		color: 	Color black
		extension: 	a MorphExtension (497025024) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'initialize
	super initialize.
	self label: ''''.
	self border...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorphWithLimits(722731008)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-d>']
		focusHolder: 	a TextMorphForEditView(442236928)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(518@360.0) corner: (534@376.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(518@360.0) corner: (534@376.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a TextMorphForEditView(442236928)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(526@369) mouseOver nil nil]
		targetOffset: 	(178.0@39.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	Form(16x16x8)
		temporaryCursorOffset: 	(-8@ -9)
		hardwareCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r...etc...
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 1540994 526 369 0 0 0 1)
		lastKeyScanCode: 	2
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	8


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1208@742)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a NautilusWindow(37748736) a Syst...etc...
		fullBounds: 	(0@0) corner: (1208@742)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #super
AssignmentTemp class>>DoIt
OpalCompiler>>evaluate
SmalltalkEditor>>evaluateSelectionAndDo:
SmalltalkEditor>>evaluateSelection
[ textMorph editor evaluateSelection ] in PluggableTextMorphWithLimits(PluggableTextMorph)>>doIt
[ result := editBlock value ] in PluggableTextMorphWithLimits(PluggableTextMorph)>>handleEdit:
TextMorphForEditView(TextMorph)>>handleEdit:
PluggableTextMorphWithLimits(PluggableTextMorph)>>handleEdit:
PluggableTextMorphWithLimits(PluggableTextMorph)>>doIt
[ :target | target sourceTextArea doIt ] in AbstractNautilusUI class>>buildEditorKeymappingsOn:
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
TextMorphForEditView(TextMorph)>>handleKeystroke:
KeyboardEvent>>sentTo:
TextMorphForEditView(Morph)>>handleEvent:
TextMorphForEditView(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: receiver of "super" is nil
17 October 2014 2:20:59.607027 pm

VM: Mac OS - intel - 1090 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30858]

UndefinedObject(Object)>>doesNotUnderstand: #super
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	super
		exception: 	MessageNotUnderstood: receiver of "super" is nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

AssignmentTemp class>>DoIt
	Receiver: AssignmentTemp
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	BorderedMorph
		methodDict: 	a MethodDictionary(#initalize->AssignmentTemp>>#initalize )
		format: 	146
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#AssignmentTemp
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#Assignment
		traitComposition: 	{}
		localSelectors: 	nil
		announcer: 	nil
		initialize: 	nil
		bounds: 	nil
		initalize: 	nil


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'initialize
	super initialize.
	self label: ''''.
	self borderW...etc...
		itsSelection: 	a Text for 'initialize
	super initialize.
	self label: ''''.
	sel...etc...
		itsSelectionString: 	'initialize
	super initialize.
	self label: ''''.
	self bor...etc...
	Receiver's instance variables: 
		ast: 	DoIt
	initialize super initialize.
	self label: ''.
	self borderWidth: 2.
...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	AssignmentTemp
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


SmalltalkEditor>>evaluateSelectionAndDo:
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | result ]
		result: 	nil
		rcvr: 	AssignmentTemp
		ctxt: 	nil
	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(442236928)
		selectionShowing: 	true
		model: 	a PackageTreeNautilusUI
		editingState: 	a SmalltalkEditingState


SmalltalkEditor>>evaluateSelection
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(442236928)
		selectionShowing: 	true
		model: 	a PackageTreeNautilusUI
		editingState: 	a SmalltalkEditingState


[ textMorph editor evaluateSelection ] in PluggableTextMorphWithLimits(PluggableTextMorph)>>doIt
	Receiver: a PluggableTextMorphWithLimits(722731008)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(344.0@329.0) corner: (1160.0@606.0)
		owner: 	a MultipleMethodsEditor(338690048)
		submorphs: 	an Array(an AlphaImageMorph(528744448) a TransformMorph(173015040))
		fullBounds: 	(344@329) corner: (1160@606)
		color: 	Color white
		extension: 	a MorphExtension (408944640) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(770441216)
		scroller: 	a TransformMorph(173015040)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(479985664)
		textMorph: 	a TextMorphForEditView(442236928)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 103)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	350
		method: 	nil
		lockIcon: 	an AlphaImageMorph(528744448)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


[ result := editBlock value ] in PluggableTextMorphWithLimits(PluggableTextMorph)>>handleEdit:
	Receiver: a PluggableTextMorphWithLimits(722731008)
	Arguments and temporary variables: 
		editBlock: 	[ textMorph editor evaluateSelection ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(344.0@329.0) corner: (1160.0@606.0)
		owner: 	a MultipleMethodsEditor(338690048)
		submorphs: 	an Array(an AlphaImageMorph(528744448) a TransformMorph(173015040))
		fullBounds: 	(344@329) corner: (1160@606)
		color: 	Color white
		extension: 	a MorphExtension (408944640) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(770441216)
		scroller: 	a TransformMorph(173015040)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(479985664)
		textMorph: 	a TextMorphForEditView(442236928)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 103)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	350
		method: 	nil
		lockIcon: 	an AlphaImageMorph(528744448)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


TextMorphForEditView(TextMorph)>>handleEdit:
	Receiver: a TextMorphForEditView(442236928)
	Arguments and temporary variables: 
		editBlock: 	[ result := editBlock value ]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (808@98)
		owner: 	a TransformMorph(173015040)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (808@98)
		color: 	Color black
		extension: 	a MorphExtension (497025024) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'initialize
	super initialize.
	self label: ''''.
	self border...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorphWithLimits(722731008)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


PluggableTextMorphWithLimits(PluggableTextMorph)>>handleEdit:
	Receiver: a PluggableTextMorphWithLimits(722731008)
	Arguments and temporary variables: 
		result: 	nil
		editBlock: 	[ textMorph editor evaluateSelection ]
	Receiver's instance variables: 
		bounds: 	(344.0@329.0) corner: (1160.0@606.0)
		owner: 	a MultipleMethodsEditor(338690048)
		submorphs: 	an Array(an AlphaImageMorph(528744448) a TransformMorph(173015040))
		fullBounds: 	(344@329) corner: (1160@606)
		color: 	Color white
		extension: 	a MorphExtension (408944640) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(770441216)
		scroller: 	a TransformMorph(173015040)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(479985664)
		textMorph: 	a TextMorphForEditView(442236928)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 103)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	350
		method: 	nil
		lockIcon: 	an AlphaImageMorph(528744448)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


PluggableTextMorphWithLimits(PluggableTextMorph)>>doIt
	Receiver: a PluggableTextMorphWithLimits(722731008)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(344.0@329.0) corner: (1160.0@606.0)
		owner: 	a MultipleMethodsEditor(338690048)
		submorphs: 	an Array(an AlphaImageMorph(528744448) a TransformMorph(173015040))
		fullBounds: 	(344@329) corner: (1160@606)
		color: 	Color white
		extension: 	a MorphExtension (408944640) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(770441216)
		scroller: 	a TransformMorph(173015040)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(479985664)
		textMorph: 	a TextMorphForEditView(442236928)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 103)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	350
		method: 	nil
		lockIcon: 	an AlphaImageMorph(528744448)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


[ :target | target sourceTextArea doIt ] in AbstractNautilusUI class>>buildEditorKeymappingsOn:
	Receiver: AbstractNautilusUI
	Arguments and temporary variables: 
		aBuilder: 	a PragmaMenuAndShortcutRegistration
		target: 	a PackageTreeNautilusUI
	Receiver's instance variables: 
		superclass: 	AbstractTool
		methodDict: 	a MethodDictionary(size 430)
		format: 	180
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #window #hierarchyClass #cachedHierarchy #sourceTex...etc...
		organization: 	a ClassOrganization
		subclasses: 	{NautilusUI}
		name: 	#AbstractNautilusUI
		classPool: 	a Dictionary(#ClassesIconsCache->a WeakIdentityKeyDictionary(AnObsol...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#Nautilus
		traitComposition: 	{}
		localSelectors: 	nil


BlockClosure>>cull:
	Receiver: [ :target | target sourceTextArea doIt ]
	Arguments and temporary variables: 
		anArg: 	a PackageTreeNautilusUI
	Receiver's instance variables: 
		outerContext: 	AbstractNautilusUI class>>buildEditorKeymappingsOn:
		startpc: 	468
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :target | target sourceTextArea doIt ]
	Arguments and temporary variables: 
		firstArg: 	a PackageTreeNautilusUI
		secondArg: 	a PluggableTextMorphWithLimits(722731008)
	Receiver's instance variables: 
		outerContext: 	AbstractNautilusUI class>>buildEditorKeymappingsOn:
		startpc: 	468
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :target | target sourceTextArea doIt ]
	Arguments and temporary variables: 
		firstArg: 	a PackageTreeNautilusUI
		secondArg: 	a PluggableTextMorphWithLimits(722731008)
		thirdArg: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		outerContext: 	AbstractNautilusUI class>>buildEditorKeymappingsOn:
		startpc: 	468
		numArgs: 	1


KMCategoryBinding>>completeMatch:buffer:
	Receiver: aKMCategoryTarget(#NautilusSourceCodeShortcuts)
	Arguments and temporary variables: 
		aKeymap: 	#doIt on Cmd + D do [ :target | target sourceTextArea doIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
	Receiver's instance variables: 
		target: 	a PackageTreeNautilusUI
		category: 	a KMCategory
		morph: 	a PluggableTextMorphWithLimits(722731008)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #doIt on Cmd + D do [ :target | target sourceTextArea doIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#NautilusSourceCodeShortcuts) a KMDispatc...etc...
		aBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		listeners: 	an Array(aKMCategoryTarget(#NautilusSourceCodeShortcuts) a KMDispatc...etc...
		l: 	aKMCategoryTarget(#NautilusSourceCodeShortcuts)
	Receiver's instance variables: 
		action: 	[ :target | target sourceTextArea doIt ]
		name: 	#doIt
		shortcut: 	Cmd + D
		defaultShortcut: 	Cmd + D
		description: 	''


Array(SequenceableCollection)>>do:
	Receiver: an Array(aKMCategoryTarget(#NautilusSourceCodeShortcuts) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(aKMCategoryTarget(#NautilusSourceCodeShortcuts) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #doIt on Cmd + D do [ :target | target sourceTextArea doIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#NautilusSourceCodeShortcuts) a KMDispatc...etc...
		aBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		listeners: 	an Array(aKMCategoryTarget(#NautilusSourceCodeShortcuts) a KMDispatc...etc...
	Receiver's instance variables: 
		action: 	[ :target | target sourceTextArea doIt ]
		name: 	#doIt
		shortcut: 	Cmd + D
		defaultShortcut: 	Cmd + D
		description: 	''


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: #doIt on Cmd + D do [ :target | target sourceTextArea doIt ]

	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#NautilusSourceCodeShortcuts) a KMDi...etc...
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		action: 	[ :target | target sourceTextArea doIt ]
		name: 	#doIt
		shortcut: 	Cmd + D
		defaultShortcut: 	Cmd + D
		description: 	''


[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#NautilusSourceCodeShortcuts) a KMDi...etc...
		aBlock: 	[ ^ self ]
		entry: 	#doIt on Cmd + D do [ :target | target sourceTextArea doIt ]

	Receiver's instance variables: 
		name: 	#NautilusSourceCodeShortcuts
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(#cut on Cmd + X do [ :target | target sourceTextArea cut ]
 #cancel on Cmd + L do [ ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	15
		each: 	#doIt on Cmd + D do [ :target | target sourceTextArea doIt ]

	Receiver's instance variables: 
		tally: 	23
		array: 	an Array(nil nil #cut on Cmd + X do [ :target | target sourceTextArea cu...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#NautilusSourceCodeShortcuts) a KMDi...etc...
		aBlock: 	[ ^ self ]
	Receiver's instance variables: 
		name: 	#NautilusSourceCodeShortcuts
		platforms: 	a Dictionary(#MacOSX->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: aKMCategoryTarget(#NautilusSourceCodeShortcuts)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		target: 	a PackageTreeNautilusUI
		category: 	a KMCategory
		morph: 	a PluggableTextMorphWithLimits(722731008)


[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#NautilusSourceCodeShortcuts)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#NautilusSourceC...etc...
		morph: 	a PluggableTextMorphWithLimits(722731008)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#TextMorph) aKMCategoryTarge...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	3
	Receiver's instance variables: 
		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#TextMorph) aKMCategor...etc...
		firstIndex: 	1
		lastIndex: 	8


KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		association: 	nil
		match: 	nil
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#NautilusSourceC...etc...
		morph: 	a PluggableTextMorphWithLimits(722731008)
		directKeymaps: 	a KMCategory


KMTarget>>dispatch:
	Receiver: a KMTarget
	Arguments and temporary variables: 
		buffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
	Receiver's instance variables: 
		realTarget: 	nil
		morph: 	a PluggableTextMorphWithLimits(722731008)
		targetSelector: 	#yourself
		directKeymaps: 	nil
		perInstanceCategories: 	nil


[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Cmd-d>']
		targetToDispatch: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>do:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatcher>>dispatchKeystroke:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		aKeyEvent: 	[keystroke '<Cmd-d>']
		chain: 	a KMDispatchChain
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...
		morph: 	a TextMorphForEditView(442236928)
		directKeymaps: 	a KMCategory


TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
	Receiver: a TextMorphForEditView(442236928)
	Arguments and temporary variables: 
		evt: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (808@98)
		owner: 	a TransformMorph(173015040)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (808@98)
		color: 	Color black
		extension: 	a MorphExtension (497025024) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'initialize
	super initialize.
	self label: ''''.
	self border...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorphWithLimits(722731008)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(TextMorph)>>handleKeystroke:
	Receiver: a TextMorphForEditView(442236928)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-d>']
		pasteUp: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (808@98)
		owner: 	a TransformMorph(173015040)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (808@98)
		color: 	Color black
		extension: 	a MorphExtension (497025024) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'initialize
	super initialize.
	self label: ''''.
	self border...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorphWithLimits(722731008)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


KeyboardEvent>>sentTo:
	Receiver: [keystroke '<Cmd-d>']
	Arguments and temporary variables: 
		anObject: 	a TextMorphForEditView(442236928)
	Receiver's instance variables: 
		timeStamp: 	1552946
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#keystroke
		buttons: 	64
		position: 	(297.0@87.0)
		handler: 	nil
		wasHandled: 	true
		keyValue: 	100
		charCode: 	100
		scanCode: 	2


TextMorphForEditView(Morph)>>handleEvent:
	Receiver: a TextMorphForEditView(442236928)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (808@98)
		owner: 	a TransformMorph(173015040)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (808@98)
		color: 	Color black
		extension: 	a MorphExtension (497025024) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'initialize
	super initialize.
	self label: ''''.
	self border...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorphWithLimits(722731008)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(Morph)>>handleFocusEvent:
	Receiver: a TextMorphForEditView(442236928)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (808@98)
		owner: 	a TransformMorph(173015040)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (808@98)
		color: 	Color black
		extension: 	a MorphExtension (497025024) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'initialize
	super initialize.
	self label: ''''.
	self border...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorphWithLimits(722731008)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-d>']
		focusHolder: 	a TextMorphForEditView(442236928)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(637@408.0) corner: (653@424.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(637@408.0) corner: (653@424.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a TextMorphForEditView(442236928)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(645@417) mouseOver nil nil]
		targetOffset: 	(297.0@87.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	Form(16x16x8)
		temporaryCursorOffset: 	(-8@ -9)
		hardwareCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r...etc...
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 1551719 645 417 0 0 0 1)
		lastKeyScanCode: 	2
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	8


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1208@742)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a NautilusWindow(37748736) a Spec...etc...
		fullBounds: 	(0@0) corner: (1208@742)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #super
AssignmentTemp class>>DoIt
OpalCompiler>>evaluate
SmalltalkEditor>>evaluateSelectionAndDo:
SmalltalkEditor>>evaluateSelection
[ textMorph editor evaluateSelection ] in PluggableTextMorphWithLimits(PluggableTextMorph)>>doIt
[ result := editBlock value ] in PluggableTextMorphWithLimits(PluggableTextMorph)>>handleEdit:
TextMorphForEditView(TextMorph)>>handleEdit:
PluggableTextMorphWithLimits(PluggableTextMorph)>>handleEdit:
PluggableTextMorphWithLimits(PluggableTextMorph)>>doIt
[ :target | target sourceTextArea doIt ] in AbstractNautilusUI class>>buildEditorKeymappingsOn:
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
TextMorphForEditView(TextMorph)>>handleKeystroke:
KeyboardEvent>>sentTo:
TextMorphForEditView(Morph)>>handleEvent:
TextMorphForEditView(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: AssignmentTemp>>label:
17 October 2014 2:21:09.991195 pm

VM: Mac OS - intel - 1090 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30858]

AssignmentTemp(Object)>>doesNotUnderstand: #label:
	Receiver: an AssignmentTemp(1012924416)
	Arguments and temporary variables: 
		aMessage: 	label: ''
		exception: 	MessageNotUnderstood: AssignmentTemp>>label:
		resumeValue: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (50@40)
		owner: 	nil
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	nil
		borderWidth: 	2
		borderColor: 	Color black


AssignmentTemp>>initialize
	Receiver: an AssignmentTemp(1012924416)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (50@40)
		owner: 	nil
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	nil
		borderWidth: 	2
		borderColor: 	Color black


AssignmentTemp class(Behavior)>>new
	Receiver: AssignmentTemp
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	BorderedMorph
		methodDict: 	a MethodDictionary(#initialize->AssignmentTemp>>#initialize )
		format: 	146
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#AssignmentTemp
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#Assignment
		traitComposition: 	{}
		localSelectors: 	nil
		announcer: 	nil
		initialize: 	nil
		bounds: 	nil
		initalize: 	nil


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'AssignmentTemp new openInWorld'
		itsSelection: 	a Text for 'AssignmentTemp new openInWorld'
		itsSelectionString: 	'AssignmentTemp new openInWorld'
	Receiver's instance variables: 
		ast: 	DoIt
	^ AssignmentTemp new openInWorld
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


SmalltalkEditor>>evaluateSelectionAndDo:
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(49283072)
		selectionShowing: 	true
		model: 	a Workspace
		editingState: 	a SmalltalkEditingState


SmalltalkEditor>>evaluateSelection
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(49283072)
		selectionShowing: 	true
		model: 	a Workspace
		editingState: 	a SmalltalkEditingState


[ textMorph editor evaluateSelection ] in PluggableTextMorph>>doIt
	Receiver: a PluggableTextMorph(430964736)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(25.0@491.0) corner: (465.0@658.0)
		owner: 	a SystemWindow(310902784)
		submorphs: 	an Array(a TransformMorph(345243648))
		fullBounds: 	(25.0@491.0) corner: (465.0@658.0)
		color: 	Color white
		extension: 	a MorphExtension (28049408) [other:  (kmDispatcher -> a KMDispatcher...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(470810624)
		scroller: 	a TransformMorph(345243648)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(386924544)
		textMorph: 	a TextMorphForEditView(49283072)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 30)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


[ result := editBlock value ] in PluggableTextMorph>>handleEdit:
	Receiver: a PluggableTextMorph(430964736)
	Arguments and temporary variables: 
		editBlock: 	[ textMorph editor evaluateSelection ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(25.0@491.0) corner: (465.0@658.0)
		owner: 	a SystemWindow(310902784)
		submorphs: 	an Array(a TransformMorph(345243648))
		fullBounds: 	(25.0@491.0) corner: (465.0@658.0)
		color: 	Color white
		extension: 	a MorphExtension (28049408) [other:  (kmDispatcher -> a KMDispatcher...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(470810624)
		scroller: 	a TransformMorph(345243648)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(386924544)
		textMorph: 	a TextMorphForEditView(49283072)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 30)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


TextMorphForEditView(TextMorph)>>handleEdit:
	Receiver: a TextMorphForEditView(49283072)
	Arguments and temporary variables: 
		editBlock: 	[ result := editBlock value ]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@18)
		owner: 	a TransformMorph(345243648)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@18)
		color: 	Color black
		extension: 	a MorphExtension (110100480) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'AssignmentTemp new openInWorld'
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(430964736)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


PluggableTextMorph>>handleEdit:
	Receiver: a PluggableTextMorph(430964736)
	Arguments and temporary variables: 
		result: 	nil
		editBlock: 	[ textMorph editor evaluateSelection ]
	Receiver's instance variables: 
		bounds: 	(25.0@491.0) corner: (465.0@658.0)
		owner: 	a SystemWindow(310902784)
		submorphs: 	an Array(a TransformMorph(345243648))
		fullBounds: 	(25.0@491.0) corner: (465.0@658.0)
		color: 	Color white
		extension: 	a MorphExtension (28049408) [other:  (kmDispatcher -> a KMDispatcher...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(470810624)
		scroller: 	a TransformMorph(345243648)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(386924544)
		textMorph: 	a TextMorphForEditView(49283072)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 30)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


PluggableTextMorph>>doIt
	Receiver: a PluggableTextMorph(430964736)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(25.0@491.0) corner: (465.0@658.0)
		owner: 	a SystemWindow(310902784)
		submorphs: 	an Array(a TransformMorph(345243648))
		fullBounds: 	(25.0@491.0) corner: (465.0@658.0)
		color: 	Color white
		extension: 	a MorphExtension (28049408) [other:  (kmDispatcher -> a KMDispatcher...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(470810624)
		scroller: 	a TransformMorph(345243648)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(386924544)
		textMorph: 	a TextMorphForEditView(49283072)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 30)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


[ :morph | morph doIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
	Receiver: SmalltalkEditor
	Arguments and temporary variables: 
		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a PluggableTextMorph(430964736)
	Receiver's instance variables: 
		superclass: 	TextEditor
		methodDict: 	a MethodDictionary(#argAdvance:->SmalltalkEditor>>#argAdvance: #bro...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SmalltalkEditor
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Text-Edition'
		traitComposition: 	{}
		localSelectors: 	nil
		cmdActions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop...etc...
		shiftCmdActions: 	#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #m...etc...


BlockClosure>>cull:
	Receiver: [ :morph | morph doIt ]
	Arguments and temporary variables: 
		anArg: 	a PluggableTextMorph(430964736)
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	157
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :morph | morph doIt ]
	Arguments and temporary variables: 
		firstArg: 	a PluggableTextMorph(430964736)
		secondArg: 	a PluggableTextMorph(430964736)
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	157
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :morph | morph doIt ]
	Arguments and temporary variables: 
		firstArg: 	a PluggableTextMorph(430964736)
		secondArg: 	a PluggableTextMorph(430964736)
		thirdArg: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	157
		numArgs: 	1


KMCategoryBinding>>completeMatch:buffer:
	Receiver: aKMCategoryTarget(#SmalltalkEditor)
	Arguments and temporary variables: 
		aKeymap: 	#doIt on Cmd + D do [ :morph | morph doIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
	Receiver's instance variables: 
		target: 	a PluggableTextMorph(430964736)
		category: 	a KMCategory
		morph: 	a PluggableTextMorph(430964736)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #doIt on Cmd + D do [ :morph | morph doIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		l: 	aKMCategoryTarget(#SmalltalkEditor)
	Receiver's instance variables: 
		action: 	[ :morph | morph doIt ]
		name: 	#doIt
		shortcut: 	Cmd + D
		defaultShortcut: 	Cmd + D
		description: 	''


Array(SequenceableCollection)>>do:
	Receiver: an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #doIt on Cmd + D do [ :morph | morph doIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ :morph | morph doIt ]
		name: 	#doIt
		shortcut: 	Cmd + D
		defaultShortcut: 	Cmd + D
		description: 	''


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: #doIt on Cmd + D do [ :morph | morph doIt ]

	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		action: 	[ :morph | morph doIt ]
		name: 	#doIt
		shortcut: 	Cmd + D
		defaultShortcut: 	Cmd + D
		description: 	''


[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#doIt on Cmd + D do [ :morph | morph doIt ]

	Receiver's instance variables: 
		name: 	#SmalltalkEditor
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


Set>>do:
	Receiver: a Set(#printIt on Cmd + P do [ :morph | morph printIt ]
 #previousSelection on Cmd + Shift...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	9
		each: 	#doIt on Cmd + D do [ :morph | morph doIt ]

	Receiver's instance variables: 
		tally: 	14
		array: 	an Array(#printIt on Cmd + P do [ :morph | morph printIt ]
 #previousSel...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
	Receiver's instance variables: 
		name: 	#SmalltalkEditor
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: aKMCategoryTarget(#SmalltalkEditor)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		target: 	a PluggableTextMorph(430964736)
		category: 	a KMCategory
		morph: 	a PluggableTextMorph(430964736)


[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#SmalltalkEditor)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#TextEditor) aKM...etc...
		morph: 	a PluggableTextMorph(430964736)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#TextMorph) aKMCategoryTarge...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	6
	Receiver's instance variables: 
		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#TextMorph) aKMCategor...etc...
		firstIndex: 	1
		lastIndex: 	7


KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		association: 	nil
		match: 	nil
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#TextEditor) aKM...etc...
		morph: 	a PluggableTextMorph(430964736)
		directKeymaps: 	a KMCategory


KMTarget>>dispatch:
	Receiver: a KMTarget
	Arguments and temporary variables: 
		buffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
	Receiver's instance variables: 
		realTarget: 	nil
		morph: 	a PluggableTextMorph(430964736)
		targetSelector: 	#yourself
		directKeymaps: 	nil
		perInstanceCategories: 	nil


[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Cmd-d>']
		targetToDispatch: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>do:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatcher>>dispatchKeystroke:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		aKeyEvent: 	[keystroke '<Cmd-d>']
		chain: 	a KMDispatchChain
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...
		morph: 	a TextMorphForEditView(49283072)
		directKeymaps: 	a KMCategory


TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
	Receiver: a TextMorphForEditView(49283072)
	Arguments and temporary variables: 
		evt: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@18)
		owner: 	a TransformMorph(345243648)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@18)
		color: 	Color black
		extension: 	a MorphExtension (110100480) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'AssignmentTemp new openInWorld'
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(430964736)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(TextMorph)>>handleKeystroke:
	Receiver: a TextMorphForEditView(49283072)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-d>']
		pasteUp: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@18)
		owner: 	a TransformMorph(345243648)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@18)
		color: 	Color black
		extension: 	a MorphExtension (110100480) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'AssignmentTemp new openInWorld'
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(430964736)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


KeyboardEvent>>sentTo:
	Receiver: [keystroke '<Cmd-d>']
	Arguments and temporary variables: 
		anObject: 	a TextMorphForEditView(49283072)
	Receiver's instance variables: 
		timeStamp: 	1563334
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#keystroke
		buttons: 	64
		position: 	(266.0@66.0)
		handler: 	nil
		wasHandled: 	true
		keyValue: 	100
		charCode: 	100
		scanCode: 	2


TextMorphForEditView(Morph)>>handleEvent:
	Receiver: a TextMorphForEditView(49283072)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@18)
		owner: 	a TransformMorph(345243648)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@18)
		color: 	Color black
		extension: 	a MorphExtension (110100480) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'AssignmentTemp new openInWorld'
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(430964736)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(Morph)>>handleFocusEvent:
	Receiver: a TextMorphForEditView(49283072)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@18)
		owner: 	a TransformMorph(345243648)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@18)
		color: 	Color black
		extension: 	a MorphExtension (110100480) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'AssignmentTemp new openInWorld'
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(430964736)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-d>']
		focusHolder: 	a TextMorphForEditView(49283072)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(295@558.0) corner: (311@574.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a TextMorphForEditView(49283072)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(295@558) mouseOver nil nil]
		targetOffset: 	(270.0@67.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 1562642 295 558 0 0 0 1)
		lastKeyScanCode: 	2
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0



--- The full stack ---
AssignmentTemp(Object)>>doesNotUnderstand: #label:
AssignmentTemp>>initialize
AssignmentTemp class(Behavior)>>new
UndefinedObject>>DoIt
OpalCompiler>>evaluate
SmalltalkEditor>>evaluateSelectionAndDo:
SmalltalkEditor>>evaluateSelection
[ textMorph editor evaluateSelection ] in PluggableTextMorph>>doIt
[ result := editBlock value ] in PluggableTextMorph>>handleEdit:
TextMorphForEditView(TextMorph)>>handleEdit:
PluggableTextMorph>>handleEdit:
PluggableTextMorph>>doIt
[ :morph | morph doIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
TextMorphForEditView(TextMorph)>>handleKeystroke:
KeyboardEvent>>sentTo:
TextMorphForEditView(Morph)>>handleEvent:
TextMorphForEditView(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: receiver of "contents:" is nil
17 October 2014 2:24:31.639963 pm

VM: Mac OS - intel - 1090 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30858]

UndefinedObject(Object)>>doesNotUnderstand: #contents:
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	contents: 'Temp Converter'
		exception: 	MessageNotUnderstood: receiver of "contents:" is nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

AssignmentTemp>>initialize
	Receiver: an AssignmentTemp(889454592)
	Arguments and temporary variables: 
		titleLabel: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (50@40)
		owner: 	nil
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	nil
		borderWidth: 	2
		borderColor: 	Color black


AssignmentTemp class(Behavior)>>new
	Receiver: AssignmentTemp
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	BorderedMorph
		methodDict: 	a MethodDictionary(#initialize->AssignmentTemp>>#initialize )
		format: 	146
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#AssignmentTemp
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#Assignment
		traitComposition: 	{}
		localSelectors: 	nil
		announcer: 	nil
		initialize: 	nil
		bounds: 	nil
		initalize: 	nil


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'AssignmentTemp new openInWorld'
		itsSelection: 	a Text for 'AssignmentTemp new openInWorld'
		itsSelectionString: 	'AssignmentTemp new openInWorld'
	Receiver's instance variables: 
		ast: 	DoIt
	^ AssignmentTemp new openInWorld
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


SmalltalkEditor>>evaluateSelectionAndDo:
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(49283072)
		selectionShowing: 	true
		model: 	a Workspace
		editingState: 	a SmalltalkEditingState


SmalltalkEditor>>evaluateSelection
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(49283072)
		selectionShowing: 	true
		model: 	a Workspace
		editingState: 	a SmalltalkEditingState


[ textMorph editor evaluateSelection ] in PluggableTextMorph>>doIt
	Receiver: a PluggableTextMorph(430964736)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(25.0@491.0) corner: (465.0@658.0)
		owner: 	a SystemWindow(310902784)
		submorphs: 	an Array(a TransformMorph(345243648))
		fullBounds: 	(25@491) corner: (465@658)
		color: 	Color white
		extension: 	a MorphExtension (28049408) [other:  (kmDispatcher -> a KMDispatcher...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(470810624)
		scroller: 	a TransformMorph(345243648)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(386924544)
		textMorph: 	a TextMorphForEditView(49283072)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 30)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


[ result := editBlock value ] in PluggableTextMorph>>handleEdit:
	Receiver: a PluggableTextMorph(430964736)
	Arguments and temporary variables: 
		editBlock: 	[ textMorph editor evaluateSelection ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(25.0@491.0) corner: (465.0@658.0)
		owner: 	a SystemWindow(310902784)
		submorphs: 	an Array(a TransformMorph(345243648))
		fullBounds: 	(25@491) corner: (465@658)
		color: 	Color white
		extension: 	a MorphExtension (28049408) [other:  (kmDispatcher -> a KMDispatcher...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(470810624)
		scroller: 	a TransformMorph(345243648)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(386924544)
		textMorph: 	a TextMorphForEditView(49283072)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 30)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


TextMorphForEditView(TextMorph)>>handleEdit:
	Receiver: a TextMorphForEditView(49283072)
	Arguments and temporary variables: 
		editBlock: 	[ result := editBlock value ]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@18)
		owner: 	a TransformMorph(345243648)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@18)
		color: 	Color black
		extension: 	a MorphExtension (110100480) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'AssignmentTemp new openInWorld'
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(430964736)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


PluggableTextMorph>>handleEdit:
	Receiver: a PluggableTextMorph(430964736)
	Arguments and temporary variables: 
		result: 	nil
		editBlock: 	[ textMorph editor evaluateSelection ]
	Receiver's instance variables: 
		bounds: 	(25.0@491.0) corner: (465.0@658.0)
		owner: 	a SystemWindow(310902784)
		submorphs: 	an Array(a TransformMorph(345243648))
		fullBounds: 	(25@491) corner: (465@658)
		color: 	Color white
		extension: 	a MorphExtension (28049408) [other:  (kmDispatcher -> a KMDispatcher...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(470810624)
		scroller: 	a TransformMorph(345243648)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(386924544)
		textMorph: 	a TextMorphForEditView(49283072)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 30)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


PluggableTextMorph>>doIt
	Receiver: a PluggableTextMorph(430964736)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(25.0@491.0) corner: (465.0@658.0)
		owner: 	a SystemWindow(310902784)
		submorphs: 	an Array(a TransformMorph(345243648))
		fullBounds: 	(25@491) corner: (465@658)
		color: 	Color white
		extension: 	a MorphExtension (28049408) [other:  (kmDispatcher -> a KMDispatcher...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(470810624)
		scroller: 	a TransformMorph(345243648)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(386924544)
		textMorph: 	a TextMorphForEditView(49283072)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 30)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


[ :morph | morph doIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
	Receiver: SmalltalkEditor
	Arguments and temporary variables: 
		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a PluggableTextMorph(430964736)
	Receiver's instance variables: 
		superclass: 	TextEditor
		methodDict: 	a MethodDictionary(#argAdvance:->SmalltalkEditor>>#argAdvance: #bro...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SmalltalkEditor
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Text-Edition'
		traitComposition: 	{}
		localSelectors: 	nil
		cmdActions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop...etc...
		shiftCmdActions: 	#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #m...etc...


BlockClosure>>cull:
	Receiver: [ :morph | morph doIt ]
	Arguments and temporary variables: 
		anArg: 	a PluggableTextMorph(430964736)
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	157
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :morph | morph doIt ]
	Arguments and temporary variables: 
		firstArg: 	a PluggableTextMorph(430964736)
		secondArg: 	a PluggableTextMorph(430964736)
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	157
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :morph | morph doIt ]
	Arguments and temporary variables: 
		firstArg: 	a PluggableTextMorph(430964736)
		secondArg: 	a PluggableTextMorph(430964736)
		thirdArg: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	157
		numArgs: 	1


KMCategoryBinding>>completeMatch:buffer:
	Receiver: aKMCategoryTarget(#SmalltalkEditor)
	Arguments and temporary variables: 
		aKeymap: 	#doIt on Cmd + D do [ :morph | morph doIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
	Receiver's instance variables: 
		target: 	a PluggableTextMorph(430964736)
		category: 	a KMCategory
		morph: 	a PluggableTextMorph(430964736)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #doIt on Cmd + D do [ :morph | morph doIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		l: 	aKMCategoryTarget(#SmalltalkEditor)
	Receiver's instance variables: 
		action: 	[ :morph | morph doIt ]
		name: 	#doIt
		shortcut: 	Cmd + D
		defaultShortcut: 	Cmd + D
		description: 	''


Array(SequenceableCollection)>>do:
	Receiver: an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #doIt on Cmd + D do [ :morph | morph doIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ :morph | morph doIt ]
		name: 	#doIt
		shortcut: 	Cmd + D
		defaultShortcut: 	Cmd + D
		description: 	''


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: #doIt on Cmd + D do [ :morph | morph doIt ]

	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		action: 	[ :morph | morph doIt ]
		name: 	#doIt
		shortcut: 	Cmd + D
		defaultShortcut: 	Cmd + D
		description: 	''


[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#doIt on Cmd + D do [ :morph | morph doIt ]

	Receiver's instance variables: 
		name: 	#SmalltalkEditor
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


Set>>do:
	Receiver: a Set(#printIt on Cmd + P do [ :morph | morph printIt ]
 #previousSelection on Cmd + Shift...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	9
		each: 	#doIt on Cmd + D do [ :morph | morph doIt ]

	Receiver's instance variables: 
		tally: 	14
		array: 	an Array(#printIt on Cmd + P do [ :morph | morph printIt ]
 #previousSel...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
	Receiver's instance variables: 
		name: 	#SmalltalkEditor
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: aKMCategoryTarget(#SmalltalkEditor)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		target: 	a PluggableTextMorph(430964736)
		category: 	a KMCategory
		morph: 	a PluggableTextMorph(430964736)


[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#SmalltalkEditor)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#TextEditor) aKM...etc...
		morph: 	a PluggableTextMorph(430964736)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#TextMorph) aKMCategoryTarge...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	6
	Receiver's instance variables: 
		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#TextMorph) aKMCategor...etc...
		firstIndex: 	1
		lastIndex: 	7


KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		association: 	nil
		match: 	nil
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#TextEditor) aKM...etc...
		morph: 	a PluggableTextMorph(430964736)
		directKeymaps: 	a KMCategory


KMTarget>>dispatch:
	Receiver: a KMTarget
	Arguments and temporary variables: 
		buffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
	Receiver's instance variables: 
		realTarget: 	nil
		morph: 	a PluggableTextMorph(430964736)
		targetSelector: 	#yourself
		directKeymaps: 	nil
		perInstanceCategories: 	nil


[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Cmd-d>']
		targetToDispatch: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>do:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatcher>>dispatchKeystroke:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		aKeyEvent: 	[keystroke '<Cmd-d>']
		chain: 	a KMDispatchChain
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...
		morph: 	a TextMorphForEditView(49283072)
		directKeymaps: 	a KMCategory


TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
	Receiver: a TextMorphForEditView(49283072)
	Arguments and temporary variables: 
		evt: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@18)
		owner: 	a TransformMorph(345243648)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@18)
		color: 	Color black
		extension: 	a MorphExtension (110100480) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'AssignmentTemp new openInWorld'
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(430964736)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(TextMorph)>>handleKeystroke:
	Receiver: a TextMorphForEditView(49283072)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-d>']
		pasteUp: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@18)
		owner: 	a TransformMorph(345243648)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@18)
		color: 	Color black
		extension: 	a MorphExtension (110100480) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'AssignmentTemp new openInWorld'
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(430964736)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


KeyboardEvent>>sentTo:
	Receiver: [keystroke '<Cmd-d>']
	Arguments and temporary variables: 
		anObject: 	a TextMorphForEditView(49283072)
	Receiver's instance variables: 
		timeStamp: 	1765000
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#keystroke
		buttons: 	64
		position: 	(131.0@86.0)
		handler: 	nil
		wasHandled: 	true
		keyValue: 	100
		charCode: 	100
		scanCode: 	2


TextMorphForEditView(Morph)>>handleEvent:
	Receiver: a TextMorphForEditView(49283072)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@18)
		owner: 	a TransformMorph(345243648)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@18)
		color: 	Color black
		extension: 	a MorphExtension (110100480) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'AssignmentTemp new openInWorld'
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(430964736)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(Morph)>>handleFocusEvent:
	Receiver: a TextMorphForEditView(49283072)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@18)
		owner: 	a TransformMorph(345243648)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@18)
		color: 	Color black
		extension: 	a MorphExtension (110100480) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'AssignmentTemp new openInWorld'
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(430964736)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-d>']
		focusHolder: 	a TextMorphForEditView(49283072)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(160@578.0) corner: (176@594.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a TextMorphForEditView(49283072)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(160@578) mouseOver nil nil]
		targetOffset: 	(135.0@87.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 1764028 160 578 0 0 0 1)
		lastKeyScanCode: 	2
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	8



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #contents:
AssignmentTemp>>initialize
AssignmentTemp class(Behavior)>>new
UndefinedObject>>DoIt
OpalCompiler>>evaluate
SmalltalkEditor>>evaluateSelectionAndDo:
SmalltalkEditor>>evaluateSelection
[ textMorph editor evaluateSelection ] in PluggableTextMorph>>doIt
[ result := editBlock value ] in PluggableTextMorph>>handleEdit:
TextMorphForEditView(TextMorph)>>handleEdit:
PluggableTextMorph>>handleEdit:
PluggableTextMorph>>doIt
[ :morph | morph doIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
TextMorphForEditView(TextMorph)>>handleKeystroke:
KeyboardEvent>>sentTo:
TextMorphForEditView(Morph)>>handleEvent:
TextMorphForEditView(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: receiver of "contents:" is nil
17 October 2014 2:24:50.474675 pm

VM: Mac OS - intel - 1090 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30858]

UndefinedObject(Object)>>doesNotUnderstand: #contents:
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	contents: 'Temp Converter'
		exception: 	MessageNotUnderstood: receiver of "contents:" is nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

AssignmentTemp>>initialize
	Receiver: an AssignmentTemp(576716800)
	Arguments and temporary variables: 
		titleLabel: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (50@40)
		owner: 	nil
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	nil
		borderWidth: 	2
		borderColor: 	Color black


AssignmentTemp class(Behavior)>>new
	Receiver: AssignmentTemp
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	BorderedMorph
		methodDict: 	a MethodDictionary(#initialize->AssignmentTemp>>#initialize )
		format: 	146
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#AssignmentTemp
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#Assignment
		traitComposition: 	{}
		localSelectors: 	nil
		announcer: 	nil
		initialize: 	nil
		bounds: 	nil
		initalize: 	nil


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'AssignmentTemp new openInWorld'
		itsSelection: 	a Text for 'AssignmentTemp new openInWorld'
		itsSelectionString: 	'AssignmentTemp new openInWorld'
	Receiver's instance variables: 
		ast: 	DoIt
	^ AssignmentTemp new openInWorld
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


SmalltalkEditor>>evaluateSelectionAndDo:
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(49283072)
		selectionShowing: 	true
		model: 	a Workspace
		editingState: 	a SmalltalkEditingState


SmalltalkEditor>>evaluateSelection
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(49283072)
		selectionShowing: 	true
		model: 	a Workspace
		editingState: 	a SmalltalkEditingState


[ textMorph editor evaluateSelection ] in PluggableTextMorph>>doIt
	Receiver: a PluggableTextMorph(430964736)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(25.0@491.0) corner: (465.0@658.0)
		owner: 	a SystemWindow(310902784)
		submorphs: 	an Array(a TransformMorph(345243648))
		fullBounds: 	(25@491) corner: (465@658)
		color: 	Color white
		extension: 	a MorphExtension (28049408) [other:  (kmDispatcher -> a KMDispatcher...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(470810624)
		scroller: 	a TransformMorph(345243648)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(386924544)
		textMorph: 	a TextMorphForEditView(49283072)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 30)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


[ result := editBlock value ] in PluggableTextMorph>>handleEdit:
	Receiver: a PluggableTextMorph(430964736)
	Arguments and temporary variables: 
		editBlock: 	[ textMorph editor evaluateSelection ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(25.0@491.0) corner: (465.0@658.0)
		owner: 	a SystemWindow(310902784)
		submorphs: 	an Array(a TransformMorph(345243648))
		fullBounds: 	(25@491) corner: (465@658)
		color: 	Color white
		extension: 	a MorphExtension (28049408) [other:  (kmDispatcher -> a KMDispatcher...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(470810624)
		scroller: 	a TransformMorph(345243648)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(386924544)
		textMorph: 	a TextMorphForEditView(49283072)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 30)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


TextMorphForEditView(TextMorph)>>handleEdit:
	Receiver: a TextMorphForEditView(49283072)
	Arguments and temporary variables: 
		editBlock: 	[ result := editBlock value ]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@18)
		owner: 	a TransformMorph(345243648)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@18)
		color: 	Color black
		extension: 	a MorphExtension (110100480) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'AssignmentTemp new openInWorld'
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(430964736)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


PluggableTextMorph>>handleEdit:
	Receiver: a PluggableTextMorph(430964736)
	Arguments and temporary variables: 
		result: 	nil
		editBlock: 	[ textMorph editor evaluateSelection ]
	Receiver's instance variables: 
		bounds: 	(25.0@491.0) corner: (465.0@658.0)
		owner: 	a SystemWindow(310902784)
		submorphs: 	an Array(a TransformMorph(345243648))
		fullBounds: 	(25@491) corner: (465@658)
		color: 	Color white
		extension: 	a MorphExtension (28049408) [other:  (kmDispatcher -> a KMDispatcher...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(470810624)
		scroller: 	a TransformMorph(345243648)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(386924544)
		textMorph: 	a TextMorphForEditView(49283072)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 30)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


PluggableTextMorph>>doIt
	Receiver: a PluggableTextMorph(430964736)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(25.0@491.0) corner: (465.0@658.0)
		owner: 	a SystemWindow(310902784)
		submorphs: 	an Array(a TransformMorph(345243648))
		fullBounds: 	(25@491) corner: (465@658)
		color: 	Color white
		extension: 	a MorphExtension (28049408) [other:  (kmDispatcher -> a KMDispatcher...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(470810624)
		scroller: 	a TransformMorph(345243648)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(386924544)
		textMorph: 	a TextMorphForEditView(49283072)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 30)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


[ :morph | morph doIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
	Receiver: SmalltalkEditor
	Arguments and temporary variables: 
		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a PluggableTextMorph(430964736)
	Receiver's instance variables: 
		superclass: 	TextEditor
		methodDict: 	a MethodDictionary(#argAdvance:->SmalltalkEditor>>#argAdvance: #bro...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SmalltalkEditor
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Text-Edition'
		traitComposition: 	{}
		localSelectors: 	nil
		cmdActions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop...etc...
		shiftCmdActions: 	#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #m...etc...


BlockClosure>>cull:
	Receiver: [ :morph | morph doIt ]
	Arguments and temporary variables: 
		anArg: 	a PluggableTextMorph(430964736)
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	157
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :morph | morph doIt ]
	Arguments and temporary variables: 
		firstArg: 	a PluggableTextMorph(430964736)
		secondArg: 	a PluggableTextMorph(430964736)
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	157
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :morph | morph doIt ]
	Arguments and temporary variables: 
		firstArg: 	a PluggableTextMorph(430964736)
		secondArg: 	a PluggableTextMorph(430964736)
		thirdArg: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	157
		numArgs: 	1


KMCategoryBinding>>completeMatch:buffer:
	Receiver: aKMCategoryTarget(#SmalltalkEditor)
	Arguments and temporary variables: 
		aKeymap: 	#doIt on Cmd + D do [ :morph | morph doIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
	Receiver's instance variables: 
		target: 	a PluggableTextMorph(430964736)
		category: 	a KMCategory
		morph: 	a PluggableTextMorph(430964736)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #doIt on Cmd + D do [ :morph | morph doIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		l: 	aKMCategoryTarget(#SmalltalkEditor)
	Receiver's instance variables: 
		action: 	[ :morph | morph doIt ]
		name: 	#doIt
		shortcut: 	Cmd + D
		defaultShortcut: 	Cmd + D
		description: 	''


Array(SequenceableCollection)>>do:
	Receiver: an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #doIt on Cmd + D do [ :morph | morph doIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ :morph | morph doIt ]
		name: 	#doIt
		shortcut: 	Cmd + D
		defaultShortcut: 	Cmd + D
		description: 	''


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: #doIt on Cmd + D do [ :morph | morph doIt ]

	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		action: 	[ :morph | morph doIt ]
		name: 	#doIt
		shortcut: 	Cmd + D
		defaultShortcut: 	Cmd + D
		description: 	''


[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#doIt on Cmd + D do [ :morph | morph doIt ]

	Receiver's instance variables: 
		name: 	#SmalltalkEditor
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


Set>>do:
	Receiver: a Set(#printIt on Cmd + P do [ :morph | morph printIt ]
 #previousSelection on Cmd + Shift...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	9
		each: 	#doIt on Cmd + D do [ :morph | morph doIt ]

	Receiver's instance variables: 
		tally: 	14
		array: 	an Array(#printIt on Cmd + P do [ :morph | morph printIt ]
 #previousSel...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
	Receiver's instance variables: 
		name: 	#SmalltalkEditor
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: aKMCategoryTarget(#SmalltalkEditor)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		target: 	a PluggableTextMorph(430964736)
		category: 	a KMCategory
		morph: 	a PluggableTextMorph(430964736)


[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#SmalltalkEditor)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#TextEditor) aKM...etc...
		morph: 	a PluggableTextMorph(430964736)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#TextMorph) aKMCategoryTarge...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	6
	Receiver's instance variables: 
		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#TextMorph) aKMCategor...etc...
		firstIndex: 	1
		lastIndex: 	7


KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		association: 	nil
		match: 	nil
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#TextEditor) aKM...etc...
		morph: 	a PluggableTextMorph(430964736)
		directKeymaps: 	a KMCategory


KMTarget>>dispatch:
	Receiver: a KMTarget
	Arguments and temporary variables: 
		buffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
	Receiver's instance variables: 
		realTarget: 	nil
		morph: 	a PluggableTextMorph(430964736)
		targetSelector: 	#yourself
		directKeymaps: 	nil
		perInstanceCategories: 	nil


[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Cmd-d>']
		targetToDispatch: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>do:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatcher>>dispatchKeystroke:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		aKeyEvent: 	[keystroke '<Cmd-d>']
		chain: 	a KMDispatchChain
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...
		morph: 	a TextMorphForEditView(49283072)
		directKeymaps: 	a KMCategory


TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
	Receiver: a TextMorphForEditView(49283072)
	Arguments and temporary variables: 
		evt: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@18)
		owner: 	a TransformMorph(345243648)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@18)
		color: 	Color black
		extension: 	a MorphExtension (110100480) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'AssignmentTemp new openInWorld'
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(430964736)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(TextMorph)>>handleKeystroke:
	Receiver: a TextMorphForEditView(49283072)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-d>']
		pasteUp: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@18)
		owner: 	a TransformMorph(345243648)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@18)
		color: 	Color black
		extension: 	a MorphExtension (110100480) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'AssignmentTemp new openInWorld'
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(430964736)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


KeyboardEvent>>sentTo:
	Receiver: [keystroke '<Cmd-d>']
	Arguments and temporary variables: 
		anObject: 	a TextMorphForEditView(49283072)
	Receiver's instance variables: 
		timeStamp: 	1783831
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#keystroke
		buttons: 	64
		position: 	(151.0@93.0)
		handler: 	nil
		wasHandled: 	true
		keyValue: 	100
		charCode: 	100
		scanCode: 	2


TextMorphForEditView(Morph)>>handleEvent:
	Receiver: a TextMorphForEditView(49283072)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@18)
		owner: 	a TransformMorph(345243648)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@18)
		color: 	Color black
		extension: 	a MorphExtension (110100480) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'AssignmentTemp new openInWorld'
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(430964736)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(Morph)>>handleFocusEvent:
	Receiver: a TextMorphForEditView(49283072)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@18)
		owner: 	a TransformMorph(345243648)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@18)
		color: 	Color black
		extension: 	a MorphExtension (110100480) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'AssignmentTemp new openInWorld'
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(430964736)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-d>']
		focusHolder: 	a TextMorphForEditView(49283072)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(180@585.0) corner: (196@601.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a TextMorphForEditView(49283072)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(180@585) mouseOver nil nil]
		targetOffset: 	(155.0@94.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 1781934 180 585 0 0 0 1)
		lastKeyScanCode: 	2
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	8



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #contents:
AssignmentTemp>>initialize
AssignmentTemp class(Behavior)>>new
UndefinedObject>>DoIt
OpalCompiler>>evaluate
SmalltalkEditor>>evaluateSelectionAndDo:
SmalltalkEditor>>evaluateSelection
[ textMorph editor evaluateSelection ] in PluggableTextMorph>>doIt
[ result := editBlock value ] in PluggableTextMorph>>handleEdit:
TextMorphForEditView(TextMorph)>>handleEdit:
PluggableTextMorph>>handleEdit:
PluggableTextMorph>>doIt
[ :morph | morph doIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
TextMorphForEditView(TextMorph)>>handleKeystroke:
KeyboardEvent>>sentTo:
TextMorphForEditView(Morph)>>handleEvent:
TextMorphForEditView(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: AssignmentTemp>>label
17 October 2014 2:25:22.92106 pm

VM: Mac OS - intel - 1090 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30858]

AssignmentTemp(Object)>>doesNotUnderstand: #label
	Receiver: an AssignmentTemp(242221056)
	Arguments and temporary variables: 
		aMessage: 	label
		exception: 	MessageNotUnderstood: AssignmentTemp>>label
		resumeValue: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (50@40)
		owner: 	nil
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	nil
		borderWidth: 	2
		borderColor: 	Color black


AssignmentTemp>>initialize
	Receiver: an AssignmentTemp(242221056)
	Arguments and temporary variables: 
		titleLabel: 	a StringMorph(285999104)'Temp Converter'
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (50@40)
		owner: 	nil
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	nil
		borderWidth: 	2
		borderColor: 	Color black


AssignmentTemp class(Behavior)>>new
	Receiver: AssignmentTemp
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	BorderedMorph
		methodDict: 	a MethodDictionary(#initialize->AssignmentTemp>>#initialize )
		format: 	146
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#AssignmentTemp
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#Assignment
		traitComposition: 	{}
		localSelectors: 	nil
		announcer: 	nil
		initialize: 	nil
		bounds: 	nil
		initalize: 	nil


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'AssignmentTemp new openInWorld'
		itsSelection: 	a Text for 'AssignmentTemp new openInWorld'
		itsSelectionString: 	'AssignmentTemp new openInWorld'
	Receiver's instance variables: 
		ast: 	DoIt
	^ AssignmentTemp new openInWorld
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


SmalltalkEditor>>evaluateSelectionAndDo:
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(49283072)
		selectionShowing: 	true
		model: 	a Workspace
		editingState: 	a SmalltalkEditingState


SmalltalkEditor>>evaluateSelection
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(49283072)
		selectionShowing: 	true
		model: 	a Workspace
		editingState: 	a SmalltalkEditingState


[ textMorph editor evaluateSelection ] in PluggableTextMorph>>doIt
	Receiver: a PluggableTextMorph(430964736)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(25.0@491.0) corner: (465.0@658.0)
		owner: 	a SystemWindow(310902784)
		submorphs: 	an Array(a TransformMorph(345243648))
		fullBounds: 	(25@491) corner: (465@658)
		color: 	Color white
		extension: 	a MorphExtension (28049408) [other:  (kmDispatcher -> a KMDispatcher...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(470810624)
		scroller: 	a TransformMorph(345243648)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(386924544)
		textMorph: 	a TextMorphForEditView(49283072)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 30)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


[ result := editBlock value ] in PluggableTextMorph>>handleEdit:
	Receiver: a PluggableTextMorph(430964736)
	Arguments and temporary variables: 
		editBlock: 	[ textMorph editor evaluateSelection ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(25.0@491.0) corner: (465.0@658.0)
		owner: 	a SystemWindow(310902784)
		submorphs: 	an Array(a TransformMorph(345243648))
		fullBounds: 	(25@491) corner: (465@658)
		color: 	Color white
		extension: 	a MorphExtension (28049408) [other:  (kmDispatcher -> a KMDispatcher...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(470810624)
		scroller: 	a TransformMorph(345243648)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(386924544)
		textMorph: 	a TextMorphForEditView(49283072)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 30)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


TextMorphForEditView(TextMorph)>>handleEdit:
	Receiver: a TextMorphForEditView(49283072)
	Arguments and temporary variables: 
		editBlock: 	[ result := editBlock value ]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@18)
		owner: 	a TransformMorph(345243648)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@18)
		color: 	Color black
		extension: 	a MorphExtension (110100480) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'AssignmentTemp new openInWorld'
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(430964736)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


PluggableTextMorph>>handleEdit:
	Receiver: a PluggableTextMorph(430964736)
	Arguments and temporary variables: 
		result: 	nil
		editBlock: 	[ textMorph editor evaluateSelection ]
	Receiver's instance variables: 
		bounds: 	(25.0@491.0) corner: (465.0@658.0)
		owner: 	a SystemWindow(310902784)
		submorphs: 	an Array(a TransformMorph(345243648))
		fullBounds: 	(25@491) corner: (465@658)
		color: 	Color white
		extension: 	a MorphExtension (28049408) [other:  (kmDispatcher -> a KMDispatcher...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(470810624)
		scroller: 	a TransformMorph(345243648)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(386924544)
		textMorph: 	a TextMorphForEditView(49283072)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 30)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


PluggableTextMorph>>doIt
	Receiver: a PluggableTextMorph(430964736)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(25.0@491.0) corner: (465.0@658.0)
		owner: 	a SystemWindow(310902784)
		submorphs: 	an Array(a TransformMorph(345243648))
		fullBounds: 	(25@491) corner: (465@658)
		color: 	Color white
		extension: 	a MorphExtension (28049408) [other:  (kmDispatcher -> a KMDispatcher...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(470810624)
		scroller: 	a TransformMorph(345243648)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(386924544)
		textMorph: 	a TextMorphForEditView(49283072)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 30)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


[ :morph | morph doIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
	Receiver: SmalltalkEditor
	Arguments and temporary variables: 
		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a PluggableTextMorph(430964736)
	Receiver's instance variables: 
		superclass: 	TextEditor
		methodDict: 	a MethodDictionary(#argAdvance:->SmalltalkEditor>>#argAdvance: #bro...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SmalltalkEditor
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Text-Edition'
		traitComposition: 	{}
		localSelectors: 	nil
		cmdActions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop...etc...
		shiftCmdActions: 	#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #m...etc...


BlockClosure>>cull:
	Receiver: [ :morph | morph doIt ]
	Arguments and temporary variables: 
		anArg: 	a PluggableTextMorph(430964736)
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	157
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :morph | morph doIt ]
	Arguments and temporary variables: 
		firstArg: 	a PluggableTextMorph(430964736)
		secondArg: 	a PluggableTextMorph(430964736)
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	157
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :morph | morph doIt ]
	Arguments and temporary variables: 
		firstArg: 	a PluggableTextMorph(430964736)
		secondArg: 	a PluggableTextMorph(430964736)
		thirdArg: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	157
		numArgs: 	1


KMCategoryBinding>>completeMatch:buffer:
	Receiver: aKMCategoryTarget(#SmalltalkEditor)
	Arguments and temporary variables: 
		aKeymap: 	#doIt on Cmd + D do [ :morph | morph doIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
	Receiver's instance variables: 
		target: 	a PluggableTextMorph(430964736)
		category: 	a KMCategory
		morph: 	a PluggableTextMorph(430964736)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #doIt on Cmd + D do [ :morph | morph doIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		l: 	aKMCategoryTarget(#SmalltalkEditor)
	Receiver's instance variables: 
		action: 	[ :morph | morph doIt ]
		name: 	#doIt
		shortcut: 	Cmd + D
		defaultShortcut: 	Cmd + D
		description: 	''


Array(SequenceableCollection)>>do:
	Receiver: an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #doIt on Cmd + D do [ :morph | morph doIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ :morph | morph doIt ]
		name: 	#doIt
		shortcut: 	Cmd + D
		defaultShortcut: 	Cmd + D
		description: 	''


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: #doIt on Cmd + D do [ :morph | morph doIt ]

	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		action: 	[ :morph | morph doIt ]
		name: 	#doIt
		shortcut: 	Cmd + D
		defaultShortcut: 	Cmd + D
		description: 	''


[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#doIt on Cmd + D do [ :morph | morph doIt ]

	Receiver's instance variables: 
		name: 	#SmalltalkEditor
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


Set>>do:
	Receiver: a Set(#printIt on Cmd + P do [ :morph | morph printIt ]
 #previousSelection on Cmd + Shift...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	9
		each: 	#doIt on Cmd + D do [ :morph | morph doIt ]

	Receiver's instance variables: 
		tally: 	14
		array: 	an Array(#printIt on Cmd + P do [ :morph | morph printIt ]
 #previousSel...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
	Receiver's instance variables: 
		name: 	#SmalltalkEditor
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: aKMCategoryTarget(#SmalltalkEditor)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		target: 	a PluggableTextMorph(430964736)
		category: 	a KMCategory
		morph: 	a PluggableTextMorph(430964736)


[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#SmalltalkEditor)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#TextEditor) aKM...etc...
		morph: 	a PluggableTextMorph(430964736)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#TextMorph) aKMCategoryTarge...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	6
	Receiver's instance variables: 
		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#TextMorph) aKMCategor...etc...
		firstIndex: 	1
		lastIndex: 	7


KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		association: 	nil
		match: 	nil
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#TextEditor) aKM...etc...
		morph: 	a PluggableTextMorph(430964736)
		directKeymaps: 	a KMCategory


KMTarget>>dispatch:
	Receiver: a KMTarget
	Arguments and temporary variables: 
		buffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
	Receiver's instance variables: 
		realTarget: 	nil
		morph: 	a PluggableTextMorph(430964736)
		targetSelector: 	#yourself
		directKeymaps: 	nil
		perInstanceCategories: 	nil


[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Cmd-d>']
		targetToDispatch: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>do:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatcher>>dispatchKeystroke:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		aKeyEvent: 	[keystroke '<Cmd-d>']
		chain: 	a KMDispatchChain
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...
		morph: 	a TextMorphForEditView(49283072)
		directKeymaps: 	a KMCategory


TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
	Receiver: a TextMorphForEditView(49283072)
	Arguments and temporary variables: 
		evt: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@18)
		owner: 	a TransformMorph(345243648)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@18)
		color: 	Color black
		extension: 	a MorphExtension (110100480) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'AssignmentTemp new openInWorld'
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(430964736)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(TextMorph)>>handleKeystroke:
	Receiver: a TextMorphForEditView(49283072)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-d>']
		pasteUp: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@18)
		owner: 	a TransformMorph(345243648)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@18)
		color: 	Color black
		extension: 	a MorphExtension (110100480) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'AssignmentTemp new openInWorld'
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(430964736)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


KeyboardEvent>>sentTo:
	Receiver: [keystroke '<Cmd-d>']
	Arguments and temporary variables: 
		anObject: 	a TextMorphForEditView(49283072)
	Receiver's instance variables: 
		timeStamp: 	1816262
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#keystroke
		buttons: 	64
		position: 	(251.0@73.0)
		handler: 	nil
		wasHandled: 	true
		keyValue: 	100
		charCode: 	100
		scanCode: 	2


TextMorphForEditView(Morph)>>handleEvent:
	Receiver: a TextMorphForEditView(49283072)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@18)
		owner: 	a TransformMorph(345243648)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@18)
		color: 	Color black
		extension: 	a MorphExtension (110100480) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'AssignmentTemp new openInWorld'
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(430964736)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(Morph)>>handleFocusEvent:
	Receiver: a TextMorphForEditView(49283072)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@18)
		owner: 	a TransformMorph(345243648)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@18)
		color: 	Color black
		extension: 	a MorphExtension (110100480) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'AssignmentTemp new openInWorld'
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(430964736)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-d>']
		focusHolder: 	a TextMorphForEditView(49283072)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(280@565.0) corner: (296@581.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a TextMorphForEditView(49283072)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(280@565) mouseOver nil nil]
		targetOffset: 	(255.0@74.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 1815504 280 565 0 0 0 1)
		lastKeyScanCode: 	2
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	8



--- The full stack ---
AssignmentTemp(Object)>>doesNotUnderstand: #label
AssignmentTemp>>initialize
AssignmentTemp class(Behavior)>>new
UndefinedObject>>DoIt
OpalCompiler>>evaluate
SmalltalkEditor>>evaluateSelectionAndDo:
SmalltalkEditor>>evaluateSelection
[ textMorph editor evaluateSelection ] in PluggableTextMorph>>doIt
[ result := editBlock value ] in PluggableTextMorph>>handleEdit:
TextMorphForEditView(TextMorph)>>handleEdit:
PluggableTextMorph>>handleEdit:
PluggableTextMorph>>doIt
[ :morph | morph doIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
TextMorphForEditView(TextMorph)>>handleKeystroke:
KeyboardEvent>>sentTo:
TextMorphForEditView(Morph)>>handleEvent:
TextMorphForEditView(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Error: MessageNotUnderstood: Float>>isTranslucent
17 October 2014 2:37:40.165633 pm

VM: Mac OS - intel - 1090 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30858]

Float(Object)>>error:
	Receiver: 0.0
	Arguments and temporary variables: 
		aString: 	'MessageNotUnderstood: Float>>isTranslucent'
	Receiver's instance variables: 
0.0

[ :err :rcvr | 
| errCtx "Handle a drawing error" errMorph |
errCtx := thisContext.
[ 
errCtx := errCtx sender.	"Search the sender chain to find the morph causing the problem"
[ errCtx notNil and: [ errCtx receiver isMorph not ] ] whileTrue: [ errCtx := errCtx sender ].	"If we're at the root of the context chain then we have a fatal drawing problem"
errCtx ifNil: [ ^ self handleFatalDrawingError: err ].
errMorph := errCtx receiver.	"If the morph causing the problem has already the #drawError flag set,
			then search for the next morph above in the caller chain."
errMorph hasProperty: #errorOnDraw ] whileTrue.
errMorph setProperty: #errorOnDraw toValue: true.	"Install the old error handler, so we can re-raise the error"
rcvr error: err ] in WorldState>>displayWorldSafely:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		err: 	'MessageNotUnderstood: Float>>isTranslucent'
		rcvr: 	0.0
		errCtx: 	AssignmentTemp(Morph)>>areasRemainingToFill:
		errMorph: 	an AssignmentTemp(525860864)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1208@742)
		canvas: 	a FormCanvas on: DisplayScreen(1208x742x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(470024192))(a DropList...etc...
		lastStepTime: 	2553548
		lastStepMessage: 	nil
		lastCycleTime: 	2553548
		alarms: 	a Heap()
		lastAlarmTime: 	2553548
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


BlockClosure>>cull:cull:
	Receiver: [ :err :rcvr | 
| errCtx "Handle a drawing error" errMorph |
errCtx := thisContext.
[ 
err...etc...
	Arguments and temporary variables: 
		firstArg: 	'MessageNotUnderstood: Float>>isTranslucent'
		secondArg: 	0.0
	Receiver's instance variables: 
		outerContext: 	WorldState>>displayWorldSafely:
		startpc: 	89
		numArgs: 	2


[ :ex | errorHandlerBlock cull: ex description cull: ex receiver ] in BlockClosure>>ifError:
	Receiver: [ aWorld displayWorld ]
	Arguments and temporary variables: 
		errorHandlerBlock: 	[ :err :rcvr | 
| errCtx "Handle a drawing error" errMorph |...etc...
		ex: 	MessageNotUnderstood: Float>>isTranslucent
	Receiver's instance variables: 
		outerContext: 	WorldState>>displayWorldSafely:
		startpc: 	82
		numArgs: 	0


BlockClosure>>cull:
	Receiver: [ :ex | errorHandlerBlock cull: ex description cull: ex receiver ]
	Arguments and temporary variables: 
		anArg: 	MessageNotUnderstood: Float>>isTranslucent
	Receiver's instance variables: 
		outerContext: 	BlockClosure>>ifError:
		startpc: 	40
		numArgs: 	1


[ self exceptionHandlerBlock cull: exception ] in MethodContext(ContextPart)>>handleSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	MessageNotUnderstood: Float>>isTranslucent
		value: 	nil
	Receiver's instance variables: 
		sender: 	BlockClosure>>ifError:
		pc: 	17
		stackp: 	3
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ aWorld displayWorld ]


BlockClosure>>ensure:
	Receiver: [ self exceptionHandlerBlock cull: exception ]
	Arguments and temporary variables: 
		aBlock: 	[ self exceptionHandlerIsActive: true ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MethodContext(ContextPart)>>handleSignal:
		startpc: 	99
		numArgs: 	0


MethodContext(ContextPart)>>handleSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	MessageNotUnderstood: Float>>isTranslucent
		value: 	nil
	Receiver's instance variables: 
		sender: 	BlockClosure>>ifError:
		pc: 	17
		stackp: 	3
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ aWorld displayWorld ]


MessageNotUnderstood(Exception)>>signal
	Receiver: MessageNotUnderstood: Float>>isTranslucent
	Arguments and temporary variables: 

	Receiver's instance variables: 
		messageText: 	nil
		tag: 	nil
		signaler: 	0.0
		signalContext: 	MessageNotUnderstood(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil
		message: 	isTranslucent
		receiver: 	0.0
		reachedDefaultHandler: 	false


Float(Object)>>doesNotUnderstand: #isTranslucent
	Receiver: 0.0
	Arguments and temporary variables: 
		aMessage: 	isTranslucent
		exception: 	MessageNotUnderstood: Float>>isTranslucent
		resumeValue: 	nil
	Receiver's instance variables: 
0.0

AssignmentTemp(Morph)>>areasRemainingToFill:
	Receiver: an AssignmentTemp(525860864)
	Arguments and temporary variables: 
		aRectangle: 	(0@0) corner: (300@200)
	Receiver's instance variables: 
		bounds: 	(10@10) corner: (300@200)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	an Array(a SimpleButtonMorph(633077760) a StringMorph(557580288)'Tem...etc...
		fullBounds: 	(0@0) corner: (300@200)
		color: 	0.0
		extension: 	a MorphExtension (671350784) [other:  (errorOnDraw -> true)]
		borderWidth: 	2
		borderColor: 	Color black


[ :eachIntersect | remnants addAll: (mm areasRemainingToFill: eachIntersect) ] in [ :dirtyRect | 
dirtyRect
	allAreasOutsideList: validList
	do: [ :r | 
		| mm rect i c remnantIntersects remnants rectToFill |
		"Experimental top-down drawing --
			Traverses top to bottom, stopping if the entire area is filled.
			If only a single rectangle remains, then continue with the reduced rectangle."
		rectToFill := r.
		remnants := OrderedCollection with: r.
		i := 1.
		[ remnants isEmpty or: [ i > n ] ]
			whileFalse: [ 
				mm := submorphs at: i.
				((remnantIntersects := remnants select: [ :each | mm fullBounds intersects: each ]) notEmpty and: [ mm visible ])
					ifTrue: [ 
						morphs addLast: mm.
						rects addLast: (Rectangle merging: (remnantIntersects collect: [ :each | mm fullBounds intersect: each ])).
						remnants removeAll: remnantIntersects.
						remnantIntersects do: [ :eachIntersect | remnants addAll: (mm areasRemainingToFill: eachIntersect) ].
						remnants size = 1
							ifTrue: [ rectToFill := remnants first ].
						remnants isEmpty
							ifTrue: [ rectToFill := nil ] ].
				i := i + 1 ].	"Now paint from bottom to top, but using the reduced rectangles."
		rectToFill ifNotNil: [ aWorld drawOn: (c := aCanvas copyClipRect: rectToFill) ].
		[ morphs isEmpty ]
			whileFalse: [ 
				(rect := rects removeLast) == rectToFill
					ifFalse: [ c := aCanvas copyClipRect: (rectToFill := rect) ].
				c fullDrawMorph: morphs removeLast ].
		morphs reset.
		rects reset.
		validList add: r ] ] in drawWorld: aWorld submorphs: submorphs invalidAreasOn: aCanvas
	"Redraw the damaged areas of the given canvas and clear the damage list. Return a collection of the areas that
were redrawn."

	| rectList n morphs rects validList |
	rectList := damageRecorder invalidRectsFullBounds: aWorld viewBox.	"sort by areas to draw largest portions first"
	rectList := rectList asArray sort: [ :r1 :r2 | r1 area > r2 area ].
	damageRecorder reset.
	n := submorphs size.
	morphs := OrderedCollection new: n * 2.
	rects := OrderedCollection new: n * 2.
	validList := OrderedCollection new: n * 2.
	rectList
		do: [ :dirtyRect | 
			dirtyRect
				allAreasOutsideList: validList
				do: [ :r | 
					| mm rect i c remnantIntersects remnants rectToFill |
					"Experimental top-down drawing --
			Traverses top to bottom, stopping if the entire area is filled.
			If only a single rectangle remains, then continue with the reduced rectangle."
					rectToFill := r.
					remnants := OrderedCollection with: r.
					i := 1.
					[ remnants isEmpty or: [ i > n ] ]
						whileFalse: [ 
							mm := submorphs at: i.
							((remnantIntersects := remnants select: [ :each | mm fullBounds intersects: each ]) notEmpty and: [ mm visible ])
								ifTrue: [ 
									morphs addLast: mm.
									rects addLast: (Rectangle merging: (remnantIntersects collect: [ :each | mm fullBounds intersect: each ])).
									remnants removeAll: remnantIntersects.
									remnantIntersects do: [ :eachIntersect | remnants addAll: (mm areasRemainingToFill: eachIntersect) ].
									remnants size = 1
										ifTrue: [ rectToFill := remnants first ].
									remnants isEmpty
										ifTrue: [ rectToFill := nil ] ].
							i := i + 1 ].	"Now paint from bottom to top, but using the reduced rectangles."
					rectToFill ifNotNil: [ aWorld drawOn: (c := aCanvas copyClipRect: rectToFill) ].
					[ morphs isEmpty ]
						whileFalse: [ 
							(rect := rects removeLast) == rectToFill
								ifFalse: [ c := aCanvas copyClipRect: (rectToFill := rect) ].
							c fullDrawMorph: morphs removeLast ].
					morphs reset.
					rects reset.
					validList add: r ] ].
	^ validList in WorldState>>drawWorld:submorphs:invalidAreasOn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		submorphs: 	an OrderedCollection()
		aCanvas: 	a FormCanvas on: DisplayScreen(1208x742x32)
		rectList: 	{(26@491) corner: (464@657). (0@0) corner: (300@200)}
		validList: 	an OrderedCollection((26@491) corner: (464@657))
		dirtyRect: 	(0@0) corner: (300@200)
		r: 	(0@0) corner: (300@200)
		rect: 	nil
		i: 	2
		c: 	nil
		remnantIntersects: 	an OrderedCollection((0@0) corner: (300@200))
		rectToFill: 	(0@0) corner: (300@200)
		n: 	6
		morphs: 	an OrderedCollection(an AssignmentTemp(525860864))
		rects: 	an OrderedCollection((0@0) corner: (300@200))
		mm: 	an AssignmentTemp(525860864)
		remnants: 	an OrderedCollection()
		eachIntersect: 	(0@0) corner: (300@200)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1208@742)
		canvas: 	a FormCanvas on: DisplayScreen(1208x742x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(470024192))(a DropList...etc...
		lastStepTime: 	2553548
		lastStepMessage: 	nil
		lastCycleTime: 	2553548
		alarms: 	a Heap()
		lastAlarmTime: 	2553548
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


OrderedCollection>>do:
	Receiver: an OrderedCollection((0@0) corner: (300@200))
	Arguments and temporary variables: 
		aBlock: 	[ :eachIntersect | remnants addAll: (mm areasRemainingToFill: eachInter...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	{(0@0) corner: (300@200). nil. nil. nil. nil. nil. nil. nil. nil. nil}
		firstIndex: 	1
		lastIndex: 	1


[ :dirtyRect | 
dirtyRect
	allAreasOutsideList: validList
	do: [ :r | 
		| mm rect i c remnantIntersects remnants rectToFill |
		"Experimental top-down drawing --
			Traverses top to bottom, stopping if the entire area is filled.
			If only a single rectangle remains, then continue with the reduced rectangle."
		rectToFill := r.
		remnants := OrderedCollection with: r.
		i := 1.
		[ remnants isEmpty or: [ i > n ] ]
			whileFalse: [ 
				mm := submorphs at: i.
				((remnantIntersects := remnants select: [ :each | mm fullBounds intersects: each ]) notEmpty and: [ mm visible ])
					ifTrue: [ 
						morphs addLast: mm.
						rects addLast: (Rectangle merging: (remnantIntersects collect: [ :each | mm fullBounds intersect: each ])).
						remnants removeAll: remnantIntersects.
						remnantIntersects do: [ :eachIntersect | remnants addAll: (mm areasRemainingToFill: eachIntersect) ].
						remnants size = 1
							ifTrue: [ rectToFill := remnants first ].
						remnants isEmpty
							ifTrue: [ rectToFill := nil ] ].
				i := i + 1 ].	"Now paint from bottom to top, but using the reduced rectangles."
		rectToFill ifNotNil: [ aWorld drawOn: (c := aCanvas copyClipRect: rectToFill) ].
		[ morphs isEmpty ]
			whileFalse: [ 
				(rect := rects removeLast) == rectToFill
					ifFalse: [ c := aCanvas copyClipRect: (rectToFill := rect) ].
				c fullDrawMorph: morphs removeLast ].
		morphs reset.
		rects reset.
		validList add: r ] ] in drawWorld: aWorld submorphs: submorphs invalidAreasOn: aCanvas
	"Redraw the damaged areas of the given canvas and clear the damage list. Return a collection of the areas that
were redrawn."

	| rectList n morphs rects validList |
	rectList := damageRecorder invalidRectsFullBounds: aWorld viewBox.	"sort by areas to draw largest portions first"
	rectList := rectList asArray sort: [ :r1 :r2 | r1 area > r2 area ].
	damageRecorder reset.
	n := submorphs size.
	morphs := OrderedCollection new: n * 2.
	rects := OrderedCollection new: n * 2.
	validList := OrderedCollection new: n * 2.
	rectList
		do: [ :dirtyRect | 
			dirtyRect
				allAreasOutsideList: validList
				do: [ :r | 
					| mm rect i c remnantIntersects remnants rectToFill |
					"Experimental top-down drawing --
			Traverses top to bottom, stopping if the entire area is filled.
			If only a single rectangle remains, then continue with the reduced rectangle."
					rectToFill := r.
					remnants := OrderedCollection with: r.
					i := 1.
					[ remnants isEmpty or: [ i > n ] ]
						whileFalse: [ 
							mm := submorphs at: i.
							((remnantIntersects := remnants select: [ :each | mm fullBounds intersects: each ]) notEmpty and: [ mm visible ])
								ifTrue: [ 
									morphs addLast: mm.
									rects addLast: (Rectangle merging: (remnantIntersects collect: [ :each | mm fullBounds intersect: each ])).
									remnants removeAll: remnantIntersects.
									remnantIntersects do: [ :eachIntersect | remnants addAll: (mm areasRemainingToFill: eachIntersect) ].
									remnants size = 1
										ifTrue: [ rectToFill := remnants first ].
									remnants isEmpty
										ifTrue: [ rectToFill := nil ] ].
							i := i + 1 ].	"Now paint from bottom to top, but using the reduced rectangles."
					rectToFill ifNotNil: [ aWorld drawOn: (c := aCanvas copyClipRect: rectToFill) ].
					[ morphs isEmpty ]
						whileFalse: [ 
							(rect := rects removeLast) == rectToFill
								ifFalse: [ c := aCanvas copyClipRect: (rectToFill := rect) ].
							c fullDrawMorph: morphs removeLast ].
					morphs reset.
					rects reset.
					validList add: r ] ].
	^ validList in WorldState>>drawWorld:submorphs:invalidAreasOn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		submorphs: 	an Array(a TaskbarMorph(984088576) an AssignmentTemp(525860864) a Sy...etc...
		aCanvas: 	a FormCanvas on: DisplayScreen(1208x742x32)
		rectList: 	{(26@491) corner: (464@657). (0@0) corner: (300@200)}
		validList: 	an OrderedCollection((26@491) corner: (464@657))
		dirtyRect: 	(0@0) corner: (300@200)
		r: 	(0@0) corner: (300@200)
		rect: 	nil
		i: 	2
		c: 	nil
		remnantIntersects: 	an OrderedCollection((0@0) corner: (300@200))
		rectToFill: 	(0@0) corner: (300@200)
		mm: 	an AssignmentTemp(525860864)
		remnants: 	an OrderedCollection()
		n: 	6
		morphs: 	an OrderedCollection(an AssignmentTemp(525860864))
		rects: 	an OrderedCollection((0@0) corner: (300@200))
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1208@742)
		canvas: 	a FormCanvas on: DisplayScreen(1208x742x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(470024192))(a DropList...etc...
		lastStepTime: 	2553548
		lastStepMessage: 	nil
		lastCycleTime: 	2553548
		alarms: 	a Heap()
		lastAlarmTime: 	2553548
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


Rectangle>>allAreasOutsideList:startingAt:do:
	Receiver: (0@0) corner: (300@200)
	Arguments and temporary variables: 
		aCollection: 	an OrderedCollection((26@491) corner: (464@657))
		startIndex: 	1
		aBlock: 	[ :dirtyRect | 
dirtyRect
	allAreasOutsideList: validList
	do: [ :r | 
...etc...
		yOrigin: 	nil
		yCorner: 	nil
		aRectangle: 	(26@491) corner: (464@657)
		index: 	2
		rr: 	nil
	Receiver's instance variables: 
		origin: 	(0@0)
		corner: 	(300@200)


Rectangle>>allAreasOutsideList:do:
	Receiver: (0@0) corner: (300@200)
	Arguments and temporary variables: 
		aCollection: 	an OrderedCollection((26@491) corner: (464@657))
		aBlock: 	[ :dirtyRect | 
dirtyRect
	allAreasOutsideList: validList
	do: [ :r | 
...etc...
	Receiver's instance variables: 
		origin: 	(0@0)
		corner: 	(300@200)


drawWorld: aWorld submorphs: submorphs invalidAreasOn: aCanvas
	"Redraw the damaged areas of the given canvas and clear the damage list. Return a collection of the areas that
were redrawn."

	| rectList n morphs rects validList |
	rectList := damageRecorder invalidRectsFullBounds: aWorld viewBox.	"sort by areas to draw largest portions first"
	rectList := rectList asArray sort: [ :r1 :r2 | r1 area > r2 area ].
	damageRecorder reset.
	n := submorphs size.
	morphs := OrderedCollection new: n * 2.
	rects := OrderedCollection new: n * 2.
	validList := OrderedCollection new: n * 2.
	rectList
		do: [ :dirtyRect | 
			dirtyRect
				allAreasOutsideList: validList
				do: [ :r | 
					| mm rect i c remnantIntersects remnants rectToFill |
					"Experimental top-down drawing --
			Traverses top to bottom, stopping if the entire area is filled.
			If only a single rectangle remains, then continue with the reduced rectangle."
					rectToFill := r.
					remnants := OrderedCollection with: r.
					i := 1.
					[ remnants isEmpty or: [ i > n ] ]
						whileFalse: [ 
							mm := submorphs at: i.
							((remnantIntersects := remnants select: [ :each | mm fullBounds intersects: each ]) notEmpty and: [ mm visible ])
								ifTrue: [ 
									morphs addLast: mm.
									rects addLast: (Rectangle merging: (remnantIntersects collect: [ :each | mm fullBounds intersect: each ])).
									remnants removeAll: remnantIntersects.
									remnantIntersects do: [ :eachIntersect | remnants addAll: (mm areasRemainingToFill: eachIntersect) ].
									remnants size = 1
										ifTrue: [ rectToFill := remnants first ].
									remnants isEmpty
										ifTrue: [ rectToFill := nil ] ].
							i := i + 1 ].	"Now paint from bottom to top, but using the reduced rectangles."
					rectToFill ifNotNil: [ aWorld drawOn: (c := aCanvas copyClipRect: rectToFill) ].
					[ morphs isEmpty ]
						whileFalse: [ 
							(rect := rects removeLast) == rectToFill
								ifFalse: [ c := aCanvas copyClipRect: (rectToFill := rect) ].
							c fullDrawMorph: morphs removeLast ].
					morphs reset.
					rects reset.
					validList add: r ] ].
	^ validList in WorldState>>drawWorld:submorphs:invalidAreasOn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		submorphs: 	an Array(a TaskbarMorph(984088576) an AssignmentTemp(525860864) a Sy...etc...
		aCanvas: 	a FormCanvas on: DisplayScreen(1208x742x32)
		rectList: 	{(26@491) corner: (464@657). (0@0) corner: (300@200)}
		validList: 	an OrderedCollection((26@491) corner: (464@657))
		n: 	6
		morphs: 	an OrderedCollection(an AssignmentTemp(525860864))
		rects: 	an OrderedCollection((0@0) corner: (300@200))
		dirtyRect: 	(0@0) corner: (300@200)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1208@742)
		canvas: 	a FormCanvas on: DisplayScreen(1208x742x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(470024192))(a DropList...etc...
		lastStepTime: 	2553548
		lastStepMessage: 	nil
		lastCycleTime: 	2553548
		alarms: 	a Heap()
		lastAlarmTime: 	2553548
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


Array(SequenceableCollection)>>do:
	Receiver: {(26@491) corner: (464@657). (0@0) corner: (300@200)}
	Arguments and temporary variables: 
		aBlock: 	drawWorld: aWorld submorphs: submorphs invalidAreasOn: aCanvas
	"Redraw...etc...
		index: 	2
	Receiver's instance variables: 
{(26@491) corner: (464@657). (0@0) corner: (300@200)}

WorldState>>drawWorld:submorphs:invalidAreasOn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		n: 	6
		morphs: 	an OrderedCollection(an AssignmentTemp(525860864))
		rects: 	an OrderedCollection((0@0) corner: (300@200))
		aWorld: 	a WorldMorph(511705088) [world]
		submorphs: 	an Array(a TaskbarMorph(984088576) an AssignmentTemp(525860864) a Sy...etc...
		aCanvas: 	a FormCanvas on: DisplayScreen(1208x742x32)
		rectList: 	{(26@491) corner: (464@657). (0@0) corner: (300@200)}
		validList: 	an OrderedCollection((26@491) corner: (464@657))
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1208@742)
		canvas: 	a FormCanvas on: DisplayScreen(1208x742x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(470024192))(a DropList...etc...
		lastStepTime: 	2553548
		lastStepMessage: 	nil
		lastCycleTime: 	2553548
		alarms: 	a Heap()
		lastAlarmTime: 	2553548
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


[ 
| worldDamageRects handDamageRects |
worldDamageRects := self drawWorld: aWorld submorphs: submorphs invalidAreasOn: canvas.	"repair world's damage on canvas"	"self handsDo:[:h| h noticeDamageRects: worldDamageRects]."
handsToDraw := self selectHandsToDrawForDamage: worldDamageRects.
handDamageRects := handsToDraw collect: [ :h | h savePatchFrom: canvas ].
allDamage := worldDamageRects , handDamageRects.
handsToDraw reverseDo: [ :h | canvas fullDrawMorph: h ]	"draw hands onto world canvas" ] in WorldState>>displayWorld:submorphs:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		submorphs: 	an Array(a TaskbarMorph(984088576) an AssignmentTemp(525860864) a Sy...etc...
		deferredUpdateMode: 	true
		allDamage: 	nil
		handsToDraw: 	nil
		worldDamageRects: 	nil
		handDamageRects: 	nil
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1208@742)
		canvas: 	a FormCanvas on: DisplayScreen(1208x742x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(470024192))(a DropList...etc...
		lastStepTime: 	2553548
		lastStepMessage: 	nil
		lastCycleTime: 	2553548
		alarms: 	a Heap()
		lastAlarmTime: 	2553548
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


FormCanvas>>roundCornersOf:in:during:
	Receiver: a FormCanvas on: DisplayScreen(1208x742x32)
	Arguments and temporary variables: 
		aMorph: 	a WorldMorph(511705088) [world]
		bounds: 	(0@0) corner: (1208@742)
		aBlock: 	[ 
| worldDamageRects handDamageRects |
worldDamageRects := self drawWo...etc...
	Receiver's instance variables: 
		origin: 	(0@0)
		clipRect: 	(0@0) corner: (1208@742)
		form: 	DisplayScreen(1208x742x32)
		port: 	a GrafPort


FormCanvas(Canvas)>>roundCornersOf:during:
	Receiver: a FormCanvas on: DisplayScreen(1208x742x32)
	Arguments and temporary variables: 
		aMorph: 	a WorldMorph(511705088) [world]
		aBlock: 	[ 
| worldDamageRects handDamageRects |
worldDamageRects := self drawWo...etc...
	Receiver's instance variables: 
		origin: 	(0@0)
		clipRect: 	(0@0) corner: (1208@742)
		form: 	DisplayScreen(1208x742x32)
		port: 	a GrafPort


WorldState>>displayWorld:submorphs:
	Receiver: a WorldState
	Arguments and temporary variables: 
		allDamage: 	nil
		handsToDraw: 	nil
		aWorld: 	a WorldMorph(511705088) [world]
		submorphs: 	an Array(a TaskbarMorph(984088576) an AssignmentTemp(525860864) a Sy...etc...
		deferredUpdateMode: 	true
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1208@742)
		canvas: 	a FormCanvas on: DisplayScreen(1208x742x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(470024192))(a DropList...etc...
		lastStepTime: 	2553548
		lastStepMessage: 	nil
		lastCycleTime: 	2553548
		alarms: 	a Heap()
		lastAlarmTime: 	2553548
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>displayWorld
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1208@742)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an AssignmentTemp(525860864) a Sy...etc...
		fullBounds: 	(0@0) corner: (1208@742)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


[ aWorld displayWorld ] in WorldState>>displayWorldSafely:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1208@742)
		canvas: 	a FormCanvas on: DisplayScreen(1208x742x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(470024192))(a DropList...etc...
		lastStepTime: 	2553548
		lastStepMessage: 	nil
		lastCycleTime: 	2553548
		alarms: 	a Heap()
		lastAlarmTime: 	2553548
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


BlockClosure>>on:do:
	Receiver: [ aWorld displayWorld ]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | errorHandlerBlock cull: ex description cull: ex receiver...etc...
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	WorldState>>displayWorldSafely:
		startpc: 	82
		numArgs: 	0


BlockClosure>>ifError:
	Receiver: [ aWorld displayWorld ]
	Arguments and temporary variables: 
		errorHandlerBlock: 	[ :err :rcvr | 
| errCtx "Handle a drawing error" errMorph |...etc...
	Receiver's instance variables: 
		outerContext: 	WorldState>>displayWorldSafely:
		startpc: 	82
		numArgs: 	0


WorldState>>displayWorldSafely:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1208@742)
		canvas: 	a FormCanvas on: DisplayScreen(1208x742x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(470024192))(a DropList...etc...
		lastStepTime: 	2553548
		lastStepMessage: 	nil
		lastCycleTime: 	2553548
		alarms: 	a Heap()
		lastAlarmTime: 	2553548
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1208@742)
		canvas: 	a FormCanvas on: DisplayScreen(1208x742x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(470024192))(a DropList...etc...
		lastStepTime: 	2553548
		lastStepMessage: 	nil
		lastCycleTime: 	2553548
		alarms: 	a Heap()
		lastAlarmTime: 	2553548
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1208@742)
		canvas: 	a FormCanvas on: DisplayScreen(1208x742x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(470024192))(a DropList...etc...
		lastStepTime: 	2553548
		lastStepMessage: 	nil
		lastCycleTime: 	2553548
		alarms: 	a Heap()
		lastAlarmTime: 	2553548
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1208@742)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an AssignmentTemp(525860864) a Sy...etc...
		fullBounds: 	(0@0) corner: (1208@742)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
World doOneCycle.
Processor yield.
false ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
Float(Object)>>error:
[ :err :rcvr | 
| errCtx "Handle a drawing error" errMorph |
errCtx := thisContext.
[ 
errCtx := errCtx sender.	"Search the sender chain to find the morph causing the problem"
[ errCtx notNil and: [ errCtx receiver isMorph not ] ] whileTrue: [ errCtx := errCtx sender ].	"If we're at the root of the context chain then we have a fatal drawing problem"
errCtx ifNil: [ ^ self handleFatalDrawingError: err ].
errMorph := errCtx receiver.	"If the morph causing the problem has already the #drawError flag set,
			then search for the next morph above in the caller chain."
errMorph hasProperty: #errorOnDraw ] whileTrue.
errMorph setProperty: #errorOnDraw toValue: true.	"Install the old error handler, so we can re-raise the error"
rcvr error: err ] in WorldState>>displayWorldSafely:
BlockClosure>>cull:cull:
[ :ex | errorHandlerBlock cull: ex description cull: ex receiver ] in BlockClosure>>ifError:
BlockClosure>>cull:
[ self exceptionHandlerBlock cull: exception ] in MethodContext(ContextPart)>>handleSignal:
BlockClosure>>ensure:
MethodContext(ContextPart)>>handleSignal:
MessageNotUnderstood(Exception)>>signal
Float(Object)>>doesNotUnderstand: #isTranslucent
AssignmentTemp(Morph)>>areasRemainingToFill:
[ :eachIntersect | remnants addAll: (mm areasRemainingToFill: eachIntersect) ] in [ :dirtyRect | 
dirtyRect
	allAreasOutsideList: validList
	do: [ :r | 
		| mm rect i c remnantIntersects remnants rectToFill |
		"Experimental top-down drawing --
			Traverses top to bottom, stopping if the entire area is filled.
			If only a single rectangle remains, then continue with the reduced rectangle."
		rectToFill := r.
		remnants := OrderedCollection with: r.
		i := 1.
		[ remnants isEmpty or: [ i > n ] ]
			whileFalse: [ 
				mm := submorphs at: i.
				((remnantIntersects := remnants select: [ :each | mm fullBounds intersects: each ]) notEmpty and: [ mm visible ])
					ifTrue: [ 
						morphs addLast: mm.
						rects addLast: (Rectangle merging: (remnantIntersects collect: [ :each | mm fullBounds intersect: each ])).
						remnants removeAll: remnantIntersects.
						remnantIntersects do: [ :eachIntersect | remnants addAll: (mm areasRemainingToFill: eachIntersect) ].
						remnants size = 1
							ifTrue: [ rectToFill := remnants first ].
						remnants isEmpty
							ifTrue: [ rectToFill := nil ] ].
				i := i + 1 ].	"Now paint from bottom to top, but using the reduced rectangles."
		rectToFill ifNotNil: [ aWorld drawOn: (c := aCanvas copyClipRect: rectToFill) ].
		[ morphs isEmpty ]
			whileFalse: [ 
				(rect := rects removeLast) == rectToFill
					ifFalse: [ c := aCanvas copyClipRect: (rectToFill := rect) ].
				c fullDrawMorph: morphs removeLast ].
		morphs reset.
		rects reset.
		validList add: r ] ] in drawWorld: aWorld submorphs: submorphs invalidAreasOn: aCanvas
	"Redraw the damaged areas of the given canvas and clear the damage list. Return a collection of the areas that
were redrawn."

	| rectList n morphs rects validList |
	rectList := damageRecorder invalidRectsFullBounds: aWorld viewBox.	"sort by areas to draw largest portions first"
	rectList := rectList asArray sort: [ :r1 :r2 | r1 area > r2 area ].
	damageRecorder reset.
	n := submorphs size.
	morphs := OrderedCollection new: n * 2.
	rects := OrderedCollection new: n * 2.
	validList := OrderedCollection new: n * 2.
	rectList
		do: [ :dirtyRect | 
			dirtyRect
				allAreasOutsideList: validList
				do: [ :r | 
					| mm rect i c remnantIntersects remnants rectToFill |
					"Experimental top-down drawing --
			Traverses top to bottom, stopping if the entire area is filled.
			If only a single rectangle remains, then continue with the reduced rectangle."
					rectToFill := r.
					remnants := OrderedCollection with: r.
					i := 1.
					[ remnants isEmpty or: [ i > n ] ]
						whileFalse: [ 
							mm := submorphs at: i.
							((remnantIntersects := remnants select: [ :each | mm fullBounds intersects: each ]) notEmpty and: [ mm visible ])
								ifTrue: [ 
									morphs addLast: mm.
									rects addLast: (Rectangle merging: (remnantIntersects collect: [ :each | mm fullBounds intersect: each ])).
									remnants removeAll: remnantIntersects.
									remnantIntersects do: [ :eachIntersect | remnants addAll: (mm areasRemainingToFill: eachIntersect) ].
									remnants size = 1
										ifTrue: [ rectToFill := remnants first ].
									remnants isEmpty
										ifTrue: [ rectToFill := nil ] ].
							i := i + 1 ].	"Now paint from bottom to top, but using the reduced rectangles."
					rectToFill ifNotNil: [ aWorld drawOn: (c := aCanvas copyClipRect: rectToFill) ].
					[ morphs isEmpty ]
						whileFalse: [ 
							(rect := rects removeLast) == rectToFill
								ifFalse: [ c := aCanvas copyClipRect: (rectToFill := rect) ].
							c fullDrawMorph: morphs removeLast ].
					morphs reset.
					rects reset.
					validList add: r ] ].
	^ validList in WorldState>>drawWorld:submorphs:invalidAreasOn:
OrderedCollection>>do:
[ :dirtyRect | 
dirtyRect
	allAreasOutsideList: validList
	do: [ :r | 
		| mm rect i c remnantIntersects remnants rectToFill |
		"Experimental top-down drawing --
			Traverses top to bottom, stopping if the entire area is filled.
			If only a single rectangle remains, then continue with the reduced rectangle."
		rectToFill := r.
		remnants := OrderedCollection with: r.
		i := 1.
		[ remnants isEmpty or: [ i > n ] ]
			whileFalse: [ 
				mm := submorphs at: i.
				((remnantIntersects := remnants select: [ :each | mm fullBounds intersects: each ]) notEmpty and: [ mm visible ])
					ifTrue: [ 
						morphs addLast: mm.
						rects addLast: (Rectangle merging: (remnantIntersects collect: [ :each | mm fullBounds intersect: each ])).
						remnants removeAll: remnantIntersects.
						remnantIntersects do: [ :eachIntersect | remnants addAll: (mm areasRemainingToFill: eachIntersect) ].
						remnants size = 1
							ifTrue: [ rectToFill := remnants first ].
						remnants isEmpty
							ifTrue: [ rectToFill := nil ] ].
				i := i + 1 ].	"Now paint from bottom to top, but using the reduced rectangles."
		rectToFill ifNotNil: [ aWorld drawOn: (c := aCanvas copyClipRect: rectToFill) ].
		[ morphs isEmpty ]
			whileFalse: [ 
				(rect := rects removeLast) == rectToFill
					ifFalse: [ c := aCanvas copyClipRect: (rectToFill := rect) ].
				c fullDrawMorph: morphs removeLast ].
		morphs reset.
		rects reset.
		validList add: r ] ] in drawWorld: aWorld submorphs: submorphs invalidAreasOn: aCanvas
	"Redraw the damaged areas of the given canvas and clear the damage list. Return a collection of the areas that
were redrawn."

	| rectList n morphs rects validList |
	rectList := damageRecorder invalidRectsFullBounds: aWorld viewBox.	"sort by areas to draw largest portions first"
	rectList := rectList asArray sort: [ :r1 :r2 | r1 area > r2 area ].
	damageRecorder reset.
	n := submorphs size.
	morphs := OrderedCollection new: n * 2.
	rects := OrderedCollection new: n * 2.
	validList := OrderedCollection new: n * 2.
	rectList
		do: [ :dirtyRect | 
			dirtyRect
				allAreasOutsideList: validList
				do: [ :r | 
					| mm rect i c remnantIntersects remnants rectToFill |
					"Experimental top-down drawing --
			Traverses top to bottom, stopping if the entire area is filled.
			If only a single rectangle remains, then continue with the reduced rectangle."
					rectToFill := r.
					remnants := OrderedCollection with: r.
					i := 1.
					[ remnants isEmpty or: [ i > n ] ]
						whileFalse: [ 
							mm := submorphs at: i.
							((remnantIntersects := remnants select: [ :each | mm fullBounds intersects: each ]) notEmpty and: [ mm visible ])
								ifTrue: [ 
									morphs addLast: mm.
									rects addLast: (Rectangle merging: (remnantIntersects collect: [ :each | mm fullBounds intersect: each ])).
									remnants removeAll: remnantIntersects.
									remnantIntersects do: [ :eachIntersect | remnants addAll: (mm areasRemainingToFill: eachIntersect) ].
									remnants size = 1
										ifTrue: [ rectToFill := remnants first ].
									remnants isEmpty
										ifTrue: [ rectToFill := nil ] ].
							i := i + 1 ].	"Now paint from bottom to top, but using the reduced rectangles."
					rectToFill ifNotNil: [ aWorld drawOn: (c := aCanvas copyClipRect: rectToFill) ].
					[ morphs isEmpty ]
						whileFalse: [ 
							(rect := rects removeLast) == rectToFill
								ifFalse: [ c := aCanvas copyClipRect: (rectToFill := rect) ].
							c fullDrawMorph: morphs removeLast ].
					morphs reset.
					rects reset.
					validList add: r ] ].
	^ validList in WorldState>>drawWorld:submorphs:invalidAreasOn:
Rectangle>>allAreasOutsideList:startingAt:do:
Rectangle>>allAreasOutsideList:do:
drawWorld: aWorld submorphs: submorphs invalidAreasOn: aCanvas
	"Redraw the damaged areas of the given canvas and clear the damage list. Return a collection of the areas that
were redrawn."

	| rectList n morphs rects validList |
	rectList := damageRecorder invalidRectsFullBounds: aWorld viewBox.	"sort by areas to draw largest portions first"
	rectList := rectList asArray sort: [ :r1 :r2 | r1 area > r2 area ].
	damageRecorder reset.
	n := submorphs size.
	morphs := OrderedCollection new: n * 2.
	rects := OrderedCollection new: n * 2.
	validList := OrderedCollection new: n * 2.
	rectList
		do: [ :dirtyRect | 
			dirtyRect
				allAreasOutsideList: validList
				do: [ :r | 
					| mm rect i c remnantIntersects remnants rectToFill |
					"Experimental top-down drawing --
			Traverses top to bottom, stopping if the entire area is filled.
			If only a single rectangle remains, then continue with the reduced rectangle."
					rectToFill := r.
					remnants := OrderedCollection with: r.
					i := 1.
					[ remnants isEmpty or: [ i > n ] ]
						whileFalse: [ 
							mm := submorphs at: i.
							((remnantIntersects := remnants select: [ :each | mm fullBounds intersects: each ]) notEmpty and: [ mm visible ])
								ifTrue: [ 
									morphs addLast: mm.
									rects addLast: (Rectangle merging: (remnantIntersects collect: [ :each | mm fullBounds intersect: each ])).
									remnants removeAll: remnantIntersects.
									remnantIntersects do: [ :eachIntersect | remnants addAll: (mm areasRemainingToFill: eachIntersect) ].
									remnants size = 1
										ifTrue: [ rectToFill := remnants first ].
									remnants isEmpty
										ifTrue: [ rectToFill := nil ] ].
							i := i + 1 ].	"Now paint from bottom to top, but using the reduced rectangles."
					rectToFill ifNotNil: [ aWorld drawOn: (c := aCanvas copyClipRect: rectToFill) ].
					[ morphs isEmpty ]
						whileFalse: [ 
							(rect := rects removeLast) == rectToFill
								ifFalse: [ c := aCanvas copyClipRect: (rectToFill := rect) ].
							c fullDrawMorph: morphs removeLast ].
					morphs reset.
					rects reset.
					validList add: r ] ].
	^ validList in WorldState>>drawWorld:submorphs:invalidAreasOn:
Array(SequenceableCollection)>>do:
WorldState>>drawWorld:submorphs:invalidAreasOn:
[ 
| worldDamageRects handDamageRects |
worldDamageRects := self drawWorld: aWorld submorphs: submorphs invalidAreasOn: canvas.	"repair world's damage on canvas"	"self handsDo:[:h| h noticeDamageRects: worldDamageRects]."
handsToDraw := self selectHandsToDrawForDamage: worldDamageRects.
handDamageRects := handsToDraw collect: [ :h | h savePatchFrom: canvas ].
allDamage := worldDamageRects , handDamageRects.
handsToDraw reverseDo: [ :h | canvas fullDrawMorph: h ]	"draw hands onto world canvas" ] in WorldState>>displayWorld:submorphs:
FormCanvas>>roundCornersOf:in:during:
FormCanvas(Canvas)>>roundCornersOf:during:
WorldState>>displayWorld:submorphs:
WorldMorph>>displayWorld
[ aWorld displayWorld ] in WorldState>>displayWorldSafely:
BlockClosure>>on:do:
BlockClosure>>ifError:
WorldState>>displayWorldSafely:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Error: MessageNotUnderstood: Float>>isTranslucent
17 October 2014 2:37:40.473357 pm

VM: Mac OS - intel - 1090 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30858]

Float(Object)>>error:
	Receiver: 0.0
	Arguments and temporary variables: 
		aString: 	'MessageNotUnderstood: Float>>isTranslucent'
	Receiver's instance variables: 
0.0

[ :err :rcvr | 
| errCtx "Handle a drawing error" errMorph |
errCtx := thisContext.
[ 
errCtx := errCtx sender.	"Search the sender chain to find the morph causing the problem"
[ errCtx notNil and: [ errCtx receiver isMorph not ] ] whileTrue: [ errCtx := errCtx sender ].	"If we're at the root of the context chain then we have a fatal drawing problem"
errCtx ifNil: [ ^ self handleFatalDrawingError: err ].
errMorph := errCtx receiver.	"If the morph causing the problem has already the #drawError flag set,
			then search for the next morph above in the caller chain."
errMorph hasProperty: #errorOnDraw ] whileTrue.
errMorph setProperty: #errorOnDraw toValue: true.	"Install the old error handler, so we can re-raise the error"
rcvr error: err ] in WorldState>>displayWorldSafely:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		err: 	'MessageNotUnderstood: Float>>isTranslucent'
		rcvr: 	0.0
		errCtx: 	WorldMorph>>displayWorld
		errMorph: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1208@742)
		canvas: 	a FormCanvas on: DisplayScreen(1208x742x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(13893632))(a SearchMorph...etc...
		lastStepTime: 	2553824
		lastStepMessage: 	nil
		lastCycleTime: 	2553817
		alarms: 	a Heap()
		lastAlarmTime: 	2553824
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


BlockClosure>>cull:cull:
	Receiver: [ :err :rcvr | 
| errCtx "Handle a drawing error" errMorph |
errCtx := thisContext.
[ 
err...etc...
	Arguments and temporary variables: 
		firstArg: 	'MessageNotUnderstood: Float>>isTranslucent'
		secondArg: 	0.0
	Receiver's instance variables: 
		outerContext: 	WorldState>>displayWorldSafely:
		startpc: 	89
		numArgs: 	2


[ :ex | errorHandlerBlock cull: ex description cull: ex receiver ] in BlockClosure>>ifError:
	Receiver: [ aWorld displayWorld ]
	Arguments and temporary variables: 
		errorHandlerBlock: 	[ :err :rcvr | 
| errCtx "Handle a drawing error" errMorph |...etc...
		ex: 	MessageNotUnderstood: Float>>isTranslucent
	Receiver's instance variables: 
		outerContext: 	WorldState>>displayWorldSafely:
		startpc: 	82
		numArgs: 	0


BlockClosure>>cull:
	Receiver: [ :ex | errorHandlerBlock cull: ex description cull: ex receiver ]
	Arguments and temporary variables: 
		anArg: 	MessageNotUnderstood: Float>>isTranslucent
	Receiver's instance variables: 
		outerContext: 	BlockClosure>>ifError:
		startpc: 	40
		numArgs: 	1


[ self exceptionHandlerBlock cull: exception ] in MethodContext(ContextPart)>>handleSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	MessageNotUnderstood: Float>>isTranslucent
		value: 	nil
	Receiver's instance variables: 
		sender: 	BlockClosure>>ifError:
		pc: 	17
		stackp: 	3
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ aWorld displayWorld ]


BlockClosure>>ensure:
	Receiver: [ self exceptionHandlerBlock cull: exception ]
	Arguments and temporary variables: 
		aBlock: 	[ self exceptionHandlerIsActive: true ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MethodContext(ContextPart)>>handleSignal:
		startpc: 	99
		numArgs: 	0


MethodContext(ContextPart)>>handleSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	MessageNotUnderstood: Float>>isTranslucent
		value: 	nil
	Receiver's instance variables: 
		sender: 	BlockClosure>>ifError:
		pc: 	17
		stackp: 	3
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ aWorld displayWorld ]


MessageNotUnderstood(Exception)>>signal
	Receiver: MessageNotUnderstood: Float>>isTranslucent
	Arguments and temporary variables: 

	Receiver's instance variables: 
		messageText: 	nil
		tag: 	nil
		signaler: 	0.0
		signalContext: 	MessageNotUnderstood(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil
		message: 	isTranslucent
		receiver: 	0.0
		reachedDefaultHandler: 	false


Float(Object)>>doesNotUnderstand: #isTranslucent
	Receiver: 0.0
	Arguments and temporary variables: 
		aMessage: 	isTranslucent
		exception: 	MessageNotUnderstood: Float>>isTranslucent
		resumeValue: 	nil
	Receiver's instance variables: 
0.0

AssignmentTemp(Morph)>>areasRemainingToFill:
	Receiver: an AssignmentTemp(525860864)
	Arguments and temporary variables: 
		aRectangle: 	(0@0) corner: (255@24)
	Receiver's instance variables: 
		bounds: 	(10@10) corner: (300@200)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	an Array(a SimpleButtonMorph(633077760) a StringMorph(557580288)'Tem...etc...
		fullBounds: 	(0@0) corner: (300@200)
		color: 	0.0
		extension: 	a MorphExtension (671350784) [other:  (errorOnDraw -> true)]
		borderWidth: 	2
		borderColor: 	Color black


[ :eachIntersect | remnants addAll: (mm areasRemainingToFill: eachIntersect) ] in [ :dirtyRect | 
dirtyRect
	allAreasOutsideList: validList
	do: [ :r | 
		| mm rect i c remnantIntersects remnants rectToFill |
		"Experimental top-down drawing --
			Traverses top to bottom, stopping if the entire area is filled.
			If only a single rectangle remains, then continue with the reduced rectangle."
		rectToFill := r.
		remnants := OrderedCollection with: r.
		i := 1.
		[ remnants isEmpty or: [ i > n ] ]
			whileFalse: [ 
				mm := submorphs at: i.
				((remnantIntersects := remnants select: [ :each | mm fullBounds intersects: each ]) notEmpty and: [ mm visible ])
					ifTrue: [ 
						morphs addLast: mm.
						rects addLast: (Rectangle merging: (remnantIntersects collect: [ :each | mm fullBounds intersect: each ])).
						remnants removeAll: remnantIntersects.
						remnantIntersects do: [ :eachIntersect | remnants addAll: (mm areasRemainingToFill: eachIntersect) ].
						remnants size = 1
							ifTrue: [ rectToFill := remnants first ].
						remnants isEmpty
							ifTrue: [ rectToFill := nil ] ].
				i := i + 1 ].	"Now paint from bottom to top, but using the reduced rectangles."
		rectToFill ifNotNil: [ aWorld drawOn: (c := aCanvas copyClipRect: rectToFill) ].
		[ morphs isEmpty ]
			whileFalse: [ 
				(rect := rects removeLast) == rectToFill
					ifFalse: [ c := aCanvas copyClipRect: (rectToFill := rect) ].
				c fullDrawMorph: morphs removeLast ].
		morphs reset.
		rects reset.
		validList add: r ] ] in drawWorld: aWorld submorphs: submorphs invalidAreasOn: aCanvas
	"Redraw the damaged areas of the given canvas and clear the damage list. Return a collection of the areas that
were redrawn."

	| rectList n morphs rects validList |
	rectList := damageRecorder invalidRectsFullBounds: aWorld viewBox.	"sort by areas to draw largest portions first"
	rectList := rectList asArray sort: [ :r1 :r2 | r1 area > r2 area ].
	damageRecorder reset.
	n := submorphs size.
	morphs := OrderedCollection new: n * 2.
	rects := OrderedCollection new: n * 2.
	validList := OrderedCollection new: n * 2.
	rectList
		do: [ :dirtyRect | 
			dirtyRect
				allAreasOutsideList: validList
				do: [ :r | 
					| mm rect i c remnantIntersects remnants rectToFill |
					"Experimental top-down drawing --
			Traverses top to bottom, stopping if the entire area is filled.
			If only a single rectangle remains, then continue with the reduced rectangle."
					rectToFill := r.
					remnants := OrderedCollection with: r.
					i := 1.
					[ remnants isEmpty or: [ i > n ] ]
						whileFalse: [ 
							mm := submorphs at: i.
							((remnantIntersects := remnants select: [ :each | mm fullBounds intersects: each ]) notEmpty and: [ mm visible ])
								ifTrue: [ 
									morphs addLast: mm.
									rects addLast: (Rectangle merging: (remnantIntersects collect: [ :each | mm fullBounds intersect: each ])).
									remnants removeAll: remnantIntersects.
									remnantIntersects do: [ :eachIntersect | remnants addAll: (mm areasRemainingToFill: eachIntersect) ].
									remnants size = 1
										ifTrue: [ rectToFill := remnants first ].
									remnants isEmpty
										ifTrue: [ rectToFill := nil ] ].
							i := i + 1 ].	"Now paint from bottom to top, but using the reduced rectangles."
					rectToFill ifNotNil: [ aWorld drawOn: (c := aCanvas copyClipRect: rectToFill) ].
					[ morphs isEmpty ]
						whileFalse: [ 
							(rect := rects removeLast) == rectToFill
								ifFalse: [ c := aCanvas copyClipRect: (rectToFill := rect) ].
							c fullDrawMorph: morphs removeLast ].
					morphs reset.
					rects reset.
					validList add: r ] ].
	^ validList in WorldState>>drawWorld:submorphs:invalidAreasOn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		submorphs: 	an OrderedCollection()
		aCanvas: 	a FormCanvas on: DisplayScreen(1208x742x32)
		rectList: 	{(47@541) corner: (723@634). (0@714) corner: (1208@742). (0@0) corner...etc...
		validList: 	an OrderedCollection((47@541) corner: (723@634) (0@714) corner: (120...etc...
		dirtyRect: 	(0@0) corner: (255@24)
		r: 	(0@0) corner: (255@24)
		rect: 	nil
		i: 	3
		c: 	nil
		remnantIntersects: 	an OrderedCollection((0@0) corner: (255@24))
		rectToFill: 	(0@0) corner: (255@24)
		n: 	7
		morphs: 	an OrderedCollection(an AssignmentTemp(525860864))
		rects: 	an OrderedCollection((0@0) corner: (255@24))
		mm: 	an AssignmentTemp(525860864)
		remnants: 	an OrderedCollection()
		eachIntersect: 	(0@0) corner: (255@24)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1208@742)
		canvas: 	a FormCanvas on: DisplayScreen(1208x742x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(13893632))(a SearchMorph...etc...
		lastStepTime: 	2553824
		lastStepMessage: 	nil
		lastCycleTime: 	2553817
		alarms: 	a Heap()
		lastAlarmTime: 	2553824
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


OrderedCollection>>do:
	Receiver: an OrderedCollection((0@0) corner: (255@24))
	Arguments and temporary variables: 
		aBlock: 	[ :eachIntersect | remnants addAll: (mm areasRemainingToFill: eachInter...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	{(0@0) corner: (255@24). nil. nil. nil. nil. nil. nil. nil. nil. nil}
		firstIndex: 	1
		lastIndex: 	1


[ :dirtyRect | 
dirtyRect
	allAreasOutsideList: validList
	do: [ :r | 
		| mm rect i c remnantIntersects remnants rectToFill |
		"Experimental top-down drawing --
			Traverses top to bottom, stopping if the entire area is filled.
			If only a single rectangle remains, then continue with the reduced rectangle."
		rectToFill := r.
		remnants := OrderedCollection with: r.
		i := 1.
		[ remnants isEmpty or: [ i > n ] ]
			whileFalse: [ 
				mm := submorphs at: i.
				((remnantIntersects := remnants select: [ :each | mm fullBounds intersects: each ]) notEmpty and: [ mm visible ])
					ifTrue: [ 
						morphs addLast: mm.
						rects addLast: (Rectangle merging: (remnantIntersects collect: [ :each | mm fullBounds intersect: each ])).
						remnants removeAll: remnantIntersects.
						remnantIntersects do: [ :eachIntersect | remnants addAll: (mm areasRemainingToFill: eachIntersect) ].
						remnants size = 1
							ifTrue: [ rectToFill := remnants first ].
						remnants isEmpty
							ifTrue: [ rectToFill := nil ] ].
				i := i + 1 ].	"Now paint from bottom to top, but using the reduced rectangles."
		rectToFill ifNotNil: [ aWorld drawOn: (c := aCanvas copyClipRect: rectToFill) ].
		[ morphs isEmpty ]
			whileFalse: [ 
				(rect := rects removeLast) == rectToFill
					ifFalse: [ c := aCanvas copyClipRect: (rectToFill := rect) ].
				c fullDrawMorph: morphs removeLast ].
		morphs reset.
		rects reset.
		validList add: r ] ] in drawWorld: aWorld submorphs: submorphs invalidAreasOn: aCanvas
	"Redraw the damaged areas of the given canvas and clear the damage list. Return a collection of the areas that
were redrawn."

	| rectList n morphs rects validList |
	rectList := damageRecorder invalidRectsFullBounds: aWorld viewBox.	"sort by areas to draw largest portions first"
	rectList := rectList asArray sort: [ :r1 :r2 | r1 area > r2 area ].
	damageRecorder reset.
	n := submorphs size.
	morphs := OrderedCollection new: n * 2.
	rects := OrderedCollection new: n * 2.
	validList := OrderedCollection new: n * 2.
	rectList
		do: [ :dirtyRect | 
			dirtyRect
				allAreasOutsideList: validList
				do: [ :r | 
					| mm rect i c remnantIntersects remnants rectToFill |
					"Experimental top-down drawing --
			Traverses top to bottom, stopping if the entire area is filled.
			If only a single rectangle remains, then continue with the reduced rectangle."
					rectToFill := r.
					remnants := OrderedCollection with: r.
					i := 1.
					[ remnants isEmpty or: [ i > n ] ]
						whileFalse: [ 
							mm := submorphs at: i.
							((remnantIntersects := remnants select: [ :each | mm fullBounds intersects: each ]) notEmpty and: [ mm visible ])
								ifTrue: [ 
									morphs addLast: mm.
									rects addLast: (Rectangle merging: (remnantIntersects collect: [ :each | mm fullBounds intersect: each ])).
									remnants removeAll: remnantIntersects.
									remnantIntersects do: [ :eachIntersect | remnants addAll: (mm areasRemainingToFill: eachIntersect) ].
									remnants size = 1
										ifTrue: [ rectToFill := remnants first ].
									remnants isEmpty
										ifTrue: [ rectToFill := nil ] ].
							i := i + 1 ].	"Now paint from bottom to top, but using the reduced rectangles."
					rectToFill ifNotNil: [ aWorld drawOn: (c := aCanvas copyClipRect: rectToFill) ].
					[ morphs isEmpty ]
						whileFalse: [ 
							(rect := rects removeLast) == rectToFill
								ifFalse: [ c := aCanvas copyClipRect: (rectToFill := rect) ].
							c fullDrawMorph: morphs removeLast ].
					morphs reset.
					rects reset.
					validList add: r ] ].
	^ validList in WorldState>>drawWorld:submorphs:invalidAreasOn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(22020096) an Assignm...etc...
		aCanvas: 	a FormCanvas on: DisplayScreen(1208x742x32)
		rectList: 	{(47@541) corner: (723@634). (0@714) corner: (1208@742). (0@0) corner...etc...
		validList: 	an OrderedCollection((47@541) corner: (723@634) (0@714) corner: (120...etc...
		dirtyRect: 	(0@0) corner: (255@24)
		r: 	(0@0) corner: (255@24)
		rect: 	nil
		i: 	3
		c: 	nil
		remnantIntersects: 	an OrderedCollection((0@0) corner: (255@24))
		rectToFill: 	(0@0) corner: (255@24)
		mm: 	an AssignmentTemp(525860864)
		remnants: 	an OrderedCollection()
		n: 	7
		morphs: 	an OrderedCollection(an AssignmentTemp(525860864))
		rects: 	an OrderedCollection((0@0) corner: (255@24))
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1208@742)
		canvas: 	a FormCanvas on: DisplayScreen(1208x742x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(13893632))(a SearchMorph...etc...
		lastStepTime: 	2553824
		lastStepMessage: 	nil
		lastCycleTime: 	2553817
		alarms: 	a Heap()
		lastAlarmTime: 	2553824
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


Rectangle>>allAreasOutsideList:startingAt:do:
	Receiver: (0@0) corner: (255@24)
	Arguments and temporary variables: 
		aCollection: 	an OrderedCollection((47@541) corner: (723@634) (0@714) corner: (1...etc...
		startIndex: 	1
		aBlock: 	[ :dirtyRect | 
dirtyRect
	allAreasOutsideList: validList
	do: [ :r | 
...etc...
		yOrigin: 	nil
		yCorner: 	nil
		aRectangle: 	(0@714) corner: (1208@742)
		index: 	3
		rr: 	nil
	Receiver's instance variables: 
		origin: 	(0@0)
		corner: 	(255@24)


Rectangle>>allAreasOutsideList:do:
	Receiver: (0@0) corner: (255@24)
	Arguments and temporary variables: 
		aCollection: 	an OrderedCollection((47@541) corner: (723@634) (0@714) corner: (1...etc...
		aBlock: 	[ :dirtyRect | 
dirtyRect
	allAreasOutsideList: validList
	do: [ :r | 
...etc...
	Receiver's instance variables: 
		origin: 	(0@0)
		corner: 	(255@24)


drawWorld: aWorld submorphs: submorphs invalidAreasOn: aCanvas
	"Redraw the damaged areas of the given canvas and clear the damage list. Return a collection of the areas that
were redrawn."

	| rectList n morphs rects validList |
	rectList := damageRecorder invalidRectsFullBounds: aWorld viewBox.	"sort by areas to draw largest portions first"
	rectList := rectList asArray sort: [ :r1 :r2 | r1 area > r2 area ].
	damageRecorder reset.
	n := submorphs size.
	morphs := OrderedCollection new: n * 2.
	rects := OrderedCollection new: n * 2.
	validList := OrderedCollection new: n * 2.
	rectList
		do: [ :dirtyRect | 
			dirtyRect
				allAreasOutsideList: validList
				do: [ :r | 
					| mm rect i c remnantIntersects remnants rectToFill |
					"Experimental top-down drawing --
			Traverses top to bottom, stopping if the entire area is filled.
			If only a single rectangle remains, then continue with the reduced rectangle."
					rectToFill := r.
					remnants := OrderedCollection with: r.
					i := 1.
					[ remnants isEmpty or: [ i > n ] ]
						whileFalse: [ 
							mm := submorphs at: i.
							((remnantIntersects := remnants select: [ :each | mm fullBounds intersects: each ]) notEmpty and: [ mm visible ])
								ifTrue: [ 
									morphs addLast: mm.
									rects addLast: (Rectangle merging: (remnantIntersects collect: [ :each | mm fullBounds intersect: each ])).
									remnants removeAll: remnantIntersects.
									remnantIntersects do: [ :eachIntersect | remnants addAll: (mm areasRemainingToFill: eachIntersect) ].
									remnants size = 1
										ifTrue: [ rectToFill := remnants first ].
									remnants isEmpty
										ifTrue: [ rectToFill := nil ] ].
							i := i + 1 ].	"Now paint from bottom to top, but using the reduced rectangles."
					rectToFill ifNotNil: [ aWorld drawOn: (c := aCanvas copyClipRect: rectToFill) ].
					[ morphs isEmpty ]
						whileFalse: [ 
							(rect := rects removeLast) == rectToFill
								ifFalse: [ c := aCanvas copyClipRect: (rectToFill := rect) ].
							c fullDrawMorph: morphs removeLast ].
					morphs reset.
					rects reset.
					validList add: r ] ].
	^ validList in WorldState>>drawWorld:submorphs:invalidAreasOn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(22020096) an Assignm...etc...
		aCanvas: 	a FormCanvas on: DisplayScreen(1208x742x32)
		rectList: 	{(47@541) corner: (723@634). (0@714) corner: (1208@742). (0@0) corner...etc...
		validList: 	an OrderedCollection((47@541) corner: (723@634) (0@714) corner: (120...etc...
		n: 	7
		morphs: 	an OrderedCollection(an AssignmentTemp(525860864))
		rects: 	an OrderedCollection((0@0) corner: (255@24))
		dirtyRect: 	(0@0) corner: (255@24)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1208@742)
		canvas: 	a FormCanvas on: DisplayScreen(1208x742x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(13893632))(a SearchMorph...etc...
		lastStepTime: 	2553824
		lastStepMessage: 	nil
		lastCycleTime: 	2553817
		alarms: 	a Heap()
		lastAlarmTime: 	2553824
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


Array(SequenceableCollection)>>do:
	Receiver: {(47@541) corner: (723@634). (0@714) corner: (1208@742). (0@0) corner: (255@24)}
	Arguments and temporary variables: 
		aBlock: 	drawWorld: aWorld submorphs: submorphs invalidAreasOn: aCanvas
	"Redraw...etc...
		index: 	3
	Receiver's instance variables: 
{(47@541) corner: (723@634). (0@714) corner: (1208@742). (0@0) corner: (255@24)}

WorldState>>drawWorld:submorphs:invalidAreasOn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		n: 	7
		morphs: 	an OrderedCollection(an AssignmentTemp(525860864))
		rects: 	an OrderedCollection((0@0) corner: (255@24))
		aWorld: 	a WorldMorph(511705088) [world]
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(22020096) an Assignm...etc...
		aCanvas: 	a FormCanvas on: DisplayScreen(1208x742x32)
		rectList: 	{(47@541) corner: (723@634). (0@714) corner: (1208@742). (0@0) corner...etc...
		validList: 	an OrderedCollection((47@541) corner: (723@634) (0@714) corner: (120...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1208@742)
		canvas: 	a FormCanvas on: DisplayScreen(1208x742x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(13893632))(a SearchMorph...etc...
		lastStepTime: 	2553824
		lastStepMessage: 	nil
		lastCycleTime: 	2553817
		alarms: 	a Heap()
		lastAlarmTime: 	2553824
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


[ 
| worldDamageRects handDamageRects |
worldDamageRects := self drawWorld: aWorld submorphs: submorphs invalidAreasOn: canvas.	"repair world's damage on canvas"	"self handsDo:[:h| h noticeDamageRects: worldDamageRects]."
handsToDraw := self selectHandsToDrawForDamage: worldDamageRects.
handDamageRects := handsToDraw collect: [ :h | h savePatchFrom: canvas ].
allDamage := worldDamageRects , handDamageRects.
handsToDraw reverseDo: [ :h | canvas fullDrawMorph: h ]	"draw hands onto world canvas" ] in WorldState>>displayWorld:submorphs:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(22020096) an Assignm...etc...
		deferredUpdateMode: 	true
		allDamage: 	nil
		handsToDraw: 	nil
		worldDamageRects: 	nil
		handDamageRects: 	nil
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1208@742)
		canvas: 	a FormCanvas on: DisplayScreen(1208x742x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(13893632))(a SearchMorph...etc...
		lastStepTime: 	2553824
		lastStepMessage: 	nil
		lastCycleTime: 	2553817
		alarms: 	a Heap()
		lastAlarmTime: 	2553824
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


FormCanvas>>roundCornersOf:in:during:
	Receiver: a FormCanvas on: DisplayScreen(1208x742x32)
	Arguments and temporary variables: 
		aMorph: 	a WorldMorph(511705088) [world]
		bounds: 	(0@0) corner: (1208@742)
		aBlock: 	[ 
| worldDamageRects handDamageRects |
worldDamageRects := self drawWo...etc...
	Receiver's instance variables: 
		origin: 	(0@0)
		clipRect: 	(0@0) corner: (1208@742)
		form: 	DisplayScreen(1208x742x32)
		port: 	a GrafPort


FormCanvas(Canvas)>>roundCornersOf:during:
	Receiver: a FormCanvas on: DisplayScreen(1208x742x32)
	Arguments and temporary variables: 
		aMorph: 	a WorldMorph(511705088) [world]
		aBlock: 	[ 
| worldDamageRects handDamageRects |
worldDamageRects := self drawWo...etc...
	Receiver's instance variables: 
		origin: 	(0@0)
		clipRect: 	(0@0) corner: (1208@742)
		form: 	DisplayScreen(1208x742x32)
		port: 	a GrafPort


WorldState>>displayWorld:submorphs:
	Receiver: a WorldState
	Arguments and temporary variables: 
		allDamage: 	nil
		handsToDraw: 	nil
		aWorld: 	a WorldMorph(511705088) [world]
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(22020096) an Assignm...etc...
		deferredUpdateMode: 	true
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1208@742)
		canvas: 	a FormCanvas on: DisplayScreen(1208x742x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(13893632))(a SearchMorph...etc...
		lastStepTime: 	2553824
		lastStepMessage: 	nil
		lastCycleTime: 	2553817
		alarms: 	a Heap()
		lastAlarmTime: 	2553824
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>displayWorld
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1208@742)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(22020096) an Assignm...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


[ aWorld displayWorld ] in WorldState>>displayWorldSafely:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1208@742)
		canvas: 	a FormCanvas on: DisplayScreen(1208x742x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(13893632))(a SearchMorph...etc...
		lastStepTime: 	2553824
		lastStepMessage: 	nil
		lastCycleTime: 	2553817
		alarms: 	a Heap()
		lastAlarmTime: 	2553824
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


BlockClosure>>on:do:
	Receiver: [ aWorld displayWorld ]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | errorHandlerBlock cull: ex description cull: ex receiver...etc...
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	WorldState>>displayWorldSafely:
		startpc: 	82
		numArgs: 	0


BlockClosure>>ifError:
	Receiver: [ aWorld displayWorld ]
	Arguments and temporary variables: 
		errorHandlerBlock: 	[ :err :rcvr | 
| errCtx "Handle a drawing error" errMorph |...etc...
	Receiver's instance variables: 
		outerContext: 	WorldState>>displayWorldSafely:
		startpc: 	82
		numArgs: 	0


WorldState>>displayWorldSafely:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1208@742)
		canvas: 	a FormCanvas on: DisplayScreen(1208x742x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(13893632))(a SearchMorph...etc...
		lastStepTime: 	2553824
		lastStepMessage: 	nil
		lastCycleTime: 	2553817
		alarms: 	a Heap()
		lastAlarmTime: 	2553824
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1208@742)
		canvas: 	a FormCanvas on: DisplayScreen(1208x742x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(13893632))(a SearchMorph...etc...
		lastStepTime: 	2553824
		lastStepMessage: 	nil
		lastCycleTime: 	2553817
		alarms: 	a Heap()
		lastAlarmTime: 	2553824
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1208@742)
		canvas: 	a FormCanvas on: DisplayScreen(1208x742x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(13893632))(a SearchMorph...etc...
		lastStepTime: 	2553824
		lastStepMessage: 	nil
		lastCycleTime: 	2553817
		alarms: 	a Heap()
		lastAlarmTime: 	2553824
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1208@742)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(22020096) an Assignm...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
World doOneCycle.
Processor yield.
false ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
Float(Object)>>error:
[ :err :rcvr | 
| errCtx "Handle a drawing error" errMorph |
errCtx := thisContext.
[ 
errCtx := errCtx sender.	"Search the sender chain to find the morph causing the problem"
[ errCtx notNil and: [ errCtx receiver isMorph not ] ] whileTrue: [ errCtx := errCtx sender ].	"If we're at the root of the context chain then we have a fatal drawing problem"
errCtx ifNil: [ ^ self handleFatalDrawingError: err ].
errMorph := errCtx receiver.	"If the morph causing the problem has already the #drawError flag set,
			then search for the next morph above in the caller chain."
errMorph hasProperty: #errorOnDraw ] whileTrue.
errMorph setProperty: #errorOnDraw toValue: true.	"Install the old error handler, so we can re-raise the error"
rcvr error: err ] in WorldState>>displayWorldSafely:
BlockClosure>>cull:cull:
[ :ex | errorHandlerBlock cull: ex description cull: ex receiver ] in BlockClosure>>ifError:
BlockClosure>>cull:
[ self exceptionHandlerBlock cull: exception ] in MethodContext(ContextPart)>>handleSignal:
BlockClosure>>ensure:
MethodContext(ContextPart)>>handleSignal:
MessageNotUnderstood(Exception)>>signal
Float(Object)>>doesNotUnderstand: #isTranslucent
AssignmentTemp(Morph)>>areasRemainingToFill:
[ :eachIntersect | remnants addAll: (mm areasRemainingToFill: eachIntersect) ] in [ :dirtyRect | 
dirtyRect
	allAreasOutsideList: validList
	do: [ :r | 
		| mm rect i c remnantIntersects remnants rectToFill |
		"Experimental top-down drawing --
			Traverses top to bottom, stopping if the entire area is filled.
			If only a single rectangle remains, then continue with the reduced rectangle."
		rectToFill := r.
		remnants := OrderedCollection with: r.
		i := 1.
		[ remnants isEmpty or: [ i > n ] ]
			whileFalse: [ 
				mm := submorphs at: i.
				((remnantIntersects := remnants select: [ :each | mm fullBounds intersects: each ]) notEmpty and: [ mm visible ])
					ifTrue: [ 
						morphs addLast: mm.
						rects addLast: (Rectangle merging: (remnantIntersects collect: [ :each | mm fullBounds intersect: each ])).
						remnants removeAll: remnantIntersects.
						remnantIntersects do: [ :eachIntersect | remnants addAll: (mm areasRemainingToFill: eachIntersect) ].
						remnants size = 1
							ifTrue: [ rectToFill := remnants first ].
						remnants isEmpty
							ifTrue: [ rectToFill := nil ] ].
				i := i + 1 ].	"Now paint from bottom to top, but using the reduced rectangles."
		rectToFill ifNotNil: [ aWorld drawOn: (c := aCanvas copyClipRect: rectToFill) ].
		[ morphs isEmpty ]
			whileFalse: [ 
				(rect := rects removeLast) == rectToFill
					ifFalse: [ c := aCanvas copyClipRect: (rectToFill := rect) ].
				c fullDrawMorph: morphs removeLast ].
		morphs reset.
		rects reset.
		validList add: r ] ] in drawWorld: aWorld submorphs: submorphs invalidAreasOn: aCanvas
	"Redraw the damaged areas of the given canvas and clear the damage list. Return a collection of the areas that
were redrawn."

	| rectList n morphs rects validList |
	rectList := damageRecorder invalidRectsFullBounds: aWorld viewBox.	"sort by areas to draw largest portions first"
	rectList := rectList asArray sort: [ :r1 :r2 | r1 area > r2 area ].
	damageRecorder reset.
	n := submorphs size.
	morphs := OrderedCollection new: n * 2.
	rects := OrderedCollection new: n * 2.
	validList := OrderedCollection new: n * 2.
	rectList
		do: [ :dirtyRect | 
			dirtyRect
				allAreasOutsideList: validList
				do: [ :r | 
					| mm rect i c remnantIntersects remnants rectToFill |
					"Experimental top-down drawing --
			Traverses top to bottom, stopping if the entire area is filled.
			If only a single rectangle remains, then continue with the reduced rectangle."
					rectToFill := r.
					remnants := OrderedCollection with: r.
					i := 1.
					[ remnants isEmpty or: [ i > n ] ]
						whileFalse: [ 
							mm := submorphs at: i.
							((remnantIntersects := remnants select: [ :each | mm fullBounds intersects: each ]) notEmpty and: [ mm visible ])
								ifTrue: [ 
									morphs addLast: mm.
									rects addLast: (Rectangle merging: (remnantIntersects collect: [ :each | mm fullBounds intersect: each ])).
									remnants removeAll: remnantIntersects.
									remnantIntersects do: [ :eachIntersect | remnants addAll: (mm areasRemainingToFill: eachIntersect) ].
									remnants size = 1
										ifTrue: [ rectToFill := remnants first ].
									remnants isEmpty
										ifTrue: [ rectToFill := nil ] ].
							i := i + 1 ].	"Now paint from bottom to top, but using the reduced rectangles."
					rectToFill ifNotNil: [ aWorld drawOn: (c := aCanvas copyClipRect: rectToFill) ].
					[ morphs isEmpty ]
						whileFalse: [ 
							(rect := rects removeLast) == rectToFill
								ifFalse: [ c := aCanvas copyClipRect: (rectToFill := rect) ].
							c fullDrawMorph: morphs removeLast ].
					morphs reset.
					rects reset.
					validList add: r ] ].
	^ validList in WorldState>>drawWorld:submorphs:invalidAreasOn:
OrderedCollection>>do:
[ :dirtyRect | 
dirtyRect
	allAreasOutsideList: validList
	do: [ :r | 
		| mm rect i c remnantIntersects remnants rectToFill |
		"Experimental top-down drawing --
			Traverses top to bottom, stopping if the entire area is filled.
			If only a single rectangle remains, then continue with the reduced rectangle."
		rectToFill := r.
		remnants := OrderedCollection with: r.
		i := 1.
		[ remnants isEmpty or: [ i > n ] ]
			whileFalse: [ 
				mm := submorphs at: i.
				((remnantIntersects := remnants select: [ :each | mm fullBounds intersects: each ]) notEmpty and: [ mm visible ])
					ifTrue: [ 
						morphs addLast: mm.
						rects addLast: (Rectangle merging: (remnantIntersects collect: [ :each | mm fullBounds intersect: each ])).
						remnants removeAll: remnantIntersects.
						remnantIntersects do: [ :eachIntersect | remnants addAll: (mm areasRemainingToFill: eachIntersect) ].
						remnants size = 1
							ifTrue: [ rectToFill := remnants first ].
						remnants isEmpty
							ifTrue: [ rectToFill := nil ] ].
				i := i + 1 ].	"Now paint from bottom to top, but using the reduced rectangles."
		rectToFill ifNotNil: [ aWorld drawOn: (c := aCanvas copyClipRect: rectToFill) ].
		[ morphs isEmpty ]
			whileFalse: [ 
				(rect := rects removeLast) == rectToFill
					ifFalse: [ c := aCanvas copyClipRect: (rectToFill := rect) ].
				c fullDrawMorph: morphs removeLast ].
		morphs reset.
		rects reset.
		validList add: r ] ] in drawWorld: aWorld submorphs: submorphs invalidAreasOn: aCanvas
	"Redraw the damaged areas of the given canvas and clear the damage list. Return a collection of the areas that
were redrawn."

	| rectList n morphs rects validList |
	rectList := damageRecorder invalidRectsFullBounds: aWorld viewBox.	"sort by areas to draw largest portions first"
	rectList := rectList asArray sort: [ :r1 :r2 | r1 area > r2 area ].
	damageRecorder reset.
	n := submorphs size.
	morphs := OrderedCollection new: n * 2.
	rects := OrderedCollection new: n * 2.
	validList := OrderedCollection new: n * 2.
	rectList
		do: [ :dirtyRect | 
			dirtyRect
				allAreasOutsideList: validList
				do: [ :r | 
					| mm rect i c remnantIntersects remnants rectToFill |
					"Experimental top-down drawing --
			Traverses top to bottom, stopping if the entire area is filled.
			If only a single rectangle remains, then continue with the reduced rectangle."
					rectToFill := r.
					remnants := OrderedCollection with: r.
					i := 1.
					[ remnants isEmpty or: [ i > n ] ]
						whileFalse: [ 
							mm := submorphs at: i.
							((remnantIntersects := remnants select: [ :each | mm fullBounds intersects: each ]) notEmpty and: [ mm visible ])
								ifTrue: [ 
									morphs addLast: mm.
									rects addLast: (Rectangle merging: (remnantIntersects collect: [ :each | mm fullBounds intersect: each ])).
									remnants removeAll: remnantIntersects.
									remnantIntersects do: [ :eachIntersect | remnants addAll: (mm areasRemainingToFill: eachIntersect) ].
									remnants size = 1
										ifTrue: [ rectToFill := remnants first ].
									remnants isEmpty
										ifTrue: [ rectToFill := nil ] ].
							i := i + 1 ].	"Now paint from bottom to top, but using the reduced rectangles."
					rectToFill ifNotNil: [ aWorld drawOn: (c := aCanvas copyClipRect: rectToFill) ].
					[ morphs isEmpty ]
						whileFalse: [ 
							(rect := rects removeLast) == rectToFill
								ifFalse: [ c := aCanvas copyClipRect: (rectToFill := rect) ].
							c fullDrawMorph: morphs removeLast ].
					morphs reset.
					rects reset.
					validList add: r ] ].
	^ validList in WorldState>>drawWorld:submorphs:invalidAreasOn:
Rectangle>>allAreasOutsideList:startingAt:do:
Rectangle>>allAreasOutsideList:do:
drawWorld: aWorld submorphs: submorphs invalidAreasOn: aCanvas
	"Redraw the damaged areas of the given canvas and clear the damage list. Return a collection of the areas that
were redrawn."

	| rectList n morphs rects validList |
	rectList := damageRecorder invalidRectsFullBounds: aWorld viewBox.	"sort by areas to draw largest portions first"
	rectList := rectList asArray sort: [ :r1 :r2 | r1 area > r2 area ].
	damageRecorder reset.
	n := submorphs size.
	morphs := OrderedCollection new: n * 2.
	rects := OrderedCollection new: n * 2.
	validList := OrderedCollection new: n * 2.
	rectList
		do: [ :dirtyRect | 
			dirtyRect
				allAreasOutsideList: validList
				do: [ :r | 
					| mm rect i c remnantIntersects remnants rectToFill |
					"Experimental top-down drawing --
			Traverses top to bottom, stopping if the entire area is filled.
			If only a single rectangle remains, then continue with the reduced rectangle."
					rectToFill := r.
					remnants := OrderedCollection with: r.
					i := 1.
					[ remnants isEmpty or: [ i > n ] ]
						whileFalse: [ 
							mm := submorphs at: i.
							((remnantIntersects := remnants select: [ :each | mm fullBounds intersects: each ]) notEmpty and: [ mm visible ])
								ifTrue: [ 
									morphs addLast: mm.
									rects addLast: (Rectangle merging: (remnantIntersects collect: [ :each | mm fullBounds intersect: each ])).
									remnants removeAll: remnantIntersects.
									remnantIntersects do: [ :eachIntersect | remnants addAll: (mm areasRemainingToFill: eachIntersect) ].
									remnants size = 1
										ifTrue: [ rectToFill := remnants first ].
									remnants isEmpty
										ifTrue: [ rectToFill := nil ] ].
							i := i + 1 ].	"Now paint from bottom to top, but using the reduced rectangles."
					rectToFill ifNotNil: [ aWorld drawOn: (c := aCanvas copyClipRect: rectToFill) ].
					[ morphs isEmpty ]
						whileFalse: [ 
							(rect := rects removeLast) == rectToFill
								ifFalse: [ c := aCanvas copyClipRect: (rectToFill := rect) ].
							c fullDrawMorph: morphs removeLast ].
					morphs reset.
					rects reset.
					validList add: r ] ].
	^ validList in WorldState>>drawWorld:submorphs:invalidAreasOn:
Array(SequenceableCollection)>>do:
WorldState>>drawWorld:submorphs:invalidAreasOn:
[ 
| worldDamageRects handDamageRects |
worldDamageRects := self drawWorld: aWorld submorphs: submorphs invalidAreasOn: canvas.	"repair world's damage on canvas"	"self handsDo:[:h| h noticeDamageRects: worldDamageRects]."
handsToDraw := self selectHandsToDrawForDamage: worldDamageRects.
handDamageRects := handsToDraw collect: [ :h | h savePatchFrom: canvas ].
allDamage := worldDamageRects , handDamageRects.
handsToDraw reverseDo: [ :h | canvas fullDrawMorph: h ]	"draw hands onto world canvas" ] in WorldState>>displayWorld:submorphs:
FormCanvas>>roundCornersOf:in:during:
FormCanvas(Canvas)>>roundCornersOf:during:
WorldState>>displayWorld:submorphs:
WorldMorph>>displayWorld
[ aWorld displayWorld ] in WorldState>>displayWorldSafely:
BlockClosure>>on:do:
BlockClosure>>ifError:
WorldState>>displayWorldSafely:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: AssignmentTemp>>label:
17 October 2014 2:40:03.188404 pm

VM: Mac OS - intel - 1090 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30858]

AssignmentTemp(Object)>>doesNotUnderstand: #label:
	Receiver: an AssignmentTemp(365428736)
	Arguments and temporary variables: 
		aMessage: 	label: ''
		exception: 	MessageNotUnderstood: AssignmentTemp>>label:
		resumeValue: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (50@40)
		owner: 	nil
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	nil
		borderWidth: 	2
		borderColor: 	Color black


AssignmentTemp>>initialize
	Receiver: an AssignmentTemp(365428736)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (50@40)
		owner: 	nil
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	nil
		borderWidth: 	2
		borderColor: 	Color black


AssignmentTemp class(Behavior)>>new
	Receiver: AssignmentTemp
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	BorderedMorph
		methodDict: 	a MethodDictionary(#initialize->AssignmentTemp>>#initialize )
		format: 	146
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#AssignmentTemp
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#Assignment
		traitComposition: 	{}
		localSelectors: 	nil
		announcer: 	nil


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'AssignmentTemp new openInWorld'
		itsSelection: 	a Text for 'AssignmentTemp new openInWorld'
		itsSelectionString: 	'AssignmentTemp new openInWorld'
	Receiver's instance variables: 
		ast: 	DoIt
	^ AssignmentTemp new openInWorld
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


SmalltalkEditor>>evaluateSelectionAndDo:
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(676069376)
		selectionShowing: 	true
		model: 	a Workspace
		editingState: 	a SmalltalkEditingState


SmalltalkEditor>>evaluateSelection
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(676069376)
		selectionShowing: 	true
		model: 	a Workspace
		editingState: 	a SmalltalkEditingState


[ textMorph editor evaluateSelection ] in PluggableTextMorph>>doIt
	Receiver: a PluggableTextMorph(919076864)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(122.0@418.0) corner: (562.0@585.0)
		owner: 	a SystemWindow(11534336)
		submorphs: 	an Array(a TransformMorph(833355776))
		fullBounds: 	(122@418) corner: (562@585)
		color: 	Color white
		extension: 	a MorphExtension (654835712) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(958922752)
		scroller: 	a TransformMorph(833355776)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(875036672)
		textMorph: 	a TextMorphForEditView(676069376)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 30)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


[ result := editBlock value ] in PluggableTextMorph>>handleEdit:
	Receiver: a PluggableTextMorph(919076864)
	Arguments and temporary variables: 
		editBlock: 	[ textMorph editor evaluateSelection ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(122.0@418.0) corner: (562.0@585.0)
		owner: 	a SystemWindow(11534336)
		submorphs: 	an Array(a TransformMorph(833355776))
		fullBounds: 	(122@418) corner: (562@585)
		color: 	Color white
		extension: 	a MorphExtension (654835712) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(958922752)
		scroller: 	a TransformMorph(833355776)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(875036672)
		textMorph: 	a TextMorphForEditView(676069376)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 30)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


TextMorphForEditView(TextMorph)>>handleEdit:
	Receiver: a TextMorphForEditView(676069376)
	Arguments and temporary variables: 
		editBlock: 	[ result := editBlock value ]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@18)
		owner: 	a TransformMorph(833355776)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@18)
		color: 	Color black
		extension: 	a MorphExtension (736886784) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'AssignmentTemp new openInWorld'
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(919076864)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


PluggableTextMorph>>handleEdit:
	Receiver: a PluggableTextMorph(919076864)
	Arguments and temporary variables: 
		result: 	nil
		editBlock: 	[ textMorph editor evaluateSelection ]
	Receiver's instance variables: 
		bounds: 	(122.0@418.0) corner: (562.0@585.0)
		owner: 	a SystemWindow(11534336)
		submorphs: 	an Array(a TransformMorph(833355776))
		fullBounds: 	(122@418) corner: (562@585)
		color: 	Color white
		extension: 	a MorphExtension (654835712) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(958922752)
		scroller: 	a TransformMorph(833355776)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(875036672)
		textMorph: 	a TextMorphForEditView(676069376)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 30)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


PluggableTextMorph>>doIt
	Receiver: a PluggableTextMorph(919076864)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(122.0@418.0) corner: (562.0@585.0)
		owner: 	a SystemWindow(11534336)
		submorphs: 	an Array(a TransformMorph(833355776))
		fullBounds: 	(122@418) corner: (562@585)
		color: 	Color white
		extension: 	a MorphExtension (654835712) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(958922752)
		scroller: 	a TransformMorph(833355776)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(875036672)
		textMorph: 	a TextMorphForEditView(676069376)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 30)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


[ :morph | morph doIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
	Receiver: SmalltalkEditor
	Arguments and temporary variables: 
		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a PluggableTextMorph(919076864)
	Receiver's instance variables: 
		superclass: 	TextEditor
		methodDict: 	a MethodDictionary(#argAdvance:->SmalltalkEditor>>#argAdvance: #bro...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SmalltalkEditor
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Text-Edition'
		traitComposition: 	{}
		localSelectors: 	nil
		cmdActions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop...etc...
		shiftCmdActions: 	#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #m...etc...


BlockClosure>>cull:
	Receiver: [ :morph | morph doIt ]
	Arguments and temporary variables: 
		anArg: 	a PluggableTextMorph(919076864)
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	157
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :morph | morph doIt ]
	Arguments and temporary variables: 
		firstArg: 	a PluggableTextMorph(919076864)
		secondArg: 	a PluggableTextMorph(919076864)
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	157
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :morph | morph doIt ]
	Arguments and temporary variables: 
		firstArg: 	a PluggableTextMorph(919076864)
		secondArg: 	a PluggableTextMorph(919076864)
		thirdArg: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	157
		numArgs: 	1


KMCategoryBinding>>completeMatch:buffer:
	Receiver: aKMCategoryTarget(#SmalltalkEditor)
	Arguments and temporary variables: 
		aKeymap: 	#doIt on Cmd + D do [ :morph | morph doIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
	Receiver's instance variables: 
		target: 	a PluggableTextMorph(919076864)
		category: 	a KMCategory
		morph: 	a PluggableTextMorph(919076864)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #doIt on Cmd + D do [ :morph | morph doIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		l: 	aKMCategoryTarget(#SmalltalkEditor)
	Receiver's instance variables: 
		action: 	[ :morph | morph doIt ]
		name: 	#doIt
		shortcut: 	Cmd + D
		defaultShortcut: 	Cmd + D
		description: 	''


Array(SequenceableCollection)>>do:
	Receiver: an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #doIt on Cmd + D do [ :morph | morph doIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ :morph | morph doIt ]
		name: 	#doIt
		shortcut: 	Cmd + D
		defaultShortcut: 	Cmd + D
		description: 	''


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: #doIt on Cmd + D do [ :morph | morph doIt ]

	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		action: 	[ :morph | morph doIt ]
		name: 	#doIt
		shortcut: 	Cmd + D
		defaultShortcut: 	Cmd + D
		description: 	''


[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#doIt on Cmd + D do [ :morph | morph doIt ]

	Receiver's instance variables: 
		name: 	#SmalltalkEditor
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


Set>>do:
	Receiver: a Set(#printIt on Cmd + P do [ :morph | morph printIt ]
 #previousSelection on Cmd + Shift...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	9
		each: 	#doIt on Cmd + D do [ :morph | morph doIt ]

	Receiver's instance variables: 
		tally: 	14
		array: 	an Array(#printIt on Cmd + P do [ :morph | morph printIt ]
 #previousSel...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
	Receiver's instance variables: 
		name: 	#SmalltalkEditor
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: aKMCategoryTarget(#SmalltalkEditor)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		target: 	a PluggableTextMorph(919076864)
		category: 	a KMCategory
		morph: 	a PluggableTextMorph(919076864)


[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#SmalltalkEditor)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#ScrollPane) aKMCategoryTarget(#TextMorph) aKM...etc...
		morph: 	a PluggableTextMorph(919076864)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#ScrollPane) aKMCategoryTarg...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	4
	Receiver's instance variables: 
		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#ScrollPane) aKMCatego...etc...
		firstIndex: 	1
		lastIndex: 	7


KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		association: 	nil
		match: 	nil
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#ScrollPane) aKMCategoryTarget(#TextMorph) aKM...etc...
		morph: 	a PluggableTextMorph(919076864)
		directKeymaps: 	a KMCategory


KMTarget>>dispatch:
	Receiver: a KMTarget
	Arguments and temporary variables: 
		buffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
	Receiver's instance variables: 
		realTarget: 	nil
		morph: 	a PluggableTextMorph(919076864)
		targetSelector: 	#yourself
		directKeymaps: 	nil
		perInstanceCategories: 	nil


[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Cmd-d>']
		targetToDispatch: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>do:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatcher>>dispatchKeystroke:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		aKeyEvent: 	[keystroke '<Cmd-d>']
		chain: 	a KMDispatchChain
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...
		morph: 	a TextMorphForEditView(676069376)
		directKeymaps: 	a KMCategory


TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
	Receiver: a TextMorphForEditView(676069376)
	Arguments and temporary variables: 
		evt: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@18)
		owner: 	a TransformMorph(833355776)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@18)
		color: 	Color black
		extension: 	a MorphExtension (736886784) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'AssignmentTemp new openInWorld'
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(919076864)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(TextMorph)>>handleKeystroke:
	Receiver: a TextMorphForEditView(676069376)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-d>']
		pasteUp: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@18)
		owner: 	a TransformMorph(833355776)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@18)
		color: 	Color black
		extension: 	a MorphExtension (736886784) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'AssignmentTemp new openInWorld'
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(919076864)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


KeyboardEvent>>sentTo:
	Receiver: [keystroke '<Cmd-d>']
	Arguments and temporary variables: 
		anObject: 	a TextMorphForEditView(676069376)
	Receiver's instance variables: 
		timeStamp: 	118281
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#keystroke
		buttons: 	64
		position: 	(30@37.0)
		handler: 	nil
		wasHandled: 	true
		keyValue: 	100
		charCode: 	100
		scanCode: 	2


TextMorphForEditView(Morph)>>handleEvent:
	Receiver: a TextMorphForEditView(676069376)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@18)
		owner: 	a TransformMorph(833355776)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@18)
		color: 	Color black
		extension: 	a MorphExtension (736886784) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'AssignmentTemp new openInWorld'
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(919076864)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(Morph)>>handleFocusEvent:
	Receiver: a TextMorphForEditView(676069376)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@18)
		owner: 	a TransformMorph(833355776)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@18)
		color: 	Color black
		extension: 	a MorphExtension (736886784) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'AssignmentTemp new openInWorld'
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(919076864)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-d>']
		focusHolder: 	a TextMorphForEditView(676069376)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(156@456.0) corner: (172@472.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a TextMorphForEditView(676069376)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(156@456) mouseOver nil nil]
		targetOffset: 	(35.0@38.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 105111 156 456 0 0 0 1)
		lastKeyScanCode: 	2
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	8



--- The full stack ---
AssignmentTemp(Object)>>doesNotUnderstand: #label:
AssignmentTemp>>initialize
AssignmentTemp class(Behavior)>>new
UndefinedObject>>DoIt
OpalCompiler>>evaluate
SmalltalkEditor>>evaluateSelectionAndDo:
SmalltalkEditor>>evaluateSelection
[ textMorph editor evaluateSelection ] in PluggableTextMorph>>doIt
[ result := editBlock value ] in PluggableTextMorph>>handleEdit:
TextMorphForEditView(TextMorph)>>handleEdit:
PluggableTextMorph>>handleEdit:
PluggableTextMorph>>doIt
[ :morph | morph doIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
TextMorphForEditView(TextMorph)>>handleKeystroke:
KeyboardEvent>>sentTo:
TextMorphForEditView(Morph)>>handleEvent:
TextMorphForEditView(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: ByteString>>self
17 October 2014 2:43:19.961292 pm

VM: Mac OS - intel - 1090 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30858]

ByteString(Object)>>doesNotUnderstand: #self
	Receiver: 'Title'
	Arguments and temporary variables: 
		aMessage: 	self
		exception: 	MessageNotUnderstood: ByteString>>self
		resumeValue: 	nil
	Receiver's instance variables: 
'Title'

AssignmentTemp>>initialize
	Receiver: an AssignmentTemp(691011584)
	Arguments and temporary variables: 
		titleLabel: 	a StringMorph(728760320)nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (50@40)
		owner: 	nil
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	nil
		borderWidth: 	2
		borderColor: 	Color black


AssignmentTemp class(Behavior)>>new
	Receiver: AssignmentTemp
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	BorderedMorph
		methodDict: 	a MethodDictionary(#initialize->AssignmentTemp>>#initialize )
		format: 	146
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#AssignmentTemp
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#Assignment
		traitComposition: 	{}
		localSelectors: 	nil
		announcer: 	nil


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'AssignmentTemp new openInWorld'
		itsSelection: 	a Text for 'AssignmentTemp new openInWorld'
		itsSelectionString: 	'AssignmentTemp new openInWorld'
	Receiver's instance variables: 
		ast: 	DoIt
	^ AssignmentTemp new openInWorld
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


SmalltalkEditor>>evaluateSelectionAndDo:
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(157810688)
		selectionShowing: 	true
		model: 	a Workspace
		editingState: 	a SmalltalkEditingState


SmalltalkEditor>>evaluateSelection
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(157810688)
		selectionShowing: 	true
		model: 	a Workspace
		editingState: 	a SmalltalkEditingState


[ textMorph editor evaluateSelection ] in PluggableTextMorph>>doIt
	Receiver: a PluggableTextMorph(1016332288)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(136.0@358.0) corner: (576.0@525.0)
		owner: 	a SystemWindow(415498240)
		submorphs: 	an Array(a TransformMorph(719585280))
		fullBounds: 	(136@358) corner: (576@525)
		color: 	Color white
		extension: 	a MorphExtension (136577024) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(1056178176)
		scroller: 	a TransformMorph(719585280)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(827588608)
		textMorph: 	a TextMorphForEditView(157810688)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 30)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


[ result := editBlock value ] in PluggableTextMorph>>handleEdit:
	Receiver: a PluggableTextMorph(1016332288)
	Arguments and temporary variables: 
		editBlock: 	[ textMorph editor evaluateSelection ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(136.0@358.0) corner: (576.0@525.0)
		owner: 	a SystemWindow(415498240)
		submorphs: 	an Array(a TransformMorph(719585280))
		fullBounds: 	(136@358) corner: (576@525)
		color: 	Color white
		extension: 	a MorphExtension (136577024) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(1056178176)
		scroller: 	a TransformMorph(719585280)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(827588608)
		textMorph: 	a TextMorphForEditView(157810688)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 30)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


TextMorphForEditView(TextMorph)>>handleEdit:
	Receiver: a TextMorphForEditView(157810688)
	Arguments and temporary variables: 
		editBlock: 	[ result := editBlock value ]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@18)
		owner: 	a TransformMorph(719585280)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@18)
		color: 	Color black
		extension: 	a MorphExtension (212598784) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'AssignmentTemp new openInWorld'
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(1016332288)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


PluggableTextMorph>>handleEdit:
	Receiver: a PluggableTextMorph(1016332288)
	Arguments and temporary variables: 
		result: 	nil
		editBlock: 	[ textMorph editor evaluateSelection ]
	Receiver's instance variables: 
		bounds: 	(136.0@358.0) corner: (576.0@525.0)
		owner: 	a SystemWindow(415498240)
		submorphs: 	an Array(a TransformMorph(719585280))
		fullBounds: 	(136@358) corner: (576@525)
		color: 	Color white
		extension: 	a MorphExtension (136577024) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(1056178176)
		scroller: 	a TransformMorph(719585280)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(827588608)
		textMorph: 	a TextMorphForEditView(157810688)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 30)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


PluggableTextMorph>>doIt
	Receiver: a PluggableTextMorph(1016332288)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(136.0@358.0) corner: (576.0@525.0)
		owner: 	a SystemWindow(415498240)
		submorphs: 	an Array(a TransformMorph(719585280))
		fullBounds: 	(136@358) corner: (576@525)
		color: 	Color white
		extension: 	a MorphExtension (136577024) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(1056178176)
		scroller: 	a TransformMorph(719585280)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(827588608)
		textMorph: 	a TextMorphForEditView(157810688)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 30)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


[ :morph | morph doIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
	Receiver: SmalltalkEditor
	Arguments and temporary variables: 
		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a PluggableTextMorph(1016332288)
	Receiver's instance variables: 
		superclass: 	TextEditor
		methodDict: 	a MethodDictionary(#argAdvance:->SmalltalkEditor>>#argAdvance: #bro...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SmalltalkEditor
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Text-Edition'
		traitComposition: 	{}
		localSelectors: 	nil
		cmdActions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop...etc...
		shiftCmdActions: 	#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #m...etc...


BlockClosure>>cull:
	Receiver: [ :morph | morph doIt ]
	Arguments and temporary variables: 
		anArg: 	a PluggableTextMorph(1016332288)
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	157
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :morph | morph doIt ]
	Arguments and temporary variables: 
		firstArg: 	a PluggableTextMorph(1016332288)
		secondArg: 	a PluggableTextMorph(1016332288)
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	157
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :morph | morph doIt ]
	Arguments and temporary variables: 
		firstArg: 	a PluggableTextMorph(1016332288)
		secondArg: 	a PluggableTextMorph(1016332288)
		thirdArg: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	157
		numArgs: 	1


KMCategoryBinding>>completeMatch:buffer:
	Receiver: aKMCategoryTarget(#SmalltalkEditor)
	Arguments and temporary variables: 
		aKeymap: 	#doIt on Cmd + D do [ :morph | morph doIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
	Receiver's instance variables: 
		target: 	a PluggableTextMorph(1016332288)
		category: 	a KMCategory
		morph: 	a PluggableTextMorph(1016332288)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #doIt on Cmd + D do [ :morph | morph doIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		l: 	aKMCategoryTarget(#SmalltalkEditor)
	Receiver's instance variables: 
		action: 	[ :morph | morph doIt ]
		name: 	#doIt
		shortcut: 	Cmd + D
		defaultShortcut: 	Cmd + D
		description: 	''


Array(SequenceableCollection)>>do:
	Receiver: an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #doIt on Cmd + D do [ :morph | morph doIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ :morph | morph doIt ]
		name: 	#doIt
		shortcut: 	Cmd + D
		defaultShortcut: 	Cmd + D
		description: 	''


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: #doIt on Cmd + D do [ :morph | morph doIt ]

	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		action: 	[ :morph | morph doIt ]
		name: 	#doIt
		shortcut: 	Cmd + D
		defaultShortcut: 	Cmd + D
		description: 	''


[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#doIt on Cmd + D do [ :morph | morph doIt ]

	Receiver's instance variables: 
		name: 	#SmalltalkEditor
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


Set>>do:
	Receiver: a Set(#printIt on Cmd + P do [ :morph | morph printIt ]
 #previousSelection on Cmd + Shift...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	9
		each: 	#doIt on Cmd + D do [ :morph | morph doIt ]

	Receiver's instance variables: 
		tally: 	14
		array: 	an Array(#printIt on Cmd + P do [ :morph | morph printIt ]
 #previousSel...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
	Receiver's instance variables: 
		name: 	#SmalltalkEditor
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: aKMCategoryTarget(#SmalltalkEditor)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		target: 	a PluggableTextMorph(1016332288)
		category: 	a KMCategory
		morph: 	a PluggableTextMorph(1016332288)


[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#SmalltalkEditor)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...
		morph: 	a PluggableTextMorph(1016332288)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#MorphFocusCtrlNavigation) a...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	7
	Receiver's instance variables: 
		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#MorphFocusCtrlNavigat...etc...
		firstIndex: 	1
		lastIndex: 	7


KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		association: 	nil
		match: 	nil
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...
		morph: 	a PluggableTextMorph(1016332288)
		directKeymaps: 	a KMCategory


KMTarget>>dispatch:
	Receiver: a KMTarget
	Arguments and temporary variables: 
		buffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
	Receiver's instance variables: 
		realTarget: 	nil
		morph: 	a PluggableTextMorph(1016332288)
		targetSelector: 	#yourself
		directKeymaps: 	nil
		perInstanceCategories: 	nil


[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Cmd-d>']
		targetToDispatch: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>do:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatcher>>dispatchKeystroke:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		aKeyEvent: 	[keystroke '<Cmd-d>']
		chain: 	a KMDispatchChain
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#MorphFocusCtrlN...etc...
		morph: 	a TextMorphForEditView(157810688)
		directKeymaps: 	a KMCategory


TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
	Receiver: a TextMorphForEditView(157810688)
	Arguments and temporary variables: 
		evt: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@18)
		owner: 	a TransformMorph(719585280)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@18)
		color: 	Color black
		extension: 	a MorphExtension (212598784) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'AssignmentTemp new openInWorld'
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(1016332288)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(TextMorph)>>handleKeystroke:
	Receiver: a TextMorphForEditView(157810688)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-d>']
		pasteUp: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@18)
		owner: 	a TransformMorph(719585280)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@18)
		color: 	Color black
		extension: 	a MorphExtension (212598784) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'AssignmentTemp new openInWorld'
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(1016332288)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


KeyboardEvent>>sentTo:
	Receiver: [keystroke '<Cmd-d>']
	Arguments and temporary variables: 
		anObject: 	a TextMorphForEditView(157810688)
	Receiver's instance variables: 
		timeStamp: 	315074
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#keystroke
		buttons: 	64
		position: 	(-4@ -24.0)
		handler: 	nil
		wasHandled: 	true
		keyValue: 	100
		charCode: 	100
		scanCode: 	2


TextMorphForEditView(Morph)>>handleEvent:
	Receiver: a TextMorphForEditView(157810688)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@18)
		owner: 	a TransformMorph(719585280)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@18)
		color: 	Color black
		extension: 	a MorphExtension (212598784) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'AssignmentTemp new openInWorld'
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(1016332288)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(Morph)>>handleFocusEvent:
	Receiver: a TextMorphForEditView(157810688)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@18)
		owner: 	a TransformMorph(719585280)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@18)
		color: 	Color black
		extension: 	a MorphExtension (212598784) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'AssignmentTemp new openInWorld'
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(1016332288)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-d>']
		focusHolder: 	a TextMorphForEditView(157810688)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(136@335.0) corner: (152@351.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(136@335.0) corner: (152@351.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928) [other:  (balloonHelpMorph -> a SimpleB...etc...
		mouseFocus: 	nil
		keyboardFocus: 	a TextMorphForEditView(157810688)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(136@335) mouseOver nil nil]
		targetOffset: 	(46.0@9.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 308351 136 335 0 0 0 1)
		lastKeyScanCode: 	2
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	8



--- The full stack ---
ByteString(Object)>>doesNotUnderstand: #self
AssignmentTemp>>initialize
AssignmentTemp class(Behavior)>>new
UndefinedObject>>DoIt
OpalCompiler>>evaluate
SmalltalkEditor>>evaluateSelectionAndDo:
SmalltalkEditor>>evaluateSelection
[ textMorph editor evaluateSelection ] in PluggableTextMorph>>doIt
[ result := editBlock value ] in PluggableTextMorph>>handleEdit:
TextMorphForEditView(TextMorph)>>handleEdit:
PluggableTextMorph>>handleEdit:
PluggableTextMorph>>doIt
[ :morph | morph doIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
TextMorphForEditView(TextMorph)>>handleKeystroke:
KeyboardEvent>>sentTo:
TextMorphForEditView(Morph)>>handleEvent:
TextMorphForEditView(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: ByteString>>self
17 October 2014 2:43:40.091621 pm

VM: Mac OS - intel - 1090 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30858]

ByteString(Object)>>doesNotUnderstand: #self
	Receiver: 'Title'
	Arguments and temporary variables: 
		aMessage: 	self
		exception: 	MessageNotUnderstood: ByteString>>self
		resumeValue: 	nil
	Receiver's instance variables: 
'Title'

AssignmentTemp>>initialize
	Receiver: an AssignmentTemp(1002176512)
	Arguments and temporary variables: 
		titleLabel: 	a StringMorph(1058013184)nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (50@40)
		owner: 	nil
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	nil
		borderWidth: 	2
		borderColor: 	Color black


AssignmentTemp class(Behavior)>>new
	Receiver: AssignmentTemp
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	BorderedMorph
		methodDict: 	a MethodDictionary(#initialize->AssignmentTemp>>#initialize )
		format: 	146
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#AssignmentTemp
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#Assignment
		traitComposition: 	{}
		localSelectors: 	nil
		announcer: 	nil


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'AssignmentTemp new openInWorld'
		itsSelection: 	a Text for 'AssignmentTemp new openInWorld'
		itsSelectionString: 	'AssignmentTemp new openInWorld'
	Receiver's instance variables: 
		ast: 	DoIt
	^ AssignmentTemp new openInWorld
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


SmalltalkEditor>>evaluateSelectionAndDo:
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(157810688)
		selectionShowing: 	true
		model: 	a Workspace
		editingState: 	a SmalltalkEditingState


SmalltalkEditor>>evaluateSelection
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(157810688)
		selectionShowing: 	true
		model: 	a Workspace
		editingState: 	a SmalltalkEditingState


[ textMorph editor evaluateSelection ] in PluggableTextMorph>>doIt
	Receiver: a PluggableTextMorph(1016332288)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(84.0@334.0) corner: (524.0@501.0)
		owner: 	a SystemWindow(415498240)
		submorphs: 	an Array(a TransformMorph(719585280))
		fullBounds: 	(84@334) corner: (524@501)
		color: 	Color white
		extension: 	a MorphExtension (136577024) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(1056178176)
		scroller: 	a TransformMorph(719585280)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(827588608)
		textMorph: 	a TextMorphForEditView(157810688)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 30)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


[ result := editBlock value ] in PluggableTextMorph>>handleEdit:
	Receiver: a PluggableTextMorph(1016332288)
	Arguments and temporary variables: 
		editBlock: 	[ textMorph editor evaluateSelection ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(84.0@334.0) corner: (524.0@501.0)
		owner: 	a SystemWindow(415498240)
		submorphs: 	an Array(a TransformMorph(719585280))
		fullBounds: 	(84@334) corner: (524@501)
		color: 	Color white
		extension: 	a MorphExtension (136577024) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(1056178176)
		scroller: 	a TransformMorph(719585280)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(827588608)
		textMorph: 	a TextMorphForEditView(157810688)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 30)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


TextMorphForEditView(TextMorph)>>handleEdit:
	Receiver: a TextMorphForEditView(157810688)
	Arguments and temporary variables: 
		editBlock: 	[ result := editBlock value ]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@18)
		owner: 	a TransformMorph(719585280)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@18)
		color: 	Color black
		extension: 	a MorphExtension (212598784) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'AssignmentTemp new openInWorld'
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(1016332288)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


PluggableTextMorph>>handleEdit:
	Receiver: a PluggableTextMorph(1016332288)
	Arguments and temporary variables: 
		result: 	nil
		editBlock: 	[ textMorph editor evaluateSelection ]
	Receiver's instance variables: 
		bounds: 	(84.0@334.0) corner: (524.0@501.0)
		owner: 	a SystemWindow(415498240)
		submorphs: 	an Array(a TransformMorph(719585280))
		fullBounds: 	(84@334) corner: (524@501)
		color: 	Color white
		extension: 	a MorphExtension (136577024) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(1056178176)
		scroller: 	a TransformMorph(719585280)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(827588608)
		textMorph: 	a TextMorphForEditView(157810688)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 30)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


PluggableTextMorph>>doIt
	Receiver: a PluggableTextMorph(1016332288)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(84.0@334.0) corner: (524.0@501.0)
		owner: 	a SystemWindow(415498240)
		submorphs: 	an Array(a TransformMorph(719585280))
		fullBounds: 	(84@334) corner: (524@501)
		color: 	Color white
		extension: 	a MorphExtension (136577024) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(1056178176)
		scroller: 	a TransformMorph(719585280)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(827588608)
		textMorph: 	a TextMorphForEditView(157810688)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 30)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


[ :morph | morph doIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
	Receiver: SmalltalkEditor
	Arguments and temporary variables: 
		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a PluggableTextMorph(1016332288)
	Receiver's instance variables: 
		superclass: 	TextEditor
		methodDict: 	a MethodDictionary(#argAdvance:->SmalltalkEditor>>#argAdvance: #bro...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SmalltalkEditor
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Text-Edition'
		traitComposition: 	{}
		localSelectors: 	nil
		cmdActions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop...etc...
		shiftCmdActions: 	#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #m...etc...


BlockClosure>>cull:
	Receiver: [ :morph | morph doIt ]
	Arguments and temporary variables: 
		anArg: 	a PluggableTextMorph(1016332288)
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	157
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :morph | morph doIt ]
	Arguments and temporary variables: 
		firstArg: 	a PluggableTextMorph(1016332288)
		secondArg: 	a PluggableTextMorph(1016332288)
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	157
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :morph | morph doIt ]
	Arguments and temporary variables: 
		firstArg: 	a PluggableTextMorph(1016332288)
		secondArg: 	a PluggableTextMorph(1016332288)
		thirdArg: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	157
		numArgs: 	1


KMCategoryBinding>>completeMatch:buffer:
	Receiver: aKMCategoryTarget(#SmalltalkEditor)
	Arguments and temporary variables: 
		aKeymap: 	#doIt on Cmd + D do [ :morph | morph doIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
	Receiver's instance variables: 
		target: 	a PluggableTextMorph(1016332288)
		category: 	a KMCategory
		morph: 	a PluggableTextMorph(1016332288)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #doIt on Cmd + D do [ :morph | morph doIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		l: 	aKMCategoryTarget(#SmalltalkEditor)
	Receiver's instance variables: 
		action: 	[ :morph | morph doIt ]
		name: 	#doIt
		shortcut: 	Cmd + D
		defaultShortcut: 	Cmd + D
		description: 	''


Array(SequenceableCollection)>>do:
	Receiver: an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #doIt on Cmd + D do [ :morph | morph doIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ :morph | morph doIt ]
		name: 	#doIt
		shortcut: 	Cmd + D
		defaultShortcut: 	Cmd + D
		description: 	''


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: #doIt on Cmd + D do [ :morph | morph doIt ]

	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		action: 	[ :morph | morph doIt ]
		name: 	#doIt
		shortcut: 	Cmd + D
		defaultShortcut: 	Cmd + D
		description: 	''


[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#doIt on Cmd + D do [ :morph | morph doIt ]

	Receiver's instance variables: 
		name: 	#SmalltalkEditor
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


Set>>do:
	Receiver: a Set(#printIt on Cmd + P do [ :morph | morph printIt ]
 #previousSelection on Cmd + Shift...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	9
		each: 	#doIt on Cmd + D do [ :morph | morph doIt ]

	Receiver's instance variables: 
		tally: 	14
		array: 	an Array(#printIt on Cmd + P do [ :morph | morph printIt ]
 #previousSel...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
	Receiver's instance variables: 
		name: 	#SmalltalkEditor
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: aKMCategoryTarget(#SmalltalkEditor)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		target: 	a PluggableTextMorph(1016332288)
		category: 	a KMCategory
		morph: 	a PluggableTextMorph(1016332288)


[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#SmalltalkEditor)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...
		morph: 	a PluggableTextMorph(1016332288)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#MorphFocusCtrlNavigation) a...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	7
	Receiver's instance variables: 
		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#MorphFocusCtrlNavigat...etc...
		firstIndex: 	1
		lastIndex: 	7


KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		association: 	nil
		match: 	nil
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...
		morph: 	a PluggableTextMorph(1016332288)
		directKeymaps: 	a KMCategory


KMTarget>>dispatch:
	Receiver: a KMTarget
	Arguments and temporary variables: 
		buffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
	Receiver's instance variables: 
		realTarget: 	nil
		morph: 	a PluggableTextMorph(1016332288)
		targetSelector: 	#yourself
		directKeymaps: 	nil
		perInstanceCategories: 	nil


[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Cmd-d>']
		targetToDispatch: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>do:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatcher>>dispatchKeystroke:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		aKeyEvent: 	[keystroke '<Cmd-d>']
		chain: 	a KMDispatchChain
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#MorphFocusCtrlN...etc...
		morph: 	a TextMorphForEditView(157810688)
		directKeymaps: 	a KMCategory


TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
	Receiver: a TextMorphForEditView(157810688)
	Arguments and temporary variables: 
		evt: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@18)
		owner: 	a TransformMorph(719585280)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@18)
		color: 	Color black
		extension: 	a MorphExtension (212598784) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'AssignmentTemp new openInWorld'
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(1016332288)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(TextMorph)>>handleKeystroke:
	Receiver: a TextMorphForEditView(157810688)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-d>']
		pasteUp: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@18)
		owner: 	a TransformMorph(719585280)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@18)
		color: 	Color black
		extension: 	a MorphExtension (212598784) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'AssignmentTemp new openInWorld'
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(1016332288)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


KeyboardEvent>>sentTo:
	Receiver: [keystroke '<Cmd-d>']
	Arguments and temporary variables: 
		anObject: 	a TextMorphForEditView(157810688)
	Receiver's instance variables: 
		timeStamp: 	335207
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#keystroke
		buttons: 	64
		position: 	(109.0@122.0)
		handler: 	nil
		wasHandled: 	true
		keyValue: 	100
		charCode: 	100
		scanCode: 	2


TextMorphForEditView(Morph)>>handleEvent:
	Receiver: a TextMorphForEditView(157810688)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@18)
		owner: 	a TransformMorph(719585280)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@18)
		color: 	Color black
		extension: 	a MorphExtension (212598784) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'AssignmentTemp new openInWorld'
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(1016332288)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(Morph)>>handleFocusEvent:
	Receiver: a TextMorphForEditView(157810688)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@18)
		owner: 	a TransformMorph(719585280)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@18)
		color: 	Color black
		extension: 	a MorphExtension (212598784) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'AssignmentTemp new openInWorld'
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(1016332288)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-d>']
		focusHolder: 	a TextMorphForEditView(157810688)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(197@457.0) corner: (213@473.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a TextMorphForEditView(157810688)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(197@457) mouseOver nil nil]
		targetOffset: 	(113.0@123.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 334398 197 457 0 0 0 1)
		lastKeyScanCode: 	2
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	8



--- The full stack ---
ByteString(Object)>>doesNotUnderstand: #self
AssignmentTemp>>initialize
AssignmentTemp class(Behavior)>>new
UndefinedObject>>DoIt
OpalCompiler>>evaluate
SmalltalkEditor>>evaluateSelectionAndDo:
SmalltalkEditor>>evaluateSelection
[ textMorph editor evaluateSelection ] in PluggableTextMorph>>doIt
[ result := editBlock value ] in PluggableTextMorph>>handleEdit:
TextMorphForEditView(TextMorph)>>handleEdit:
PluggableTextMorph>>handleEdit:
PluggableTextMorph>>doIt
[ :morph | morph doIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
TextMorphForEditView(TextMorph)>>handleKeystroke:
KeyboardEvent>>sentTo:
TextMorphForEditView(Morph)>>handleEvent:
TextMorphForEditView(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: Point>>extent
17 October 2014 2:47:06.147996 pm

VM: Mac OS - intel - 1090 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30858]

Point(Object)>>doesNotUnderstand: #extent
	Receiver: (100@100)
	Arguments and temporary variables: 
		aMessage: 	extent
		exception: 	MessageNotUnderstood: Point>>extent
		resumeValue: 	nil
	Receiver's instance variables: 
		x: 	100
		y: 	100


SimpleButtonMorph(Morph)>>bounds:
	Receiver: a SimpleButtonMorph(952893440)
	Arguments and temporary variables: 
		newBounds: 	(100@100)
		oldExtent: 	(36@20)
		newExtent: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (36@20)
		owner: 	nil
		submorphs: 	an Array(a StringMorph(19660800)'Flash')
		fullBounds: 	nil
		color: 	(Color r: 0.4 g: 0.8 b: 0.6 alpha: 1.0)
		extension: 	a MorphExtension (995885056)
		borderWidth: 	1
		borderColor: 	Color gray
		target: 	nil
		actionSelector: 	#flash
		arguments: 	#()
		actWhen: 	#buttonUp
		oldColor: 	nil
		mouseDownTime: 	nil
		label: 	a StringMorph(19660800)'Flash'
		helpText: 	nil


AssignmentTemp>>initialize
	Receiver: an AssignmentTemp(821559296)
	Arguments and temporary variables: 
		titleLabel: 	a StringMorph(938999808)nil
		convertButton: 	a SimpleButtonMorph(952893440)
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (500@200)
		owner: 	nil
		submorphs: 	an Array(a StringMorph(938999808)nil)
		fullBounds: 	nil
		color: 	(Color r: 0.611 g: 0.988 b: 0.532 alpha: 1.0)
		extension: 	a MorphExtension (920387584)
		borderWidth: 	2
		borderColor: 	Color black


AssignmentTemp class(Behavior)>>new
	Receiver: AssignmentTemp
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	BorderedMorph
		methodDict: 	a MethodDictionary(#initialize->AssignmentTemp>>#initialize )
		format: 	146
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#AssignmentTemp
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#Assignment
		traitComposition: 	{}
		localSelectors: 	nil
		announcer: 	nil


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'AssignmentTemp new openInWorld'
		itsSelection: 	a Text for 'AssignmentTemp new openInWorld'
		itsSelectionString: 	'AssignmentTemp new openInWorld'
	Receiver's instance variables: 
		ast: 	DoIt
	^ AssignmentTemp new openInWorld
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


SmalltalkEditor>>evaluateSelectionAndDo:
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(157810688)
		selectionShowing: 	true
		model: 	a Workspace
		editingState: 	a SmalltalkEditingState


SmalltalkEditor>>evaluateSelection
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(157810688)
		selectionShowing: 	true
		model: 	a Workspace
		editingState: 	a SmalltalkEditingState


[ textMorph editor evaluateSelection ] in PluggableTextMorph>>doIt
	Receiver: a PluggableTextMorph(1016332288)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(84.0@334.0) corner: (524.0@501.0)
		owner: 	a SystemWindow(415498240)
		submorphs: 	an Array(a TransformMorph(719585280))
		fullBounds: 	(84@334) corner: (524@501)
		color: 	Color white
		extension: 	a MorphExtension (136577024) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(1056178176)
		scroller: 	a TransformMorph(719585280)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(827588608)
		textMorph: 	a TextMorphForEditView(157810688)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 30)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


[ result := editBlock value ] in PluggableTextMorph>>handleEdit:
	Receiver: a PluggableTextMorph(1016332288)
	Arguments and temporary variables: 
		editBlock: 	[ textMorph editor evaluateSelection ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(84.0@334.0) corner: (524.0@501.0)
		owner: 	a SystemWindow(415498240)
		submorphs: 	an Array(a TransformMorph(719585280))
		fullBounds: 	(84@334) corner: (524@501)
		color: 	Color white
		extension: 	a MorphExtension (136577024) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(1056178176)
		scroller: 	a TransformMorph(719585280)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(827588608)
		textMorph: 	a TextMorphForEditView(157810688)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 30)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


TextMorphForEditView(TextMorph)>>handleEdit:
	Receiver: a TextMorphForEditView(157810688)
	Arguments and temporary variables: 
		editBlock: 	[ result := editBlock value ]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@18)
		owner: 	a TransformMorph(719585280)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@18)
		color: 	Color black
		extension: 	a MorphExtension (212598784) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'AssignmentTemp new openInWorld'
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(1016332288)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


PluggableTextMorph>>handleEdit:
	Receiver: a PluggableTextMorph(1016332288)
	Arguments and temporary variables: 
		result: 	nil
		editBlock: 	[ textMorph editor evaluateSelection ]
	Receiver's instance variables: 
		bounds: 	(84.0@334.0) corner: (524.0@501.0)
		owner: 	a SystemWindow(415498240)
		submorphs: 	an Array(a TransformMorph(719585280))
		fullBounds: 	(84@334) corner: (524@501)
		color: 	Color white
		extension: 	a MorphExtension (136577024) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(1056178176)
		scroller: 	a TransformMorph(719585280)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(827588608)
		textMorph: 	a TextMorphForEditView(157810688)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 30)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


PluggableTextMorph>>doIt
	Receiver: a PluggableTextMorph(1016332288)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(84.0@334.0) corner: (524.0@501.0)
		owner: 	a SystemWindow(415498240)
		submorphs: 	an Array(a TransformMorph(719585280))
		fullBounds: 	(84@334) corner: (524@501)
		color: 	Color white
		extension: 	a MorphExtension (136577024) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(1056178176)
		scroller: 	a TransformMorph(719585280)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(827588608)
		textMorph: 	a TextMorphForEditView(157810688)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 30)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


[ :morph | morph doIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
	Receiver: SmalltalkEditor
	Arguments and temporary variables: 
		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a PluggableTextMorph(1016332288)
	Receiver's instance variables: 
		superclass: 	TextEditor
		methodDict: 	a MethodDictionary(#argAdvance:->SmalltalkEditor>>#argAdvance: #bro...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SmalltalkEditor
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Text-Edition'
		traitComposition: 	{}
		localSelectors: 	nil
		cmdActions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop...etc...
		shiftCmdActions: 	#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #m...etc...


BlockClosure>>cull:
	Receiver: [ :morph | morph doIt ]
	Arguments and temporary variables: 
		anArg: 	a PluggableTextMorph(1016332288)
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	157
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :morph | morph doIt ]
	Arguments and temporary variables: 
		firstArg: 	a PluggableTextMorph(1016332288)
		secondArg: 	a PluggableTextMorph(1016332288)
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	157
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :morph | morph doIt ]
	Arguments and temporary variables: 
		firstArg: 	a PluggableTextMorph(1016332288)
		secondArg: 	a PluggableTextMorph(1016332288)
		thirdArg: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	157
		numArgs: 	1


KMCategoryBinding>>completeMatch:buffer:
	Receiver: aKMCategoryTarget(#SmalltalkEditor)
	Arguments and temporary variables: 
		aKeymap: 	#doIt on Cmd + D do [ :morph | morph doIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
	Receiver's instance variables: 
		target: 	a PluggableTextMorph(1016332288)
		category: 	a KMCategory
		morph: 	a PluggableTextMorph(1016332288)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #doIt on Cmd + D do [ :morph | morph doIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		l: 	aKMCategoryTarget(#SmalltalkEditor)
	Receiver's instance variables: 
		action: 	[ :morph | morph doIt ]
		name: 	#doIt
		shortcut: 	Cmd + D
		defaultShortcut: 	Cmd + D
		description: 	''


Array(SequenceableCollection)>>do:
	Receiver: an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #doIt on Cmd + D do [ :morph | morph doIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ :morph | morph doIt ]
		name: 	#doIt
		shortcut: 	Cmd + D
		defaultShortcut: 	Cmd + D
		description: 	''


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: #doIt on Cmd + D do [ :morph | morph doIt ]

	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		action: 	[ :morph | morph doIt ]
		name: 	#doIt
		shortcut: 	Cmd + D
		defaultShortcut: 	Cmd + D
		description: 	''


[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#doIt on Cmd + D do [ :morph | morph doIt ]

	Receiver's instance variables: 
		name: 	#SmalltalkEditor
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


Set>>do:
	Receiver: a Set(#printIt on Cmd + P do [ :morph | morph printIt ]
 #previousSelection on Cmd + Shift...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	9
		each: 	#doIt on Cmd + D do [ :morph | morph doIt ]

	Receiver's instance variables: 
		tally: 	14
		array: 	an Array(#printIt on Cmd + P do [ :morph | morph printIt ]
 #previousSel...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
	Receiver's instance variables: 
		name: 	#SmalltalkEditor
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: aKMCategoryTarget(#SmalltalkEditor)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		target: 	a PluggableTextMorph(1016332288)
		category: 	a KMCategory
		morph: 	a PluggableTextMorph(1016332288)


[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#SmalltalkEditor)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...
		morph: 	a PluggableTextMorph(1016332288)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#MorphFocusCtrlNavigation) a...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	7
	Receiver's instance variables: 
		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#MorphFocusCtrlNavigat...etc...
		firstIndex: 	1
		lastIndex: 	7


KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
		association: 	nil
		match: 	nil
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...
		morph: 	a PluggableTextMorph(1016332288)
		directKeymaps: 	a KMCategory


KMTarget>>dispatch:
	Receiver: a KMTarget
	Arguments and temporary variables: 
		buffer: 	an OrderedCollection([keystroke '<Cmd-d>'])
	Receiver's instance variables: 
		realTarget: 	nil
		morph: 	a PluggableTextMorph(1016332288)
		targetSelector: 	#yourself
		directKeymaps: 	nil
		perInstanceCategories: 	nil


[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Cmd-d>']
		targetToDispatch: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>do:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatcher>>dispatchKeystroke:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		aKeyEvent: 	[keystroke '<Cmd-d>']
		chain: 	a KMDispatchChain
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#MorphFocusCtrlN...etc...
		morph: 	a TextMorphForEditView(157810688)
		directKeymaps: 	a KMCategory


TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
	Receiver: a TextMorphForEditView(157810688)
	Arguments and temporary variables: 
		evt: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@18)
		owner: 	a TransformMorph(719585280)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@18)
		color: 	Color black
		extension: 	a MorphExtension (212598784) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'AssignmentTemp new openInWorld'
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(1016332288)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(TextMorph)>>handleKeystroke:
	Receiver: a TextMorphForEditView(157810688)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-d>']
		pasteUp: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@18)
		owner: 	a TransformMorph(719585280)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@18)
		color: 	Color black
		extension: 	a MorphExtension (212598784) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'AssignmentTemp new openInWorld'
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(1016332288)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


KeyboardEvent>>sentTo:
	Receiver: [keystroke '<Cmd-d>']
	Arguments and temporary variables: 
		anObject: 	a TextMorphForEditView(157810688)
	Receiver's instance variables: 
		timeStamp: 	541230
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#keystroke
		buttons: 	64
		position: 	(131.0@80.0)
		handler: 	nil
		wasHandled: 	true
		keyValue: 	100
		charCode: 	100
		scanCode: 	2


TextMorphForEditView(Morph)>>handleEvent:
	Receiver: a TextMorphForEditView(157810688)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@18)
		owner: 	a TransformMorph(719585280)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@18)
		color: 	Color black
		extension: 	a MorphExtension (212598784) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'AssignmentTemp new openInWorld'
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(1016332288)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(Morph)>>handleFocusEvent:
	Receiver: a TextMorphForEditView(157810688)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Cmd-d>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@18)
		owner: 	a TransformMorph(719585280)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@18)
		color: 	Color black
		extension: 	a MorphExtension (212598784) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'AssignmentTemp new openInWorld'
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(1016332288)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil



--- The full stack ---
Point(Object)>>doesNotUnderstand: #extent
SimpleButtonMorph(Morph)>>bounds:
AssignmentTemp>>initialize
AssignmentTemp class(Behavior)>>new
UndefinedObject>>DoIt
OpalCompiler>>evaluate
SmalltalkEditor>>evaluateSelectionAndDo:
SmalltalkEditor>>evaluateSelection
[ textMorph editor evaluateSelection ] in PluggableTextMorph>>doIt
[ result := editBlock value ] in PluggableTextMorph>>handleEdit:
TextMorphForEditView(TextMorph)>>handleEdit:
PluggableTextMorph>>handleEdit:
PluggableTextMorph>>doIt
[ :morph | morph doIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
TextMorphForEditView(TextMorph)>>handleKeystroke:
KeyboardEvent>>sentTo:
TextMorphForEditView(Morph)>>handleEvent:
TextMorphForEditView(Morph)>>handleFocusEvent:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: AssignmentTemp>>convertTemp
17 October 2014 2:49:54.873528 pm

VM: Mac OS - intel - 1090 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30858]

AssignmentTemp(Object)>>doesNotUnderstand: #convertTemp
	Receiver: an AssignmentTemp(1033633792)
	Arguments and temporary variables: 
		aMessage: 	convertTemp
		exception: 	MessageNotUnderstood: AssignmentTemp>>convertTemp
		resumeValue: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (500@500)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	an Array(a SimpleButtonMorph(228851712) a StringMorph(71303168)'Stri...etc...
		fullBounds: 	(0@0) corner: (500@500)
		color: 	(Color r: 0.936 g: 0.318 b: 0.973 alpha: 1.0)
		extension: 	a MorphExtension (52690944)
		borderWidth: 	2
		borderColor: 	Color black


[ target perform: actionSelector withArguments: arguments ] in SimpleButtonMorph>>doButtonAction
	Receiver: a SimpleButtonMorph(228851712)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(200.0@200.0) corner: (300.0@300.0)
		owner: 	an AssignmentTemp(1033633792)
		submorphs: 	an Array(a StringMorph(369360896)'Flash')
		fullBounds: 	(200@200) corner: (300@300)
		color: 	(Color r: 0.4 g: 0.8 b: 0.6 alpha: 1.0)
		extension: 	a MorphExtension (271843328)
		borderWidth: 	1
		borderColor: 	Color gray
		target: 	an AssignmentTemp(1033633792)
		actionSelector: 	#convertTemp
		arguments: 	#()
		actWhen: 	#buttonUp
		oldColor: 	nil
		mouseDownTime: 	709867
		label: 	a StringMorph(369360896)'Flash'
		helpText: 	nil


BlockClosure>>ensure:
	Receiver: [ target perform: actionSelector withArguments: arguments ]
	Arguments and temporary variables: 
		aBlock: 	[ oldcursor show ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SimpleButtonMorph>>doButtonAction
		startpc: 	68
		numArgs: 	0


CursorWithMask(Cursor)>>showWhile:
	Receiver: ((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0
		2r100000000000000000000...etc...
	Arguments and temporary variables: 
		aBlock: 	[ target perform: actionSelector withArguments: arguments ]
		oldcursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0
		2...etc...
	Receiver's instance variables: 
		bits: 	a Bitmap of length 16
		width: 	16
		height: 	16
		depth: 	1
		offset: 	(-1@ -1)
		maskForm: 	Form(16x16x1)


SimpleButtonMorph>>doButtonAction
	Receiver: a SimpleButtonMorph(228851712)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(200.0@200.0) corner: (300.0@300.0)
		owner: 	an AssignmentTemp(1033633792)
		submorphs: 	an Array(a StringMorph(369360896)'Flash')
		fullBounds: 	(200@200) corner: (300@300)
		color: 	(Color r: 0.4 g: 0.8 b: 0.6 alpha: 1.0)
		extension: 	a MorphExtension (271843328)
		borderWidth: 	1
		borderColor: 	Color gray
		target: 	an AssignmentTemp(1033633792)
		actionSelector: 	#convertTemp
		arguments: 	#()
		actWhen: 	#buttonUp
		oldColor: 	nil
		mouseDownTime: 	709867
		label: 	a StringMorph(369360896)'Flash'
		helpText: 	nil


SimpleButtonMorph>>mouseUp:
	Receiver: a SimpleButtonMorph(228851712)
	Arguments and temporary variables: 
		evt: 	[(287@245) mouseUp 709933 nil]
	Receiver's instance variables: 
		bounds: 	(200.0@200.0) corner: (300.0@300.0)
		owner: 	an AssignmentTemp(1033633792)
		submorphs: 	an Array(a StringMorph(369360896)'Flash')
		fullBounds: 	(200@200) corner: (300@300)
		color: 	(Color r: 0.4 g: 0.8 b: 0.6 alpha: 1.0)
		extension: 	a MorphExtension (271843328)
		borderWidth: 	1
		borderColor: 	Color gray
		target: 	an AssignmentTemp(1033633792)
		actionSelector: 	#convertTemp
		arguments: 	#()
		actWhen: 	#buttonUp
		oldColor: 	nil
		mouseDownTime: 	709867
		label: 	a StringMorph(369360896)'Flash'
		helpText: 	nil


SimpleButtonMorph(Morph)>>handleMouseUp:
	Receiver: a SimpleButtonMorph(228851712)
	Arguments and temporary variables: 
		anEvent: 	[(287@245) mouseUp 709933 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(200.0@200.0) corner: (300.0@300.0)
		owner: 	an AssignmentTemp(1033633792)
		submorphs: 	an Array(a StringMorph(369360896)'Flash')
		fullBounds: 	(200@200) corner: (300@300)
		color: 	(Color r: 0.4 g: 0.8 b: 0.6 alpha: 1.0)
		extension: 	a MorphExtension (271843328)
		borderWidth: 	1
		borderColor: 	Color gray
		target: 	an AssignmentTemp(1033633792)
		actionSelector: 	#convertTemp
		arguments: 	#()
		actWhen: 	#buttonUp
		oldColor: 	nil
		mouseDownTime: 	709867
		label: 	a StringMorph(369360896)'Flash'
		helpText: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(287@245) mouseUp 709933 nil]
	Arguments and temporary variables: 
		anObject: 	a SimpleButtonMorph(228851712)
	Receiver's instance variables: 
		timeStamp: 	709933
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(287@245)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


SimpleButtonMorph(Morph)>>handleEvent:
	Receiver: a SimpleButtonMorph(228851712)
	Arguments and temporary variables: 
		anEvent: 	[(287@245) mouseUp 709933 nil]
	Receiver's instance variables: 
		bounds: 	(200.0@200.0) corner: (300.0@300.0)
		owner: 	an AssignmentTemp(1033633792)
		submorphs: 	an Array(a StringMorph(369360896)'Flash')
		fullBounds: 	(200@200) corner: (300@300)
		color: 	(Color r: 0.4 g: 0.8 b: 0.6 alpha: 1.0)
		extension: 	a MorphExtension (271843328)
		borderWidth: 	1
		borderColor: 	Color gray
		target: 	an AssignmentTemp(1033633792)
		actionSelector: 	#convertTemp
		arguments: 	#()
		actWhen: 	#buttonUp
		oldColor: 	nil
		mouseDownTime: 	709867
		label: 	a StringMorph(369360896)'Flash'
		helpText: 	nil


SimpleButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a SimpleButtonMorph(228851712)
	Arguments and temporary variables: 
		anEvent: 	[(287@245) mouseUp 709933 nil]
	Receiver's instance variables: 
		bounds: 	(200.0@200.0) corner: (300.0@300.0)
		owner: 	an AssignmentTemp(1033633792)
		submorphs: 	an Array(a StringMorph(369360896)'Flash')
		fullBounds: 	(200@200) corner: (300@300)
		color: 	(Color r: 0.4 g: 0.8 b: 0.6 alpha: 1.0)
		extension: 	a MorphExtension (271843328)
		borderWidth: 	1
		borderColor: 	Color gray
		target: 	an AssignmentTemp(1033633792)
		actionSelector: 	#convertTemp
		arguments: 	#()
		actWhen: 	#buttonUp
		oldColor: 	nil
		mouseDownTime: 	709867
		label: 	a StringMorph(369360896)'Flash'
		helpText: 	nil


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(287@245) mouseUp 709933 nil]
		focusHolder: 	a SimpleButtonMorph(228851712)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(287@245.0) corner: (303@261.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(287@245.0) corner: (303@261.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a TextMorphForEditView(157810688)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(287@245) mouseOver nil nil]
		targetOffset: 	(87.0@45.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 709933 287 245 0 0 0 1)
		lastKeyScanCode: 	2
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	[(287@245) mouseOver red nil nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1208@742)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an AssignmentTemp(1033633792) a S...etc...
		fullBounds: 	(0@0) corner: (1208@742)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(287@245) mouseUp 709933 nil]
		focusHolder: 	a SimpleButtonMorph(228851712)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		bounds: 	(287@245.0) corner: (303@261.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(287@245.0) corner: (303@261.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a TextMorphForEditView(157810688)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(287@245) mouseOver nil nil]
		targetOffset: 	(87.0@45.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 709933 287 245 0 0 0 1)
		lastKeyScanCode: 	2
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(287@245) mouseUp 709933 nil]
		focusHolder: 	a SimpleButtonMorph(228851712)
		aBlock: 	[ self mouseFocus: nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(287@245.0) corner: (303@261.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(287@245.0) corner: (303@261.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a TextMorphForEditView(157810688)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(287@245) mouseOver nil nil]
		targetOffset: 	(87.0@45.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 709933 287 245 0 0 0 1)
		lastKeyScanCode: 	2
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(287@245) mouseUp 709933 nil]
	Receiver's instance variables: 
		bounds: 	(287@245.0) corner: (303@261.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(287@245.0) corner: (303@261.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a TextMorphForEditView(157810688)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(287@245) mouseOver nil nil]
		targetOffset: 	(87.0@45.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 709933 287 245 0 0 0 1)
		lastKeyScanCode: 	2
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>handleEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(287@245) mouseUp 709933 nil]
		evt: 	[(287@245) mouseUp 709933 nil]
	Receiver's instance variables: 
		bounds: 	(287@245.0) corner: (303@261.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(287@245.0) corner: (303@261.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a TextMorphForEditView(157810688)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(287@245) mouseOver nil nil]
		targetOffset: 	(87.0@45.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 709933 287 245 0 0 0 1)
		lastKeyScanCode: 	2
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>processEvents
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		evt: 	[(287@245) mouseUp 709933 nil]
		evtBuf: 	#(1 709933 287 245 0 0 0 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	(287@245.0) corner: (303@261.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(287@245.0) corner: (303@261.0)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a TextMorphForEditView(157810688)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(287@245) mouseOver nil nil]
		targetOffset: 	(87.0@45.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 709933 287 245 0 0 0 1)
		lastKeyScanCode: 	2
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		h: 	a HandMorph(760479744)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1208@742)
		canvas: 	a FormCanvas on: DisplayScreen(1208x742x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(470024192))(a DropList...etc...
		lastStepTime: 	709981
		lastStepMessage: 	nil
		lastCycleTime: 	709979
		alarms: 	a Heap()
		lastAlarmTime: 	709981
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(760479744))
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(760479744))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1208@742)
		canvas: 	a FormCanvas on: DisplayScreen(1208x742x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(470024192))(a DropList...etc...
		lastStepTime: 	709981
		lastStepMessage: 	nil
		lastCycleTime: 	709979
		alarms: 	a Heap()
		lastAlarmTime: 	709981
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1208@742)
		canvas: 	a FormCanvas on: DisplayScreen(1208x742x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(470024192))(a DropList...etc...
		lastStepTime: 	709981
		lastStepMessage: 	nil
		lastCycleTime: 	709979
		alarms: 	a Heap()
		lastAlarmTime: 	709981
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1208@742)
		canvas: 	a FormCanvas on: DisplayScreen(1208x742x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(470024192))(a DropList...etc...
		lastStepTime: 	709981
		lastStepMessage: 	nil
		lastCycleTime: 	709979
		alarms: 	a Heap()
		lastAlarmTime: 	709981
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1208@742)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) an AssignmentTemp(1033633792) a S...etc...
		fullBounds: 	(0@0) corner: (1208@742)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
World doOneCycle.
Processor yield.
false ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
AssignmentTemp(Object)>>doesNotUnderstand: #convertTemp
[ target perform: actionSelector withArguments: arguments ] in SimpleButtonMorph>>doButtonAction
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
SimpleButtonMorph>>doButtonAction
SimpleButtonMorph>>mouseUp:
SimpleButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SimpleButtonMorph(Morph)>>handleEvent:
SimpleButtonMorph(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: AssignmentTemp>>convertTemp
17 October 2014 2:49:55.355536 pm

VM: Mac OS - intel - 1090 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30858]

AssignmentTemp(Object)>>doesNotUnderstand: #convertTemp
	Receiver: an AssignmentTemp(1033633792)
	Arguments and temporary variables: 
		aMessage: 	convertTemp
		exception: 	MessageNotUnderstood: AssignmentTemp>>convertTemp
		resumeValue: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (500@500)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	an Array(a SimpleButtonMorph(228851712) a StringMorph(71303168)'Stri...etc...
		fullBounds: 	(0@0) corner: (500@500)
		color: 	(Color r: 0.936 g: 0.318 b: 0.973 alpha: 1.0)
		extension: 	a MorphExtension (52690944)
		borderWidth: 	2
		borderColor: 	Color black


[ target perform: actionSelector withArguments: arguments ] in SimpleButtonMorph>>doButtonAction
	Receiver: a SimpleButtonMorph(228851712)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(200.0@200.0) corner: (300.0@300.0)
		owner: 	an AssignmentTemp(1033633792)
		submorphs: 	an Array(a StringMorph(369360896)'Flash')
		fullBounds: 	(200@200) corner: (300@300)
		color: 	(Color r: 0.4 g: 0.8 b: 0.6 alpha: 1.0)
		extension: 	a MorphExtension (271843328)
		borderWidth: 	1
		borderColor: 	Color gray
		target: 	an AssignmentTemp(1033633792)
		actionSelector: 	#convertTemp
		arguments: 	#()
		actWhen: 	#buttonUp
		oldColor: 	nil
		mouseDownTime: 	710408
		label: 	a StringMorph(369360896)'Flash'
		helpText: 	nil


BlockClosure>>ensure:
	Receiver: [ target perform: actionSelector withArguments: arguments ]
	Arguments and temporary variables: 
		aBlock: 	[ oldcursor show ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SimpleButtonMorph>>doButtonAction
		startpc: 	68
		numArgs: 	0


CursorWithMask(Cursor)>>showWhile:
	Receiver: ((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0
		2r100000000000000000000...etc...
	Arguments and temporary variables: 
		aBlock: 	[ target perform: actionSelector withArguments: arguments ]
		oldcursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0
		2...etc...
	Receiver's instance variables: 
		bits: 	a Bitmap of length 16
		width: 	16
		height: 	16
		depth: 	1
		offset: 	(-1@ -1)
		maskForm: 	Form(16x16x1)


SimpleButtonMorph>>doButtonAction
	Receiver: a SimpleButtonMorph(228851712)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(200.0@200.0) corner: (300.0@300.0)
		owner: 	an AssignmentTemp(1033633792)
		submorphs: 	an Array(a StringMorph(369360896)'Flash')
		fullBounds: 	(200@200) corner: (300@300)
		color: 	(Color r: 0.4 g: 0.8 b: 0.6 alpha: 1.0)
		extension: 	a MorphExtension (271843328)
		borderWidth: 	1
		borderColor: 	Color gray
		target: 	an AssignmentTemp(1033633792)
		actionSelector: 	#convertTemp
		arguments: 	#()
		actWhen: 	#buttonUp
		oldColor: 	nil
		mouseDownTime: 	710408
		label: 	a StringMorph(369360896)'Flash'
		helpText: 	nil


SimpleButtonMorph>>mouseUp:
	Receiver: a SimpleButtonMorph(228851712)
	Arguments and temporary variables: 
		evt: 	[(287@245) mouseUp 710474 nil]
	Receiver's instance variables: 
		bounds: 	(200.0@200.0) corner: (300.0@300.0)
		owner: 	an AssignmentTemp(1033633792)
		submorphs: 	an Array(a StringMorph(369360896)'Flash')
		fullBounds: 	(200@200) corner: (300@300)
		color: 	(Color r: 0.4 g: 0.8 b: 0.6 alpha: 1.0)
		extension: 	a MorphExtension (271843328)
		borderWidth: 	1
		borderColor: 	Color gray
		target: 	an AssignmentTemp(1033633792)
		actionSelector: 	#convertTemp
		arguments: 	#()
		actWhen: 	#buttonUp
		oldColor: 	nil
		mouseDownTime: 	710408
		label: 	a StringMorph(369360896)'Flash'
		helpText: 	nil


SimpleButtonMorph(Morph)>>handleMouseUp:
	Receiver: a SimpleButtonMorph(228851712)
	Arguments and temporary variables: 
		anEvent: 	[(287@245) mouseUp 710474 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(200.0@200.0) corner: (300.0@300.0)
		owner: 	an AssignmentTemp(1033633792)
		submorphs: 	an Array(a StringMorph(369360896)'Flash')
		fullBounds: 	(200@200) corner: (300@300)
		color: 	(Color r: 0.4 g: 0.8 b: 0.6 alpha: 1.0)
		extension: 	a MorphExtension (271843328)
		borderWidth: 	1
		borderColor: 	Color gray
		target: 	an AssignmentTemp(1033633792)
		actionSelector: 	#convertTemp
		arguments: 	#()
		actWhen: 	#buttonUp
		oldColor: 	nil
		mouseDownTime: 	710408
		label: 	a StringMorph(369360896)'Flash'
		helpText: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(287@245) mouseUp 710474 nil]
	Arguments and temporary variables: 
		anObject: 	a SimpleButtonMorph(228851712)
	Receiver's instance variables: 
		timeStamp: 	710474
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(287@245)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


SimpleButtonMorph(Morph)>>handleEvent:
	Receiver: a SimpleButtonMorph(228851712)
	Arguments and temporary variables: 
		anEvent: 	[(287@245) mouseUp 710474 nil]
	Receiver's instance variables: 
		bounds: 	(200.0@200.0) corner: (300.0@300.0)
		owner: 	an AssignmentTemp(1033633792)
		submorphs: 	an Array(a StringMorph(369360896)'Flash')
		fullBounds: 	(200@200) corner: (300@300)
		color: 	(Color r: 0.4 g: 0.8 b: 0.6 alpha: 1.0)
		extension: 	a MorphExtension (271843328)
		borderWidth: 	1
		borderColor: 	Color gray
		target: 	an AssignmentTemp(1033633792)
		actionSelector: 	#convertTemp
		arguments: 	#()
		actWhen: 	#buttonUp
		oldColor: 	nil
		mouseDownTime: 	710408
		label: 	a StringMorph(369360896)'Flash'
		helpText: 	nil


SimpleButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a SimpleButtonMorph(228851712)
	Arguments and temporary variables: 
		anEvent: 	[(287@245) mouseUp 710474 nil]
	Receiver's instance variables: 
		bounds: 	(200.0@200.0) corner: (300.0@300.0)
		owner: 	an AssignmentTemp(1033633792)
		submorphs: 	an Array(a StringMorph(369360896)'Flash')
		fullBounds: 	(200@200) corner: (300@300)
		color: 	(Color r: 0.4 g: 0.8 b: 0.6 alpha: 1.0)
		extension: 	a MorphExtension (271843328)
		borderWidth: 	1
		borderColor: 	Color gray
		target: 	an AssignmentTemp(1033633792)
		actionSelector: 	#convertTemp
		arguments: 	#()
		actWhen: 	#buttonUp
		oldColor: 	nil
		mouseDownTime: 	710408
		label: 	a StringMorph(369360896)'Flash'
		helpText: 	nil


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(287@245) mouseUp 710474 nil]
		focusHolder: 	a SimpleButtonMorph(228851712)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(287@245.0) corner: (303@261.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(227803136)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(287@245) mouseOver nil nil]
		targetOffset: 	(87.0@45.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 710474 287 245 0 0 0 1)
		lastKeyScanCode: 	2
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	[(287@245) mouseOver red nil nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1208@742)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(306446336) an Assign...etc...
		fullBounds: 	(0@0) corner: (1208@742)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(287@245) mouseUp 710474 nil]
		focusHolder: 	a SimpleButtonMorph(228851712)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		bounds: 	(287@245.0) corner: (303@261.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(227803136)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(287@245) mouseOver nil nil]
		targetOffset: 	(87.0@45.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 710474 287 245 0 0 0 1)
		lastKeyScanCode: 	2
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(287@245) mouseUp 710474 nil]
		focusHolder: 	a SimpleButtonMorph(228851712)
		aBlock: 	[ self mouseFocus: nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(287@245.0) corner: (303@261.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(227803136)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(287@245) mouseOver nil nil]
		targetOffset: 	(87.0@45.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 710474 287 245 0 0 0 1)
		lastKeyScanCode: 	2
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(287@245) mouseUp 710474 nil]
	Receiver's instance variables: 
		bounds: 	(287@245.0) corner: (303@261.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(227803136)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(287@245) mouseOver nil nil]
		targetOffset: 	(87.0@45.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 710474 287 245 0 0 0 1)
		lastKeyScanCode: 	2
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>handleEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(287@245) mouseUp 710474 nil]
		evt: 	[(287@245) mouseUp 710474 nil]
	Receiver's instance variables: 
		bounds: 	(287@245.0) corner: (303@261.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(227803136)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(287@245) mouseOver nil nil]
		targetOffset: 	(87.0@45.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 710474 287 245 0 0 0 1)
		lastKeyScanCode: 	2
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>processEvents
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		evt: 	[(287@245) mouseUp 710474 nil]
		evtBuf: 	#(1 710474 287 245 0 0 0 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	(287@245.0) corner: (303@261.0)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(227803136)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(287@245) mouseOver nil nil]
		targetOffset: 	(87.0@45.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 710474 287 245 0 0 0 1)
		lastKeyScanCode: 	2
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		h: 	a HandMorph(760479744)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1208@742)
		canvas: 	a FormCanvas on: DisplayScreen(1208x742x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(13893632))(a SearchMorph...etc...
		lastStepTime: 	710496
		lastStepMessage: 	nil
		lastCycleTime: 	710496
		alarms: 	a Heap()
		lastAlarmTime: 	710496
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(760479744))
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(760479744))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1208@742)
		canvas: 	a FormCanvas on: DisplayScreen(1208x742x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(13893632))(a SearchMorph...etc...
		lastStepTime: 	710496
		lastStepMessage: 	nil
		lastCycleTime: 	710496
		alarms: 	a Heap()
		lastAlarmTime: 	710496
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1208@742)
		canvas: 	a FormCanvas on: DisplayScreen(1208x742x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(13893632))(a SearchMorph...etc...
		lastStepTime: 	710496
		lastStepMessage: 	nil
		lastCycleTime: 	710496
		alarms: 	a Heap()
		lastAlarmTime: 	710496
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1208@742)
		canvas: 	a FormCanvas on: DisplayScreen(1208x742x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(13893632))(a SearchMorph...etc...
		lastStepTime: 	710496
		lastStepMessage: 	nil
		lastCycleTime: 	710496
		alarms: 	a Heap()
		lastAlarmTime: 	710496
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1208@742)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SpecWindow(306446336) an Assign...etc...
		fullBounds: 	(0@0) corner: (1208@742)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ 
World doOneCycle.
Processor yield.
false ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
AssignmentTemp(Object)>>doesNotUnderstand: #convertTemp
[ target perform: actionSelector withArguments: arguments ] in SimpleButtonMorph>>doButtonAction
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
SimpleButtonMorph>>doButtonAction
SimpleButtonMorph>>mouseUp:
SimpleButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SimpleButtonMorph(Morph)>>handleEvent:
SimpleButtonMorph(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

